<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web安全之xss学习]]></title>
    <url>%2F2017%2F01%2F05%2Fweb%E5%AE%89%E5%85%A8%E4%B9%8Bxss%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[xss攻击概念就是利用各种手段把恶意代码添加到网页中, 并让受害者执行这段脚本 xss攻击的类型反射型 我们可以用node,express来模拟，客户端在url的search里面传入一段xss攻击的脚本， 比如说img标签，让&quot;xss=&lt;img src=&quot;null&quot; onerror=&quot;alert(1)&quot;&gt;&quot; 这个时候会服务器会接收并解析，xss:req.query.xss,render渲染到模板返回。这个时候如果在服务器设置res.set(‘x-xss-protection’, 0)不让浏览器拦截xss响应，那么就会在页面弹出1。 如果是恶意的，在search栏里面嵌入了iframe，那么会在页面嵌入一个页面，通常见到插入恶意广告，或者直接嵌入一段让用户登陆个人信息的页面，客户输入登陆时，就会泄露了个人的隐私信息。 存储型不是放在search栏里面，而是会存储到服务器端，如数据库，内存，文件系统里面，并不会马上响应回来，下次请求的时候也不用再每次都提交xss代码，通过服务端读取seq里面的文件返回 防御措施编码对用户输入的数据进行HTML Entity编码，一些实体字符，编码成十进制的 过滤移除用户上传的DOM属性，如onerror等移除用户上传的style节点，可以控制页面的显示不显示，js节点，iframe节点 校正避免直接对HTML Entity解码使用DOM Parese转换，校正不匹配的DOM标签 后台接收到之后，对接收到的数据做解码，用正则替换&amp;&lt;等符号为实体字符，进行转义。 前台对后台返回的数据用domParse.js里面的HTMLParse(he.unescape(str, {strict: true}))方法进行先解码，反转义，再解析。domParse会有start,end,char,comment几个函数分别对传入的字符串做html或注释解码，拼接，拼接成一个html元素 这就是前端解码的过程 第三方库的地址：encode.js：可以使用https://github.com/mathiasbynens/he 中的he.js domParse：可以用楼上说的 https://github.com/blowsie/Pure-JavaScript-HTML5-Parser 接下来就是过滤，在前面的函数里面，就将这几个script等的标签过滤掉。校正. 上面的模拟过程在github上有fork的案例 写的比较全面的一个博客：http://www.cnblogs.com/wqhwe/p/5416976.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[图片优化之预加载]]></title>
    <url>%2F2016%2F09%2F22%2F%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E4%B9%8B%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[背景慕课网学习记录： 页面里面图片资源比较丰富的时候，加载比较慢，但是又需要全部展示出来给用户看，一张张加载很容易造成假死，效果很不好。 比如首页有很多图片，展示性的，所以可以用一个loading进度条，显示加载的进度，等加载完毕之后，再全部显示，就需要预加载 或者局部加载，一个评论框，下面可以选择表情，也需要把表情全部展示出来，如果不适用预加载，会看到那些表情是一个个加载的，有快有慢，体验不好。 或者是上一页下一页的图片，点击当前一页图片的时候，提前加载下一页的图片。 概念提前加载图片，当用户需要查看时可直接从本地缓存中渲染，可以保证图片无缝的展示，用户体验更好。 分类有序加载 无序加载 封装插件image-preLoad提供了三个实例： 1.先loading进度条显示进度，图片再无序预加载，进度条加载完毕，展示所有图片。 2.qq表情无序加载，点击选择表情按钮时，loading进度条显示完毕，显示所有图片 3.柯南漫画的有序加载，翻页时提前展示下一页 原理就是： 进度条无序加载的原理是先用一个loading进度条显示的图片覆盖住要显示的页面，然后遍历图片的所有地址，在每次循环的时候new 一个 image图片，然后监听图片的load事件，图片加载完毕，就把地址赋值给图片。直到所有的图片都加载完毕，再让进度条消失，让图片显示出来。 原生代码： &lt;script&gt; var imgs = [ &apos;http://i2.hoopchina.com.cn/user/308/15960308/13383588090.jpg&apos;, &apos;http://img.article.pchome.net/00/44/23/20/pic_lib/wm/2.jpg&apos;, &apos;http://lcd.yesky.com/imagelist/2009/044/404q4y8g4m0p.jpg&apos;, &apos;http://lcd.yesky.com/imagelist/2009/044/cgro54wt2t2x.jpg&apos; ]; var index = 0, // 当前是第几张图片 len = imgs.length, // 图片的总长度 $progress = $(&apos;.progress&apos;), var count = 0 // 当前加载的数量 // 遍历所有图片的src $.each(imgs, function (i, src) { // 创建图片 var imgObj = new Image(); // 当前图片加载完毕的时候 $(imgObj).on(&apos;load error&apos;, function () { // 每加载一次,显示加载 $progress.html(Math.round((count + 1) / len) + &apos;%&apos;); // 如果所有的都加载完毕，就将loading页面隐藏起来 if (count &gt;= len - 1) { $(&apos;loading&apos;).hide(); // 当前页是第一张 document.title = &apos;1/&apos;; } count++; }); imgObj.src = src }) &lt;/script&gt; 封装插件：这里就不详细贴代码了，按照jquery插件封装的方法： 1.一个自执行函数，不会污染全局变量； 2.面向对象的方法，创造一个preload构造函数，传入参数； 3.设置默认参数，用$extend{target, obj1, obj2}进行合并； 4.将有序时执行的方法和无序时的方法挂载在构造函数的原型上； 5.用$.extend({ preLoad: funciton() {new PreLoad()}的方法将其作为工具函数，合并到jquery函数中， // 调用的时候直接：$.perload(传参)即可 如果是$.fn.extend话，是实例方法，要用一个元素去调用。 })]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包对事件处理程序的封装]]></title>
    <url>%2F2016%2F08%2F20%2F%E9%97%AD%E5%8C%85%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[看js高程的时候，闭包讲的并不多，研究了网上很多资料，但是实际用的时候还是不多的，一个是因为会携带其他的作用域，容易造成内存泄漏，一个是没有多少意识去用闭包，前面在性能优化总结的章节里面讲了一个闭包来保存兼容性判断结果的优化思想，这里详细的用代码阐述一下。 js高程里面的eventHandler方法，实际上并不完善，使用的时候，为了做兼容性处理，如果直接使用封装的函数，会导致每一次都要去判断。 普通事件处理程序封装函数： 来找一找问题： 1：没有兼容dom0级事件，且这个函数会每次被调用时都判断浏览器兼容情况，应该用一个闭包函数来优化，一次调用，后面就不用再检测了。 2.addEventLister第三个参数用时间捕获方法不好，多数情况下还是应该用事件冒泡方法； 3.attachEvent事件中listener调用时，因为IE和chrome调用的方式不同，chrome调用时是将e作为参数传入进入的，el.onclcik = function (e) ;而IE是var func = el.onclcik; func()； 没有传递event参数，且执行时this指向window对象，所以listener执行的时候，无法直接获取event事件对象，也无法让直接调用this = el， 所以需要想办法将listener执行时获取window.event参数，且this指向el.onclick的el对象。 闭包封装事件处理程序封装eventRegister.js：/** * 判断浏览器支持的注册事件的方式， 获取一个注册事件的函数 * 闭包封装事件处理程序 * 1.解决IE和普通浏览器的兼容性问题； 2.解决了每次调用方法都判断浏览器是否支持某方法的问题，利用闭包； 3.解决了IE方法调用时无法直接适用event事件对象和this指向window的问题 */ function createEventRegister(){ //如果浏览器支持的是addEventListener if(document.addEventListener){ //就返回一个函数，这个函数内部使用addEventListener来注册事件 return function(ele, type, eventHandler){ ele.addEventListener(type, eventHandler); } }else if(document.attachEvent){ return function(ele, type, eventHandler){ ele.attachEvent(&quot;on&quot; + type, function(){ //这里手动通过上下文调用模式调用这个eventHandler //将里面的this指向当前对象，并且将事件对象作为参数传给了eventHandler eventHandler.call(ele, window.event); }); //var func = div.onclick //func(); } }else{ return function(ele, type, eventHandler){ ele[&quot;on&quot; + type] = eventHandler; } } } 使用方法：&lt;div id=&quot;box&quot;&gt;&lt;/div&gt; // 引入 &lt;script src=&quot;eventRegister.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var div = document.getElementById(&quot;box&quot;); // 保存每次的结果 var eventRegister = createEventRegister(); // 在被监听的元素上使用 eventRegister(div, &quot;click&quot;, function(e){ // console.log(e); // this }) &lt;/script&gt; 解决绑定的封装，js高程写法删除事件：1.dom0级事件：div.onclick = null; 2.IE: var EventUtil = { addHandler: function(element,type,handler) { if (element.addEventListener) { element.addEventListener(type,handler,false); } else if (element.attachEvent) { element.attachEvent(&apos;on&apos;+type,handler); } else { element[&apos;on&apos;+type] = handler; } }, removeHandler: function(element,type,handler) { if (element.removeEventListener) { element.removeEventListener(type,handler,false); } else(element.detachEvent) { element.detachEvent(&apos;on&apos; +type,handler); } else { element[&apos;on&apos;+type] = null; } } }]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目里面用过的性能优化]]></title>
    <url>%2F2016%2F08%2F18%2F%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E7%94%A8%E8%BF%87%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[谈到性能优化，好像是一个很大的命题，其实只要代码写的久一些，总会去思考怎么写才可以让网页速度加载的更快，节约更少的带宽，这并不是在项目实现效果后才会去考虑的问题，要在一开始分析需求，组织结构的时候就有意识去用，去思考。 看过雅虎36条军规，但是很多还是没有实践过的，或者说有些是一开始写js的规则，觉得不值一提的，这里总结一下，开发时候用到过的。 一、尽量减少HTTP请求次数浏览器解析的时候，从上往下执行，页面中的图像，css、js等文件，都需要去外部下载。用gulp或webpack,将文件合并、压缩； 二、图片优化1.写css布局的时候，要给图片一个宽高，给标签一个class名，尽可能不用标签查找2.精灵图页面有很多小图片的时候，做成精灵图，通过控制background-image和background-position来显；缺点是维护起来麻烦，改一张要改整个图片，合并图片麻烦，要合理安排空间。 3.iconfont页面里面的icon比较小，又比较多的时候，用字体图标，制作网站：iconmon 4.base64格式图片图片个数比较少，不超过2kb，请求的频率又比较高，比如网站头部的logo图片，可以用base64,不会发送http请求。webpack-cli默认设置是不超过1kb的用base64.实际使用看业务情况，既考虑大小，也考虑请求的频率。base64制作方法： 1、html5的FileReader()方法里面的readAsDataURL转化， var imgFile = new FileReader(); imgFile.readAsDataURL(img.files[0]); 网址：http://blog.csdn.net/qq_30632003/article/details/61201093 2、canvas的 toDataURL(imgurl)方法也可以转 3、在线工具 5.svg画图标之前项目里面用svg画过两个圆形交叠的图标，去控制进度条显示，这个和canvas很类似，可以在以后项目里多做实践，也不用发送请求 6.移动端2x、3x图按需加载这个在移动端项目里面总结过用法，其实加载还有一个比较新的属性，srcset，只是兼容性不好。 三、懒加载、预加载技术针对页面大图片比较多的情况下，要保证高清效果，还要保证加载速度，不能造成假死，用lazyload插件或者是预加载技术，懒加载是先不给图片src设置真正的地址，等到页面滚动到图片的位置的时候，再给src赋值。 四、缓存思想遇到有用递归来获取的，先把前面的结果缓存起来，下一次递归的时候，先去取值。项目里几乎没用到递归，只是总结一下这个思想。 几种cache： 1. 浏览器缓存 浏览器缓存会将部分资源缓存在本地，当用户向服务器发送请求的时候，这部分资源会直接从本地读取，避免了网络传输数据内容过多，导致访问效率变差的问题！ 2. CDN Content delivery Network 提升网站打开速度！ 3. 硬件缓存 也是为了提升访问效的！ 4. 数据库缓存 硬盘型数据库： MySQL MSSQL ORACLE 内存型数据库： MongoDB Redis 内存型数据经常被用来做缓存，提升数据存取速度！ 补充：2017.5在vue项目里面，有一个很好的方法，keep-alive，可以在当前组件切换到其他组件的时候不销毁页面和数据，而是保存在缓存里面，下一次再调用。另外lazyload也可以使用在vue里面。 五、闭包的去保存事件处理程序的兼容性测试结果js文件写的时候，比如事件处理程序兼容性封装的时候，可以考虑利用闭包的方法，不用每次都去判断浏览器是否支持某种方法，用一个浏览器，检测一次，用变量保存。这个觉得可以专门写一篇分析一下。 六、减少页面的重绘在一个后台项目里面，用模板把请求回来的数据填入模块，渲染到页面上，再下一次，只是部分数据发生变化，有几种方案可以解决，把原来的数据替换，原数组更换，渲染，或者只是把这部分用html字符串拼接方法来改变局部。最后选了后者，虽然看起来麻烦一些，但是渲染的速度更快，减少了dom操作。 七、动态创建元素，添加到页面时候的优化在页面某一部分重新请求了数据，需要重新渲染,在页面添加节点和内容的时候，既可以用document.createElement(‘p’)的方法； 也可以使用innerHTML实行字符串拼接，对于比较多的dom元素创建，比如for循环一个arr数组，然后根据里面的每一项来创建Li标签，采用innerHTML方法效率会更高； 同时，因为字符串品拼接具有不可变性，，频繁拼接会造成内存的浪费，可以考虑优化的方法： 先把每一次循环的字符串push进一个[],然后循环结束，采用arr.join(“”),转成字符串输出 一个展示在线人员图像的示例： &lt;script&gt; var datas = [ // json对象，这是一种数据传输的格式 每个大括号就是一个对象 {&quot;name&quot;: &quot;tdxy01&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;}, {&quot;name&quot;: &quot;沉眠楚人&quot;, &quot;icon&quot;: &quot;images/avatar_11.jpg&quot;}, {&quot;name&quot;: &quot;爱上karina&quot;, &quot;icon&quot;: &quot;images/75_avatar_small.jpg&quot;}, {&quot;name&quot;: &quot;today&quot;, &quot;icon&quot;: &quot;images/avatar_02.jpg&quot;}, {&quot;name&quot;: &quot;hlg&quot;, &quot;icon&quot;: &quot;images/avatar_03.jpg&quot;} ] var arr = []; for (var i = 0; i &lt; datas.length; i++) { var str = &apos;&lt;li&gt;&apos; + &apos;&lt;p&gt;&apos; +datas[i].name+ &apos;&lt;/p&gt;&apos; + &apos;&lt;span&gt;&apos;+datas[i].icon+&apos;&lt;/span&gt;&apos; + &apos;&lt;li&gt;&apos;; arr.push(str); // 将li标签添加到数组里面 } var html = arr.join(&apos;&apos;); // 将数组中的元素连接成字符串 ul.innerHTML = html; &lt;/script&gt; 。。。。未完待续，想到就补充]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端dpr不同时，2x图，3x图的处理方法]]></title>
    <url>%2F2016%2F06%2F16%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFdpr%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C2x%E5%9B%BE%EF%BC%8C3x%E5%9B%BE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前面总结了移动端页面怎么利用rem实现不同屏幕的适配，解决了尺寸一样，随页面缩放时发生变形的问题。 但是因为不同手机的屏幕分辨率不同，尤其是受高清屏的影响，有了设备的物理像素和设备的独立像素（css中的px像素）的区别，同样的页面，独立像素是640 1280，但是物理像素是320 640，写页面的时候，就需要按照 比例为2， 即 640 * 1280来准备图片。 dpr(device pixel ratio).设备像素比window.devicePixelRatio = 物理像素 / 独立像素 浏览器默认的视口获取document.documentElement.clientWidth 首先需要对视口做设置，不允许用户随意缩放： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; // 让viewport宽度 = 设备的宽度 dpr 不同，造成图片再dpr比较大的情况下，被放大，图片失真，所以需要在切图的时候准备对应的2X图和3x图，普通屏幕下，加载高清图又浪费dpr &lt;= 2时，使用2x图 apr &gt;= 2时，使用3x图 比如ipone6是375的屏，切750的2x图，3x图切1125px尺寸下的图 在项目里面，两种写法都用过，没有区别： 1.在common的mixin公共样式里面，写 // 2x和3x图切换的样式，根据media-query来判断 bg-image($url) background-image: url($url + &quot;@2x.png&quot;) @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3) background-image: url($url + &quot;@3x.png&quot;) // $url是前缀，用的时候，先@import引入公共样式，然后 img { bg-image(&apos;beijing&apos;) } 2.也是在公共样式mixin里面写，这个时候根元素里面也需要设置了data-dpr img-dpr(){ background-image: url(image.jpg);//默认 [data-dpr=&quot;2&quot;] &amp; { background-image: url(image@2x.jpg);//两倍高清 } [data-dpr=&quot;3&quot;] &amp; { background-image: url(image@3x.jpg);//三倍高清 } } 先引入mixin样式 .content{ img-dpr(); } 雪碧图使用rem造成像素偏差的问题解决办法：1.先放大100倍，提高图片精度，找到图片位置，再缩小100倍 .icon-fix { background: none; position: relative; overflow: hidden; } .icon-fix:after { content: &apos;&apos;; display: block; width: 10000%; height: 10000%; position: absolute; left: 0; top: 0; background-image: url(sprite.png); background-repeat: no-repeat; background-size: 140rem; -webkit-transform-origin: 0 0; -webkit-transform: scale(.01); transform-origin: 0 0; transform: scale(.01); } .icon3:after { background-position: 0 -280rem; }]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端高清、多屏幕适配方案总结-rem]]></title>
    <url>%2F2016%2F06%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%AB%98%E6%B8%85%E3%80%81%E5%A4%9A%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-rem%2F</url>
    <content type="text"><![CDATA[这篇文章，算是对学习rem及用在手机端项目里面的一个汇总。 rem是什么？在开发移动端h5页面的时候，一套设计图，需要适配不同尺寸的手机，手机的分辨率也不同。所以不能把单位写死为xxpx。 这里对rem、px、em做一个区分： px是绝对字体大小，但是页面缩放的时候因为字体不变，网页还是那么大，会变形。 em计算方式是乘以当前对象从父级遗传的字体大小，参考对象是一个变化的值 父级： height: 1em; // 16px,如果html的font-size是100% 子元素： font-size: 0.625em // 16 * 0.625 = 10px height: 1em // 实际上是10px rem是rem是基于根节点html的字体大小进行计算，浏览器一般默认字体是16px,1em = 16px;但是是css3的新属性，不支持ie678，兼容性处理，再写px或者100% 1.5rem = 根节点默认字体大小 * 1.5 = 24px; // 转化的时候，可以用 28px = 28/16 = 1.75rem 可以把根节点设置为10px或62.5%（100%是16px），方便以10计算而不是16，为了兼容IE7和ie8,默认字体可以设置为： html { font-size: 62.5%; } 利用rem实现多屏幕适配的思路相同的rem,只需要更改页面根元素html的font-size,把和元素尺寸有关的css，如width,height,line-height,margin,padding等都以rem作为单位,这样页面在不同设备下就能保持一致的网页布局，也解决了1px的问题。 怎么判断屏幕的尺寸（宽度），去动态的调整html的font-size？方法一、css media query@media screen and (max-width: 320px) { html{ font-size: 14px; } } @media screen and (min-width: 321px) and (max-width: 413px) { html{ font-size: 16px; } } @media screen and (min-width: 414px) and (max-width: 639px) { html{ font-size: 17px; } } @media screen and (min-width: 640px) { html{ font-size: 18px; } } 方法二、通过js来判断页面宽度，动态调整html的font-size 方法三、引入淘宝的lib-flexible地址：https://github.com/amfe/lib-flexible使用文档说明：http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html1.把flexible.js和flexible_css.js引入，放在head标签的utf-8meta标签下面此时不用再写 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; 2.此时,F12,会发现ip6下面，html的font-size会自动被设置为font-size: 75px（设计稿的尺寸是750），也会给html元素上增加一个data-dpr属性，js会根据不同的设备添加不同的data-dpr值，比如ip6是2. 3写css样式的时候，其他样式尺寸设置为rem，根据标注稿尺寸 / 标注稿基准字体大小来转换 1）实现定义了一个变量来保存基准字体大小 @font-size-base: 75; 2）某一个元素的尺寸设置方式： .item { width: 350rem/@font-size-base; // 350 / 70 = 5rem height: 80rem/@font-size-base; } 标注稿基准字体大小 = 标注稿宽度 / 10，如标注稿宽为750，标注稿基准字体大小为75；标注稿宽为640，标注稿基准字体大小为64；（所以淘宝这个方案是可以在任意设计稿尺寸下使用的） 4.如果还需要设置某一个元素的字体大小，可以根据html的data-dpr属性来处理，写法如下： [data-dpr=&quot;2&quot;] p { font-size: 16px; } [data-dpr=&quot;3&quot;] p { font-size: 24px; } dpr(device pixel ratio).设备像素比；i5,6 = 2;i6plus=3; 使用rem时候的问题，最多的问题就是 小数像素造成background-image 的问题，经常会因为小数像素导致背景图被裁掉一部分。所以可以的话，尽量使用iconfont,或者尽量给背景图设置一定的空白间隙]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github使用之将项目推送到远程仓库]]></title>
    <url>%2F2016%2F03%2F15%2Fgithub%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[总结一下在本地创建好项目之后，把项目推送到github上的步骤： 1 在github创建一个远程仓库2 进入你需要需要创建的文件夹下面，比如，我一般都放置在D/git目录下，点击git bush,运行： $ git clone 仓库地址 可以看到git文件夹下面已经有了一个和远程仓库同名的仓库 3 将你已经完成的项目拷贝过去 4 git切换到当前目录 5.git log 查看日志 6.git status 查看当前状态可以看到未追踪的和已修改的文件 7.如果有.project这样的隐藏目录，不需要提交到github,创建一个ignore文件 $ touch .gitignore 8.把需要忽略的文件写进gitignore里面，如果是忽略文件夹，在后面加/，如$ echo .dir/ &gt;&gt; .gitignore,忽略所有的隐藏文件，.* &gt;&gt; $ echo .project &gt;&gt; .gitignore 9.git status 查看状态 10.把.gitignore自身也忽略不提交 $ echo .gitignore &gt;&gt; .gitignore 如果想操作.gitnore里面的文件，用vi .gitignore进入操作，完成后退出 12.添加到本地仓库 git add -A 13.提交到本地仓库 git commit -m &apos;描述信息&apos; 14 git log 查看日志 15.push到远程仓库,第一次Push加-u $ git push -u origin master 16.下一次需要修改增加项目的时候，先去远程仓库上拉取 $ git pull origin master]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端底部tab或按钮显示问题-css sticky footer]]></title>
    <url>%2F2016%2F03%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BA%95%E9%83%A8tab%E6%88%96%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98-css%20sticky%20footer%2F</url>
    <content type="text"><![CDATA[问题： 项目里面需要设置一个弹出框，下面有一个浮层，浮层上面，分别是内容区块和底部关闭按钮，要求关闭按钮总是固定在窗口底部。 但是实际遇到的问题是，页面内容不够长的时候，页脚块固定在视窗底部；页面内容足够长，需要滚动的时候，页脚块随着内容向下推送，而不是固定视窗底部，挡住了页面的文字。 解决方法：设置三个层，一个内容的包裹层，里面再有一个层，是内容；再有一个层是底部层 // wrapper层 &lt;div class=&quot;detail&quot;&gt; // 和关闭按钮并列的层 &lt;div class=&quot;detail-wrapper clearfix&quot;&gt; // 里面的主题内容层 &lt;div class=&quot;detail-main&quot;&gt;&lt;/div&gt; &lt;/div&gt; // 关闭按钮层 &lt;div class=&quot;detail-close&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; // 样式 .detail /*设置全屏效果，占满视窗*/ position: fixed z-index: 100 top: 0 left: 0 width: 100% height: 100% overflow: auto background-color: rgba(7, 17, 27, 0.8) // filter: blur(10px) // 内容的wrapper层也宽高也占满100%，占满屏幕 .detail-wrapper min-width: 100% height: 100% .detail-main margin-top: 64px padding-bottom: 64px (这个是关键，设置一个下padding，给底部留出空间) .detail-close // 和wrapper层一个层级，wrapper层占有100%的高度，所以footer层永远在视口之外，需要下面用-margin-top调整至视口之内 position: relative width: 32px height: 32px margin: -64px auto 0 auto // 设置一个-margin,将自己放置在上面预留的-margin处 clear: both font-size: 32px]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端click事件时的点透问题]]></title>
    <url>%2F2016%2F03%2F05%2F%E6%89%8B%E6%9C%BA%E7%AB%AFclick%E4%BA%8B%E4%BB%B6%E6%97%B6%E7%9A%84%E7%82%B9%E9%80%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[移动端点透事件，其实网上已经大把这样的案例说明和解决方法，项目里面遇到过一次之后，就已经解决了。 点透事件的原理根据遇到的问题来分析，项目里是一个页面要做一个弹出层，弹出层后面有一个mask，点击mask的时候，弹出层隐藏，但是触发了主页面的input输入框的焦点。 原因就是移动端click有300ms的滞后性，要去判断你是不是缩放，还会不会双击。所以touchend的时候，先隐藏了弹出层和mask，后面真正的点击事件到来的时候，点击的是下面一层。 解决方法： 给这个事件添加阻止默认事件方法：e.preventDefault();但是每一次都要添加，很麻烦。封装了一个tap事件，利用touch事件的执行时机比click要早，通过事件的判断来进行逻辑处理tap.js如下： // 参数1 dom元素 参数2 回调函数 function tap(dom,callBack) { /* tap是轻敲 1. 手指 放上去 离开的速度 很快 2. 手指如果放上去之后 移动了 失效 3. 手指放上去 按了超过一定时间（长按） */ // 获取起始时间 var startTime; var isMove = false; // 标识符 dom.addEventListener(&apos;touchstart&apos;, function (event) { startTime = Date.now(); // 还原isMove的值 isMove = false; }) // 进入到这个事件中 说明 移动了 dom.addEventListener(&apos;touchmove&apos;, function (event) { // console.log(&apos;move&apos;); isMove = true; }) // 计算 停留的时间 dom.addEventListener(&apos;touchend&apos;, function (event) { var delayTime = Date.now() - startTime; // 如果移动了 也失效 if (isMove == true) { // console.log(&apos;移动了，失效&apos;); return; } // 判断停留时间，是否太久了 // 这里的时间 可以根据需求调整 if (delayTime &gt; 300) { // console.log(&apos;太久了，失效&apos;); return; } // 正常执行 // console.log(&apos;轻敲&apos;); callBack(); }) } 用FastClick原理：FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟click 事件，并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。 地址：https://github.com/ftlabs/fastclick/ 用法：1.引入js 2.绑定在document.body上 if (&apos;addEventListener&apos; in document) { document.addEventListener(&apos;DOMContentLoaded&apos;, function() { FastClick.attach(document.body); }, false); } $(function() { FastClick.attach(document.body); }); var attachFastClick = require(&apos;fastclick&apos;); attachFastClick(document.body); fastclick源码分析，转：https://segmentfault.com/a/1190000005850383（转）]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包学习笔记]]></title>
    <url>%2F2015%2F12%2F31%2F%E9%97%AD%E5%8C%85%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天又是一年的平安夜，还是不去人潮里面凑热闹了，一个人的平安夜是虐狗夜，静静的打开电脑，让蓝光屏映在脸旁，再啃一个发的大苹果，继续来学习之旅吧。 闭包知乎上一大把问题和答案，博客也是，早已经被各位大牛分析的很透彻了，但是对小菜鸟来说，不懂依然迷迷糊糊，希望能通过这篇学习笔记，有进一步的认识吧。 闭包的概念函数局部变量在外部是不可以访问的，这个时候，我们就可以在函数内部创建一个函数，这个内部函数就有权访问原函数的私有变量，再把这个内部函数返回出去，在外部调用这个内部函数。 总结起来： 1.函数嵌套函数； 2.能在函数外部访问函数内部声明的变量 闭包的基本模式function add(outerArg) { function inner(innerArg) { return innerArg + outerArg } return inner; } var addTen = add(10); console.log(addTen(1)) // 输出11 console.log(addTen(2)) // 输出12 本质是利用函数的作用域链，函数内部定义的函数，会把外部函数的作用域中的对象添加到自己到作用域链中，因为子对象可以沿着作用域链向上查找父对象的变量。 在外部函数执行完的时候，执行环境（变量）本来应该被销毁，但是因为被return出去的内部函数还在引用外部函数的变量，所以外部函数的变量不会被销毁，仍然保留在内部函数的作用域链里面，直到内部函数被销毁之后，外部函数的变量才会跟着销毁。 闭包调用方式不同，结果不同如果只调用1次外部outer函数，那么多次使用outer()返回的值访问的变量是同一个变量，如果多次调用外部函数，那么每次调用都生成一个新的变量 &lt;script&gt; function func() { var num = Math.random(); return function () { return num; } } //每次的结果相同，因为外部函数func只调用了一次，只开辟了一次空间，存储了num的值，里面的函数每次调用时引用的变量都相同 // var num = func(); // console.log(num()); // console.log(num()); // console.log(num()); //每次结果不同，因为每次调用func的时候都开辟了一个新的空间，所以彼此之间是独立的，作用域是兄弟关系，没有直接联系，互相无法访问，每一次调用时num都生成新的值 console.log(func()()); console.log(func()()); console.log(func()()); &lt;/script&gt; 闭包的用途1.可以使用闭包保护变量，防止放在外部的变量被别人随意修改，使用闭包，可以给别人提供一个访问变量的接口，在定义接口的时候，在为别人提供的修改变量的方法中设置一些校验逻辑，来判断用户设置的数据的合法性 function func(){ var name = &quot;小明&quot;; var yanzhi = 99999999999; var obj = { setYanZhi: function(value){ if(value &lt; 999999999999){ throw &quot;你是不是不想混了！&quot;; } }, getYanZhi: function(){ return yanzhi; } } return obj; } //小同 var o = func(); o.setYanZhi(9999999999999); console.log(o.getYanZhi()); 2.保护变量，暴露接口，获取元素的所有子元素方法 function outer(){ var list = []; function getChildren(ele){ //1. 获取所有的子元素 var children = ele.children; //2. 遍历所有的子元素 for(var i = 0; i &lt; children.length; i++){ var child = children[i]; list.push(child); getChildren(child); } } return { getChildren: getChildren, list : list }; } // var o = outer(); // o.getChildren(body); // o.list就可以访问获取到的结果了！ 闭包的缺陷1.会把外部函数的活动对象都添加到自己的作用域链上，会比普通的函数更耗费内存； 2.垃圾回收机制发现闭包外部函数的变量有人使用的时候，就不会回收。所以会占用内存 闭包的应用场景tab栏切换tab栏切换的时候，给ul下面的每一个li添加点击事件，点击的时候，需要获取当前的li的索引 &lt;ul&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt; &lt;li&gt;item5&lt;/li&gt; &lt;/ul&gt; var list = document.getElementsByTagName(&apos;li&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { list[i].onclick = function() { alert(i); //i=5 } } 点击任意一个li的时候，i的值总是5 因为onclick事件是被异步触发的，先执行的是for循环的同步事件，执行完i是5，onclick被触发的时候，i是5 解决方案1,遍历的时候添加自定义属性index，点击的时候获取： var list = document.getElementsByTagName(&apos;li&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { // 循环的时候就给每一个btn设置自定义属性 list[i].index = i; list[i].onclick = function() { alert(this.index); //解决了问题 } } 解决方案2：闭包，每次一for循环的时候，将i的值存储起来 var list = document.getElementsByTagName(&apos;button&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { // 创建一个闭包 function outer(){ var j = i; function func(){ alert(j); } return func; } var f = outer(); //关键是这一步，for循环的时候就执行了 list[i].onclick = f //每次循环都存储i的值 } // 简化版： for(var i = 0, len = list.length; i &lt; len; i++) { // 创建一个闭包 list[i].onclick = function(j) { return function(){ alert(j) } }(i) } 保护私有变量写js代码的时候，为了防止全局变量污染，也为了别人不能随意更改自己的变量值，所以经常会把自己的代码写在一个自执行函数里面。 但是又想向外面暴露接口，修改里面的值和获取里面的值，修改的时候设置校验条件，判断用户设置的值的合法性，就可以考虑闭包。 var foo = (function(){ var secret = &apos;secret&apos;; return { get_secret: function() { return secret; }, set_secret: function(newValue) { if（newValue &lt; 0）{ throw(&apos;修改值不符合要求&apos;); } secret = newValue; } } }()) foo.get_secret() //&apos;secret&apos; foo.secret // 不能访问 foo.set_secret(&apos;new_secret&apos;); foo.get_secret() // new_secret 解决for循环里面setTimeout问题for(var i = 0; i &lt; 5; i++){ setTimeout(function(){ console.log(new Date, i); }, 1000); } console.log(new Date, i); // 异步的，先for循环完毕，i为5,然后一下子打印5个5 // 5-》5，5，5，5，5 // 解决方法：闭包 for(var i = 0; i &lt; 5; i++){ function outer(){ var j = i; function inner(){ console.log(j); } return inner; } var f = outer(); //每一次for循环都会执行Outer函数，开辟内存，保存当时的i变量 setTimeout(f, 1000); } // 简化之后 for (var i = 0; i &lt; 5; i++) { (function(j) { // i = j setTimeout(function() { console.log(new Date, j) }) })(i) } 或者：闭包的另一种做法： var output = function (i) { setTimeout(function() { console.log(new Date, i); }, 1000); }; for (var i = 0; i &lt; 5; i++) { output(i); // 这里传过去的 i 值被复制了 } console.log(new Date, i); 补充： 其实如果不是需要在外部打印，其实可以用let作用域，把var换成let，就解决了问题。因为let只作用在循环内部的作用域。 补充：看到简书上一个对闭包进一步深化的学习，解决这个问题的需求和答案： 问题： 如果期望代码的输出变成 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？新的需求可以精确的描述为：代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5 1.简单粗暴的解决方法： for (var i = 0; i &lt; 5; i++) { (function(j) { setTimeout(function() { console.log(new Date, j); }, 1000 * j)); // 这里修改 0~4 的定时器时间 })(i); } setTimeout(function() { // 这里增加定时器，超时设置为 5 秒 console.log(new Date, i); }, 1000 * i); 2.虽然解决了问题，但是没有联想起异步操作的Promise方法在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情，代码该怎么组织？ const tasks = []; for (var i = 0; i &lt; 5; i++) { // 这里 i 的声明不能改成 let，如果要改该怎么做？ ((j) =&gt; { tasks.push(new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(new Date, j); resolve(); // 这里一定要 resolve，否则代码不会按预期 work }, 1000 * j); // 定时器的超时时间逐步增加 })); })(i); } Promise.all(tasks).then(() =&gt; { setTimeout(() =&gt; { console.log(new Date, i); }, 1000); // 注意这里只需要把超时设置为 1 秒 }); 下面代码会更简洁明了一些 const tasks = []; // 这里存放异步操作的 Promise const output = (i) =&gt; new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(new Date, i); resolve(); }, 1000 * i); }); // 生成全部的异步操作 for (var i = 0; i &lt; 5; i++) { tasks.push(output(i)); } // 异步操作完成之后，输出最后的 i Promise.all(tasks).then(() =&gt; { setTimeout(() =&gt; { console.log(new Date, i); }, 1000); }); 之前看过几次阮一峰的ES6的Primise讲解，但是实践中用的还是不多，找时间可以再去研究一下。 再补充：佩服原作者的好学精神，还给出了es7的解决方案： // 模拟其他语言中的 sleep，实际上可以是任何异步操作 const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; { setTimeout(resolve, timeountMS); }); (async () =&gt; { // 声明即执行的 async 函数表达式 for (var i = 0; i &lt; 5; i++) { await sleep(1000); console.log(new Date, i); } await sleep(1000); console.log(new Date, i); })(); 这个先占坑，之后再学习一下es7，感觉快跟不上时代了。。。 闭包的优化 比如说一个外部函数，里面定义一个内部函数，我只想用这个内部函数去引用外部函数的一个属性值，但是闭包会把外部函数的所有属性和方法都添加到内部函数的作用域链上，导致占用不必要的内存。 可以把要引用的变量用另外的值保存下来，然后把引用的对象设置为null。 function Outer() { var obj = {}; obj.id = &apos;12345678&apos;; obj.name = &apos;aha&apos;; // ... 假设经过很多处理过程，最后obj上带有很多属性 return function() { return obj.id; }; } function AnotherOuter() { var obj = {}; obj.id = &apos;12345678&apos;; obj.name = &apos;aha&apos;; // ... 假设经过很多处理过程，最后obj上带有很多属性 var id = obj.id; obj = null; return function() { return id; }; }]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端1px的border问题]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E7%9A%84border%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近做一个移动端的页面，踩了很多坑，也有很多小细节，终于找个时间总结一下，记录下来。 问题： 页面中很多border-bottom被设置为1px,在桌面端的时候，没有问题，但是到手机端，看起来会是2px,因为手机的有一个设备像素比，是两倍,设置的是1px，在2倍的像素比下，就是2px. 解决方法： 因为像素不可能是0.5px,最小单位是1px，所以考虑用css3的伪类 + transform方法对其做scale缩放 把原来的border去掉，利用：after重新做border,定位于原来的元素。 并且由于不同设备像素比，缩放比例需要不同。 因为在项目里面使用的比较多，为了增强复用性，需要单独创建一个文件，比如：css/mixin.css，使用的时候将这个文件用@import引入进来 css/mixin.css 设置： /*设置一个border-top为1px的伪类*/ .border-1px { position: relative; border: none; } .border-1px:after { display: block; position: absolute; left: 0; bottom: 0; // 因为设置的是border-bottom width: 100%; border-top: 1px solid #ccc; //height: 1px; content: &apos;&apos; } 注意：stylus或less或sass的写法： .border-1px ($color) { // 样式 &amp;:after // 样式 // 把颜色换成$color } /* 如果是需要设置border-top,用before伪类,设置伪类的border-bottom 但是此时的1px还是和原来直接设置border-bottom: 1px 一样的，并没有缩放效果 */ /*根据设备像素比，用media query来判断，做不同缩放，保证缩放完毕的值 * 设备像素比 = 1px*/ // 在设备像素比是1.5和2时候用scale做缩放 @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7) @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 用法： 1.先引入定义的公用样式，用 @import &apos;地址&apos; 2.设置给需要的元素，比如item元素 .item { border-1px(&apos;#ccc&apos;) // 设置1px的border-bottom }]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局总结]]></title>
    <url>%2F2015%2F05%2F20%2Fcss%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、两列布局写移动端项目的时候，经常遇到左边或右边是图片，需要固定宽度，中间自适应，是图片的内容介绍，需要垂直居中，且和两边高度对齐，这个时候用flex布局比较好，总结了两种比较常用的方法： 第一种：flex左边宽度固定，右边自适应/*父元素*/ .father { display: flex; } /*左边子元素*/ .left { flex: 0 0 30px; width: 30px; } .right { flex: 1; } 第二种：positon定位和padding-left用100%宽的一个div用paading-left把左边图片的位置留出来，图片绝对定位到padding-left区域 例如一个列表项，每一个item下面左边是图片，右边是说明 二、三列布局左侧和右侧固定，中间自适应 1.设置第一个DIV左浮动，第二个DIV右浮动，第三个DIV设置左右MARGIN为两个DIV的固定宽度 #box1 { float: left; width: 300px; background-color: #0099cc; } #box2 { float: right; width: 300px; background-color: #cc6600; } #box3 { height: 500px; background-color: #c30230; margin-left: 300px; margin-right: 300px; } &lt;div id=&quot;box1&quot;&gt;这是div1&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;这是div2&lt;/div&gt; &lt;div id=&quot;box3&quot;&gt;这是div3&lt;/div&gt; 2.父元素宽度100%，相对定位，左右子元素绝对定位，中间子元素设置margin-left和margin-right #wrapper { position: relative; width: 100%; } #box1 { position: absolute; top: 0; left: 0; width: 300px; height: 300px; background-color: #0099cc; } #box2 { height: 400px; margin-left: 300px; margin-right: 300px; background-color: #cc6600; } #box3 { position: absolute; top: 0; right: 0; width: 300px; height: 300px; background-color: #c30230; } 三、多列布局要横向排列的子元素设置float:left或者是display:inline-block,并且设置父元素的font-size为0 经典圣杯布局和淘宝双飞翼布局实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，也就是我们常说的固比固布局页面的宽度的变化，三栏布局是中间盒子优先渲染，两边的盒子框子固定不变 圣杯布局&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;h4&gt;中间弹性区&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;h4&gt;左边栏&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;h4&gt;右边栏&lt;/h4&gt;&lt;/div&gt; &lt;/div&gt; /*middle放在第一个，先渲染，宽度100%*/ .container{ padding: 0 200px; 左右盒子的宽度 height:200px; overflow:hidden; } .middle{ width: 100%; height: 200px; float:left; } .left{ position: relative; left: -200px width: 200px; height: 200px; float:left; margin-left: -100%; // 设置左边盒子负边距为中间盒子的宽度，即100%，可以在中间盒子的左边 } .right{ position: relative; //重点 right: -210px // 重点 width: 200px; height: 200px; float:left; margin-left: -200px; // 关键，这样才能在最右边 } 淘宝的双飞翼布局 淘宝的双飞翼布局是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。 &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inside&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; #middle{ float:left; width:100%;/*左栏上去到第一行*/ height:100px; } #left { float:left; width:180px; height:100px; margin-left:-100%; // 本来在第二行，此时上去到第一行 } #right{ float:left; width:200px; height:100px; margin-left:-200px; // 本来在第二行，此时到第一行 } /*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/ #inside{ margin:0 200px 0 180px; height:100px; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现垂直居中的方法]]></title>
    <url>%2F2015%2F05%2F12%2Fcss%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[不定宽高的子元素垂直水平居中的方法项目里面写静态页面的时候，多次自适应宽高的子元素需要设置垂直水平居中的方法，总结了一下，主要是利用css3的translate和flex两种方法 示例： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;con&quot;&gt;&lt;/div&gt; /div&gt; 第一种：css3的translate方法// 父元素 .box { position: relative; width: 500px; height: 300px; background-color: red; } // 子元素 .con { position: absolute; width: 20%; height: 50%; /*不定宽高*/ left: 50%; /*先移动父元素的50%*/ top: 50%; transform: translate(-50%, -50%); /*移动自身的50%*/ background-color: #000; } 第二种：flex方法.box { display: flex; justify-content: center; /*块居中对齐*/ align-items: center; /*块垂直居中*/ width: 300px; height: 300px; background-color: red; } .con { width: 30%; height: 40%; background-color: #000; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和Github搭建的博客]]></title>
    <url>%2F2015%2F04%2F01%2Fartical%2F</url>
    <content type="text"><![CDATA[博客迁移原因之前一直在印象笔记上做记录，单机版的，时间长了占用大量的本地内存。markdown写起来还是比较少的，偶然看到一个用hexo搭建的博客，简洁明了，花了几个小时的功夫，终于把这个博客搭建起来了，虽然功能还不完善，但是看起来还是很舒服的，后面有时间了再慢慢完善。这几天先把部分笔记迁移过来，权当再复习一遍知识。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>