<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue锚点问题解决]]></title>
    <url>%2F2017%2F08%2F09%2Fvue%E9%94%9A%E7%82%B9%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[昨天电话技术面的时候，面试官提到一个问题，在pc端的时候，怎么处理a标签的锚点问题，因为vue里面router的导航会添加“#”，a标签的href属性添加#时，会作为hash路由跳转，所以需要另外想办法解决。 vue文档里面其实有模拟滚动事件的说明，但是当时真的没有印象了，而且也没有时间查文档，所以直观的就想，不用a标签，用楼层跳跃。 具体思路：左侧用li导航，点击的时候，右侧根据index获取到对应楼层的offsetTop，让window.scroll滚动距离为对应的楼层距离顶部的高度，其中为了动画效果，可以获取当前的位置和目标位置的差/10，每隔30毫秒触发。 通话结束之后，看以一下文档，发现文档里面说明： 当路由的模式是‘history’模式的时候，提供了方法： scrollBehavior（to, from, savedPosition） { // #这种模式，现在不作为路由标志 if(to.hash) { return { // 找到对应的选择器 selector: to.hash } } }) 但是不能用history模式的时候，和我之前想得是差不都的思路，点击的时候，让window.scroll滚动到对应的位置 1.需要处理的a标签的href禁用，绑定点击事件，事件传递参数，参数用#+index的方式来表示； 2.methods里面，处理事件，点击的时候，用this.$el.querySelector(参数)获取到对应id的列表块，然后滚动到这个元素的offsetTop的距离。 注意兼容写法 有一个类似的问题：https://segmentfault.com/q/1010000007888351 以上实现了基本功能，但是效果太过生硬，所以需要用动画处理，因为不能用jquery的animate方法，所以还是需要依靠原生的方法。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[angular1仿拉钩App项目学习总结]]></title>
    <url>%2F2017%2F07%2F25%2Fangular1%E4%BB%BF%E6%8B%89%E9%92%A9App%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[好记性不如烂笔头，之前很早看过一点文档，写过一个豆瓣电影的小demo，几个月之后发现自己已经忘记的差不多了。 这次vue项目之后，感觉两者共通之处还是很多的，又把基本指令学习了一遍，通过这个demo再加深一下学习。 安装包管理工具bowerhttps://segmentfault.com/a/1190000002971135 npm i -g bower bower init bower install --save angular null&gt;.bowerrc 或者 先在目录下创建1.txt文件 命令下进入目录，修改文件名为.bowerrrc ren 1.txt .bowerrc 如果删除文件，uninstall 文件 less预编译 定义变量，比如定义颜色，后代选择器的写法，文件引用，函数 @bgcolor: #fff 引用：background-color: @bgcolor @import ‘1.css’引用 函数：fun(@px) { height: @px} 单页应用：页面跳转无刷新，利用路由控制页面跳转，页面切换流畅，前后端分离 自动化构建工具gulp基于流、任务化的常用API:src、dest、watch、task、pipe gulp中文网 全局安装gulp npm i -g gulp 一路回车 npm i --save-dev gulp 保存在开发依赖中 安装其他模块 npm i --save-dev gulp-clean gulp-concat 或者在package.json里面添加 &quot;gulp-clean&quot;: &quot;^0.3.2&quot;, &quot;gulp-concat&quot;: &quot;^2.6.0&quot;, &quot;gulp-connect&quot;: &quot;^5.0.0&quot;, &quot;gulp-cssmin&quot;: &quot;^0.1.7&quot;, &quot;gulp-imagemin&quot;: &quot;^3.0.3&quot;, &quot;gulp-less&quot;: &quot;^3.1.0&quot;, &quot;gulp-load-plugins&quot;: &quot;^1.2.4&quot;, &quot;gulp-plumber&quot;: &quot;^1.1.0&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot;, &quot;open&quot;: &quot;0.0.5&quot; 然后删除lock文件，执行 npm install 新建一个gulpfile.js文件 var gulp = require(&apos;gulp&apos;); var $ = require(&apos;gulp-load-plugins&apos;)(); var open = require(&apos;open&apos;); // 目录路径 var app = { srcPath: &apos;src/&apos;, devPath: &apos;build/&apos;, prdPath: &apos;dist/&apos; }; // 拷贝文件,将依赖文件放在开发目录和生产目录下 // 定义一个任务 gulp.task(&apos;lib&apos;, function() { // 任务内容 // 读取文件 gulp.src(&apos;bower_components/**/*.js&apos;) // 读取到生产环境和上线环境 .pipe(gulp.dest(app.devPath + &apos;vendor&apos;)) .pipe(gulp.dest(app.prdPath + &apos;vendor&apos;)) // 因为serve服务里面做了watch监控，所以每次src下面的原文件更改之后，会自动构建，构建之后会热启动，刷新页面 .pipe($.connect.reload()) }) 然后执行 gulp lib 可以看到文件目录下面已经有了一个build和dist目录 // 建立html文件,定义任务明恒为 gulp.task(&apos;html&apos;, function() { // 读取这个文件夹下面的所有的html文件，进行拷贝 gulp.src(app.srcPath + &apos;**/*.html&apos;) .pipe(gulp.dest(app.devPath)) .pipe(gulp.dest(app.prdPath)); }) 执行gulp html // 读取假数据的任务，因为此处是没有后台服务器的 gulp.task(&apos;json&apos;, function() { // 从src的data文件夹下读取json文件，读入到build下面的data文件夹下 gulp.src(app.srcPath + &apos;data/**/*.json&apos;) .pipe(gulp.dest(app.devPath + &apos;data&apos;)) .pipe(gulp.dest(app.prdPath + &apos;data&apos;)); }) less任务 在src目录下面建立一个style文件夹，里面写入index.less文件，然后把其他的分割的less文件用@import引入到index.less里面，最后编译的是index.less // less任务 gulp.task(&apos;less&apos;, function() { gulp.src(app.srcPath + &apos;style/index.less&apos;) .pipe($.less()) // 编译完成之后放入生产环境 .pipe(gulp.dest(app.devPath + &apos;css&apos;)) // 压缩 .pipe($.cssmin()) // 压缩之后放入上线环境 .pipe(gulp.dest(app.prdPath + &apos;css&apos;)); }) js任务 // js任务 gulp.task(&apos;js&apos;, function() { gulp.src(app.srcPath + &apos;script/**/*.js&apos;) // 把src下面的所有js合并成一个文件,index.js .pipe($.concat(&apos;index.js&apos;)) // 放入开发目录 .pipe(gulp.dest(app.devPath + &apos;js&apos;)) // 压缩 .pipe($.uglify()) // 发布到生产环境 .pipe(gulp.dest(app.prdPath + &apos;js&apos;)) .pipe($.connect.reload()) }) // 执行 gulp js image任务 // image任务 gulp.task(&apos;image&apos;, function() { gulp.src(app.srcPath + &apos;image/**/*&apos;) .pipe(gulp.dest(app.devPath + &apos;image&apos;)) // 压缩 .pipe($.imagemin()) .pipe(gulp.dest(app.prdPath + &apos;image&apos;)) }) // 打包整个项目，合并,不需要每次一个个的用gulp js等命令启动 gulp.task(&apos;build&apos;, [&apos;image&apos;, &apos;js&apos;, &apos;less&apos;, &apos;lib&apos;, &apos;html&apos;, &apos;json&apos;]); // 服务器任务 gulp.task(&apos;serve&apos;, [&apos;build&apos;], function() { $.connect.server({ // 默认从开发模式下读取 root: [app.devPath], // 自动刷新浏览器，热启动 livereload: true, // 启动端口 port: 1234 }); // 自动打开网址 open(&apos;http://localhost:1234&apos;); // 自动监控src下面的原文件更改，有更改就自动构建 gulp.watch(&apos;bower_components/**/*&apos;, [&apos;lib&apos;]); gulp.watch(app.srcPath + &apos;**/*.html&apos;, [&apos;html&apos;]); gulp.watch(app.srcPath + &apos;data/**/*.json&apos;, [&apos;json&apos;]); gulp.watch(app.srcPath + &apos;style/**/*.less&apos;, [&apos;less&apos;]); gulp.watch(app.srcPath + &apos;script/**/*.js&apos;, [&apos;js&apos;]); gulp.watch(app.srcPath + &apos;image/**/*&apos;, [&apos;image&apos;]); }); // default默认任务，想调用serve的时候，不需要用gulp serve，只需要执行gulp就可以了 gulp.task(&apos;default&apos;, [&apos;serve&apos;]); // clean删除任务，删除两个文件夹 gulp.task(&apos;clean&apos;, function() { gulp.src([app.devPath, app.prdPath]) .pipe($.clean()); }) npm i gulp-plumber --save-dev 作用是： 编译发生错误的时候不会中断线程 需要在gulp.src下面一行加入： .pipe($.plumber()) 模块划分根据模块功能编写，划分为招聘、求职、用户三个模块 求职模块首先在src的index.html里面引入angular.js和index.js 然后写app.js的内容，app.js会在最后编译成index.js 路由配置http://blog.csdn.net/zcl_love_wx/article/details/52034193 目录文件下安装ui-router bower i ui-router --save 但是没有这个文件，1.0版本，去github自己下载导过来 在index.html里面引入 在app.js里面注入依赖 var app = angular.module(&apos;myApp&apos;, [&apos;ui.router&apos;]); 配置文件，路由状态 新建一个config文件夹，定义一个router.js路由文件 app.config([&quot;$stateProvider&quot;, function($stateProvider){ $stateProvider.state(&quot;home&quot;, { //导航用的名字，如&lt;a ui-sref=&quot;login&quot;&gt;login&lt;/a&gt;里的login url: &apos;/&apos;, //访问路径 template:&apos;&lt;div&gt;模板内容......&lt;/div&gt;&apos; }).state(&apos;login&apos;, { // 定义其他路由 }) // 除了上述路由外，处理其他不匹配的路由 $urlRouterProvider.otherwise(&apos;main&apos;); }]); // 定义视图 ui-view替代的是ngroute路由的ng-view。 &lt;div ui-view&gt;&lt;/div&gt; 此时页面进入的时候，会默认定向到main页面 main页面又分为头部，中间列表和下部，所以再建立一个模板文件，里面有head文件，有foot.html文件 路由跳转 ui-sref 使用ui-router自带的ui-sref属性来定义将要跳转的页面的id。 &lt;li ui-sref=&quot;main&quot;&gt;跳转到main页面&lt;/li&gt; 如果要传入参数，如下格式。（）中的对象反映的是传入的参数键值对。 &lt;li ui-sref=&quot;position({id: item.id})&quot;&gt;跳转到position页面&lt;/li&gt; 在position页面对应的控制器中，通过$state.params.id取得查询键。 `angular.module(‘app’) .controller(‘positionCtrl’, [‘$http’, ‘$state’, ‘$scope’, function($http, $state, $scope) { $http.get(&apos;data/position.json&apos;, { params: { id: $state.params.id } }) .then(function() {}, function() {}) }])` 可以通过ui-sref-active给选中的标签添加样式。比如菜单栏。 图片处理底部的三个小图标，要么拼成雪碧图，要么转成base64格式的，小于10kb的 &lt;!--ui-sref-active=&quot;select&quot;点击时候高亮--&gt; &lt;!--ui-sref=&quot;main&quot;点击时候跳转的路由--&gt; 1.在使用Angular 1.6版本的$http服务时会抛出异常：$http.get(…).success is not a function 究其原因，新版本的AngularJs中取消了success和error，用promise规则。 指令http://blog.csdn.net/real_bird/article/details/57129483 1.在父组件中定义属性，属性指向子组件 &lt;div app-position-list data=&quot;list&quot;&gt;&lt;/div&gt; 2.设置子组件的指令 &apos;use strict&apos;; angular.module(&apos;app&apos;).directive(&apos;appPositionList&apos;, [function() { return { restrict: &apos;A&apos;, replace: true, templateUrl: &apos;view/template/positionList.html&apos;, scope: { data: &apos;=&apos;, //表示scope声明的这个属性和mainCtrl控制器是共享的 filterObj: &apos;=&apos;, // 父组件传递过来的过滤对象 isFavorite: &apos;=&apos; }, link: function($scope) { // 点击收藏按钮时，会把当前项发送到后台 $scope.select = function(item) { $http.post(&apos;data/favorite.json&apos;, { id: item.id, select: !item.select }).then(function(res) { item.select = !item.select; }) }; } }; }]); 3.建立子组件的模板，通过指令传递组附件控制器获取的数据 $index/$last在使用ng-repeat渲染元素时，可以使用两个内置的属性观察渲染情况。$scope.$index来查看渲染的子元素的索引，$scope.$last（boolean）来查看是否执行完成，如果是true，表示ng-repeat执行完毕。 &lt;button ng-click=&quot;showPositionList($index)&quot; ng-repeat=&quot;cls in com.positionClass&quot; ng-bind=&quot;cls.name&quot;&gt;&lt;/button&gt; 这个类似于导航栏的按钮，点击后控制器拿到这个$index，根据不同的$index传递给view层不同的数据。 factory/service 自定义一个服务，把服务缓存到cookie里面bower install angular-cookies --save 执行gulp，自动把依赖文件打包到上线和生产环境文件夹下 在index.html里面引入cookie.js文件，在app.js里面添加依赖 写一个cache.js &#39;use strict&#39;; angular.module(&#39;app&#39;).service(&#39;cache&#39;, [&#39;$cookies&#39;, function($cookies){ this.put = function(key, value){ $cookies.put(key, value); }; this.get = function(key) { return $cookies.get(key); }; this.remove = function(key) { $cookies.remove(key); }; }]); 使用时 将’cache’注入到依赖里面 调用cache.put(‘name’, ‘张三’)等方法即可完成cookie的操作 factory方法创建一个服务// 服务的工厂写法 angular.module(&#39;app&#39;).factory(&#39;cache&#39;, [&#39;$cookies&#39;, function ($cookies) { // var obj = {} 私有属性，外部不可访问 return { // 创建一个对象，添加方法 put: function (key, val) { $cookies.put(key, val); }, get: function (key) { return $cookies.get(key); }, remove: function (key) { $cookies.remove(key); } } }])两者区别： factory在return之前，可以声明自己的私有属性 value()和constant()使用constant()来保存一个常量。使用value()函数来缓存全局变量（需要的时候可以直接使用）。 constant()和value()方法之间一个最主要的区别是，常量可以注入到配置函数（.config()）中，而值不行。 angular.module(&apos;app&apos;).constant(&apos;apikey&apos;, &apos;real&apos;) 维度数据缓存 - value()比如根据搜索词返回一个数组列表，然后tab栏是这个数据列表的筛选条件，根据条件显示数据 `’use strict’; // dict是全局变量，缓存对象angular.module(‘app’).value(‘dict’, {}).run([‘dict’, ‘http’, function(dict, $http) { $http.get(‘data/city.json’).then(function(res) { dict.city = res.data; }); $http.get(‘data/salary.json’).then(function(res) { dict.salary = res.data; }); $http.get(‘data/scale.json’).then(function(res) { dict.scale = res.data; });}])` angular.forEachvar objs =[{a:1},{a:2}]; angular.forEach(objs, function(data,index,array){ //data等价于array[index] console.log(data.a+&apos;=&apos;+array[index].a); }); 参数如下： objs：需要遍历的集合 data:遍历时当前的数据 index:遍历时当前索引 array:需要遍历的集合，每次遍历时都会把objs原样的传一次。 或者可以省略后面的参数 var objs =[{a:1},{a:2}]; angular.forEach(objs, function(data){ console.log(data.a); }); 创建自定义过滤器// 船建一个过滤器 &apos;use strict&apos;; angular.module(&apos;app&apos;).filter(&apos;filterByObj&apos;, [function() { // obj是过滤的对象 return function(list, obj) { var result = []; // 遍历原数组 angular.forEach(list, function(item) { // 设置一个标识符 var isEqual = true; // 遍历传入的对象的k for (var k in obj) { // 判断同样的属性的值是不是相等 if (item[k] !== obj[k]) { isEqual = false; } } if (isEqual) { result.push(item); } }); return result; }; }]); 使用： 1.在控制器里面定义过滤条件，是一个对象，有属性： $scope.filterObj[tabId + &apos;Id&apos;] = id; // 相当于 filterObj = { tabId + &apos;Id&apos;: id } 2.在html模板里面定义要传递到子组件的属性 &lt;div app-position-list data=&quot;positionList&quot; filter-obj=&quot;filterObj&quot; class=&quot;search-list&quot;&gt;&lt;/div&gt; 3.子组件控制器里面接收 &apos;use strict&apos;; angular.module(&apos;app&apos;).directive(&apos;appPositionList&apos;, [function() { return { restrict: &apos;A&apos;, replace: true, templateUrl: &apos;view/template/positionList.html&apos;, scope: { data: &apos;=&apos;, //表示scope声明的这个属性和mainCtrl控制器是共享的 filterObj: &apos;=&apos; // 父组件传递过来的过滤对象 } } }])； 3.在子组件里面使用过滤器显示数据 // 要过滤的数据：data | 定义的过滤器名称：过滤器条件对象 &lt;li ui-sref=&quot;position({id:item.id})&quot; class=&quot;item p-r&quot; ng-repeat=&quot;item in data | filterByObj:filterObj&quot;&gt;&lt;/li&gt; $intervalvar interval = $interval(fn, timedelay) $inteval.cancel(interval); // 使用cancel取消这个定时器 // 在原生js中是interval = null; 阻止冒泡ng-click事件有一个事件对象$event。stopPropagation不需要加括号。 &lt;li ng-click=&quot;$event.stopPropagation;select(item);&quot;&gt;&lt;/li&gt; 表单验证https://github.com/hueitan/angular-validation bower install --save angular-validation 1.去index.html里面引入 2.去app.js里面添加依赖 3.写一个validation.js服务 &apos;use strict&apos;; angular.module(&apos;app&apos;).config([&apos;$validationProvider&apos;, function($validationProvider) { // 校验规则 var expression = { phone: /^1[\d]{10}$/, password: function(value) { var str = value + &apos;&apos;; return str.length &gt; 5; }, required: function(value) { return !!value; } }; // 错误提示信息 var defaultMsg = { phone: { success: &apos;&apos;, error: &apos;必须是11位手机号码&apos; }, password: { success: &apos;&apos;, error: &apos;长度至少6位&apos; }, required: { success: &apos;&apos;, error: &apos;不能为空&apos; } }; $validationProvider.setExpression(expression).setDefaultMsg(defaultMsg); }]); 4.在html文件里面添加校验规则代码： validator=&quot;required,phone&quot; validation-submit=&quot;form&quot; 装饰器$provide.decorator()装饰器是非常强大的，它不仅可以应用在我们的我们自己的服务上，也可以对AngularJS的核心服务进行拦截、中断甚至替换功能的操作。事实上angularjs中很多功能的测试就是借助$provide.decorator()建立的。 由于这个项目没有后端，为了模拟post请求，我们需要修改$http内置的post请求。 angular.module(&apos;app&apos;) .config([&apos;$provide&apos;, function($provide) { $provide.decorator(&apos;$http&apos;, [&apos;$delegate&apos;, &apos;$q&apos;, function($delegate, $q) { $delegate.post = function(url, data, config) { var def = $q.defer(); $delegate.get(url).then(function(res) { def.resolve(res.data); }, function(err) { def.reject(err); }) return { success: function(cb) { def.promise.then(cb); }, error: function(cb) { def.promise.then(null, cb); } } } return $delegate; }]) }]) decorator()函数可以接受两个参数。 name （字符串）将要拦截的服务名称 decoratorFn（函数）在服务实例化时调用该函数，这个函数由injector.invoke调用，可以将服务注入这个函数中。$delegate是可以进行装饰的最原始的服务，为了装饰其他服务，需要将其注入进装饰器。 $q内置的$q服务用来在Angular中创建promise。如上所述，我们使用$q.deffer()创建一个延迟对象def。通常返回时通过return def.promise得到一个promise对象。这里更进一步封装了。 上述的def使用了两种方法，分别是： def.resolve(data) def.reject(err) def.notify(data) 上述未提到如果返回值是def.promise，它的then方法有三个参数。 var promise = $http.post(someurl); promise.then(function(data) { alert(&apos;success&apos;); }, funciton(err) { alert(&apos;failed&apos;); }, function(dataUpdate) { alert(&apos;update&apos;) }) 博客：http://www.cnblogs.com/big-snow/p/5126059.html?utm_source=tuicool&amp;utm_medium=referral angular动画效果可以用animation.css方法实现，也可以用angular的animate 安装：bower install --save angular-animate 按照文档操作即可]]></content>
      <categories>
        <category>angular</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“momentApp（ionic2+angular2）学习总结”]]></title>
    <url>%2F2017%2F07%2F23%2F%E2%80%9CmomentApp%E2%80%9D%2F</url>
    <content type="text"><![CDATA[开发文档官方文档：http://ionicframework.com/docs/ 国内翻译版：https://yanxiaodi.gitbooks.io/ionic2-guide/ 开发步骤记录ion图标网址：ionicons.com 安装 1.npm install -g ionic@beta 2.初始化一个空项目 ionic start ionicdemo --v2 使用2.0的版本，安装了cordova的组件 3.运行项目 ionic serve 运行一个ios项目 ionic cordova run ios 切换到新创建的目录下，运行项目 搭建正式的项目ionic lab可视化工具的使用不便于命令行的学习可以把做好的项目上传，还可以分屏查看勾选后可以实现实时更新 ios环境的搭建ios环境中，下载Xcode找到平台文件夹下面的ios的环境文件 性能的调试都可以看到可以横屏竖屏，调节方向 安卓环境的搭建andirod studio 导入项目genymotion模拟器 去官网注册，下载，然后选择add 文件类型介绍hook是钩子，编译或其他某个阶段结束之后，执行的 platforms是平台信息 plugins是cordova的插件 resources是图标 www文件夹里面是网站或者平台上用 config文件，是配置全局信息 gulp自动化编译 inoicons里面有图标，可以把名字拷贝过来，然后在tabs文件夹里面改icon-tabs的tab的icon的名字，要把前缀去掉 ionic的组件组件有事件： onPageLoaded () { // 页面加载完成 } onPageWillEnter(){} 声明周期事件，有进入，有离开事件 onPageWillUnload () { // 从dom中移出的时候 } tab初始化 可以指定初始化时候先加载哪一个tab，在ion-tab标签上指定id并给属性selectedIndex=”0”,从0开始 如果不想一开始就改变，而是过一段时间动态通过js去改变，可以在tab的js里面去改 使用方法： 由于navigation 的所有组件都是跟组件的 “子组件”，所以我们不可以直接注入navigation的子组件到根组件中（包括我们需要导航的NavController）组件，NavController实例实际上就是指向ion-tabs组件的实例，所以我们可以通过给ion-tabs组件添加一个引用变量#tabs,然后使用ViewChild获取到tabs组件实例，再使用select(1)方法来进行页面的选择。 第一步：import { Component,ViewChild } from &apos;@angular/core&apos;; import { Tabs } from &apos;ionic-angular&apos;; 第二步：@ViewChild(&apos;Tabs&apos;) mytab : Tabs; // 在进入完成之后，动态的选择某一个tab // 比如说如果用户未登录，就选定第三个登陆的tab // 如果登陆了，就选择第一个 ionViewDidEnter(){ let mainTabs = this.tabRef; mainTabs.select(1);//根据需求动态选中所需的组件 } list控件展示列表数据信息比较多的时候，向上滑动使用List和Item组件可以非常方便的支持诸如滑动编辑，拖动排序，或者移除之类的交互操作。 根据文档，但是写死了 需要从数据源里面取数据 数据绑定的实现： &lt;ion-item *ngFor=&quot;let item of items&quot;&gt;，用ngFor 控制器里面直接定义 import { Component } from &apos;@angular/core&apos;; import { NavController } from &apos;ionic-angular&apos;; @Component({ selector: &apos;page-contact&apos;, templateUrl: &apos;contact.html&apos; }) export class ContactPage { // 一般数据源都是从api进行获取，这里我们知识模拟一下已经取到的数据 // 创建类 public items; constructor(public navCtrl: NavController) { } ionViewDidLoad() { this.items = [ {&quot;id&quot;: 1, &quot;name&quot;: &apos;小树&apos;, &quot;desc&quot;: &quot;一只爱睡懒觉的猪&quot;}, {&quot;id&quot;: 2, &quot;name&quot;: &apos;冲冲&apos;, &quot;desc&quot;: &quot;有趣的女孩子&quot;}, {&quot;id&quot;: 3, &quot;name&quot;: &apos;莎莎&apos;, &quot;desc&quot;: &quot;做饭好吃，爽朗&quot;}, {&quot;id&quot;: 4, &quot;name&quot;: &apos;灵灵&apos;, &quot;desc&quot;: &quot;一个爱敲代码的好孩子&quot;}, ] } } 一般是从api里面通过请求去后台获取，可以定义一个类 export class WareHouse{ id:number; name:string; desc:string; img:string; constructor(id:number,name:string,desc:string,img:string){ this.id = id; this.name = name; this.desc = desc; this.img = img; } } 然后模拟通过api获取到了一个WareHouse类型的数组 wareHouseList:WareHouse[]=[ new WareHouse(1,&apos;上海仓&apos;,&apos;徐汇仓库&apos;,&apos;img/1.jpg&apos;), new WareHouse(2,&apos;北京仓&apos;,&apos;一环仓库&apos;,&apos;img/2.jpg&apos;), new WareHouse(3,&apos;北京二仓&apos;,&apos;二环仓库&apos;,&apos;img/3.jpg&apos;), new WareHouse(4,&apos;北京三仓&apos;,&apos;三环仓库&apos;,&apos;img/4.jpg&apos;), new WareHouse(5,&apos;广州仓&apos;,&apos;小蛮腰&apos;,&apos;img/5.jpg&apos;), new WareHouse(6,&apos;杭州仓&apos;,&apos;西湖美景&apos;,&apos;img/6.jpg&apos;), new WareHouse(7,&apos;苏州仓&apos;,&apos;楼外楼&apos;,&apos;img/7.jpg&apos;), new WareHouse(8,&apos;扬州仓&apos;,&apos;汤包&apos;,&apos;img/8.jpg&apos;), new WareHouse(9,&apos;上海二仓&apos;,&apos;闵行仓库&apos;,&apos;img/9.jpeg&apos;), new WareHouse(10,&apos;上海三仓&apos;,&apos;浦东仓库&apos;,&apos;img/10.jpg&apos;) ]; 接下来在前台通过angular2来把这个数组上的数据循环绑定到ion-list上 &lt;ion-list&gt; &lt;ion-item *ngFor=&quot;let wh of wareHouseList&quot; (click)=&quot;itemClick($event,wh)&quot;&gt; {{wh.name}} &lt;/ion-item&gt; &lt;/ion-list&gt; 点击item时触发的click事件： itemClick(event,item:WareHouse):void{ alert(item.name); } No Lines 可以看到，每个List Item之间都是有一根线划分开的，可以为ion-list增加一个no-lines属性来移除这些分割线。 &lt;ion-list no-lines&gt; &lt;ion-item *ngFor=&quot;let wh of wareHouseList&quot; (click)=&quot;itemClick($event,wh)&quot;&gt; {{wh.name}} &lt;/ion-item&gt; &lt;/ion-list&gt; 这样就移除了分割线 点击item的时候，绑定click事件直接写itemClick函数 card组件卡片形式的组件，流式的布局 比如微博就是卡片式的布局 新创建组件注意事项新创建一个组件moment之后，修改了tabs和本组件，但是发现报错： No component factory found for MomentPage No component factory found for MomentPage. Did you add it to @NgModule.entryComponents? 就需要去app.module.ts 中引入新模块，并在declarations，entryComponents里面添加新模块即可 三个地方都需要添加 button组件根据文档clear属性没有边框outline描边 input组件input的ng-model写法： 直接在控制器里面使用即可 loading组件先引入控制器，然后自定义，见文档用法 alert组件见文档用法 inoic的toast控件填写错误，不弹框，而是在文本框下面填写 Grid布局toolbar控件用来做头部和脚部的按钮其中模态框的关闭，需要用viewCtroller nagation导航功能从列表页，进入到详情页，并传递参数的方法：1.在列表页里面，引入详情页的组件页面；2.点击事件时触发，传递参数 // 点击事件 itemClick(event, item) { // 在点击的时候，加载对应的列表页面 // 导入导航组件navController // 导入需要进入的详情页面页面 this.navCtrl.push(contactDetailPage, { // 向跳转的页面传入参数 item: item }) } 3.详情页需要导入NavParams from ‘ionic-angular’; 4.详情页 constructor( public navCtrl: NavController, public viewCtrl: ViewController, private navParams: NavParams ) { } 5.接收参数 ionViewDidLoad() { console.log(this) this.item = this.navParams.get(&apos;item&apos;); } Cordova组件介绍Image Picker组件 图片选取https://github.com/wymsee/cordova-imagePicker 按照文档：http://ionicframework.com/docs/native/image-picker/ 基本用法先安装 1.首先在头部导入ImagePicker: import { ImagePicker } from &apos;ionic-native&apos;; 2。在app.module里面导入 import { ImagePicker } from &apos;@ionic-native/image-picker&apos;; 3.在app.module的providers里面注入： ImagePicker 4.在contructor里面注入 该组件有以下三个方法： getPictures(options) :顾名思义，就是选取照片 hasReadPermission() : 判断是否有读取权限 (android用) requestReadPermission() : 请求读取权限 (android用) getPictures详解 Promise和箭头函数的写法： ImagePicker.getPictures(options).then((results) =&gt; { for (var i = 0; i &lt; results.length; i++) { console.log(&apos;Image URI: &apos; + results[i]); } }, (err) =&gt; { }); 该方法的options属性如下： maximumImagesCount (number) :一次能选择的最大数量的图片 width (number) 图片被允许的最大的宽度 height (number) 图片被允许的最大的高度 quality (number) 图片质量，默认是100 注：maximumImagesCount实际测试ios不起作用，具体什么问题还要再研究 设置参数： uploadPic(){ var opt = { maxImagesCount:1, width:100, height:100, quality:50 }; ImagePicker.getPictures(opt).then((results)=&gt;{ for (var i = 0; i &lt; results.length; i++) { this.userInfo.Url = results[i]; } }, (err)=&gt;{ }); } 但是需要在模拟器里面运行ionic build android geolocation组件进行位置确认http://ionicframework.com/docs/native/geolocation/ 根据文档操作 在app.js平台函数下面操作ionic build ios Local Notifications组件，本地通知比如生日及闹钟提醒 还有一个远程，push，从服务器通知国内比较好的第三方极光推送 快速生成APP图标和启动页面可以按照文档方法生成，但是比较慢 makeappicon.com 会生成各种大小的文件 可以下载 ios.hvims.com启动界面的生成 使用： 需要安装一个插件：cordova-plugin-splashscreen在config里面处理 用localstroage存储用户信息model关闭后父页面刷新的概念和方法model从用户登陆页面进入到用户中心的时候，是以模态框的形式，可以向用户中心页面传递参数，用户中心模态框消失的时候，也可以向即将进入的页面传递参数。 // 即将关闭的页面 this.viewCtrl.dismiss(this.username) // 然后接收的页面： // 没有登陆的状态 let loginModal = this.modalCtrl.create(LoginPage); // 监听传递过来的数据 loginModal.onDidDismiss((data) =&gt; { // 是一个回调函数，有传过来的数据 console.log(data) this.headface = &apos;images/&apos; + data + &apos;.jpg&apos;; }) loginModal.present(); 而不是用reload来刷新页面 注册注册：获取用户名和密码，调用api接口，传入到后台，后台将用户名和密码保存到数据库 登录场景，前端用户传入用户名及密码，通过api接口传到后台，在后台进行配对，如果配对成功，则在后台派发（返回）一个令牌（id_token，下同）,通过这个令牌作为用户已经登录的唯一凭证，需要保存到用户本地存储（localStorage）,以后作后续操作； 登录后操作，当用户需要授权操作时，那么首先得获取本地存储（localStorage）中的令牌，将令牌传到后台，如果匹配成功，则允许操作，否则不允许操作。 第三方接口： 注册、登录及查询这三个接口 http://localhost:3001/users http://localhost:3001/sessions/create http://localhost:3001/api/protected/random-quote 下载及方法： git clone https://github.com/auth0/nodejs-jwt-authentication-sample.git npm install node server.js ionic中的网络请求发送ajax请求，做数据的实时更新 api.gugujiankong.com/account/Login?email=1 发送请求之后，会返回一个singToken,每次请求的时候会发送到后台，后台判断是否是以登陆状态发起的请求 文档地址：https://ionicframework.com/docs/native/http/ 安装：地址：https://github.com/wymsee/cordova-HTTP $ ionic cordova plugin add cordova-plugin-http $ npm install --save @ionic-native/http Add this plugin to your app&apos;s module 但是这种方法在浏览器端开发的时候不方便，会报错 Native: tried calling HTTP.get, but Cordova is not available. Make sure to include cordova.js or run in a device/simulator 所以用了另外一种方法： import {Http} from &apos;angular2/http&apos; 但是报错，最后去atackoverflow上面找到答案 // 需要去app.module里面注入 import { HttpModule } from &apos;@angular/http&apos; @NgModule({ imports: [ HttpModule, &lt;---- BrowserModule, HttpModule, ], declarations: [AppComponent], providers: [], bootstrap: [AppComponent], }) export class AppModule { } 本案例是使用： import {Http} from &apos;@angular/http&apos; constructor里面注入 this.http.get(&apos;http://api.gugujiankong.com/account/Login?email=1@qq.com&amp;password=1&apos;).subscribe((data) =&gt; { }) // 返回的数据会把用户图像返回回来 // 如果登陆成功，即判断返回的loginstatus状态码，如果成功，就把token存储起来 http请求抽取成httpService参考博客： https://github.com/ParryQiu/GuGuJianKong/blob/master/www/js/services.jshttp://www.jianshu.com/p/779b0a830a7f?winzoom=1 其他的http请求的用法介绍类似于jquery的写法： this.http({ url: &quot;data/list.json&quot; or &quot;data/list.php&quot; or ...... method: &quot;get&quot;, search: &quot;name=zhangxuchao&amp;password=heping&quot; or 使用URLSearchParams() 对象 headers: 使用Headers()对象设置 可选 body: &quot;&quot; 可选 }) 实例： import { Http, Response, URLSearchParams } from &apos;angular2/http&apos;; let params = new URLSearchParams(); params.set(&apos;name&apos;, &apos;huge&apos;); console.log(params.toString()) // name=huge this.http.get(StaticSettings.BASE_URL, { search: params}).subscribe( ); this.http.post(url, params).subscribe(res=&gt; { console.log(res); }); URLSearchParams说明地址：https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams 跨域问题ng2不需要考虑跨域问题，按照常规写法请求就好了，只在浏览器里面，但是在打包成apk之后是不存在的 cors跨域的文档：enable-cors.org 用法：后台支持跨域，cors,添加header，允许来自于跨域的请求 或者如果使用的是node,express,可以express端配置： 1. 安装cors npm install cors 2. 配置app.js文件 var cors = require(&quot;cors&quot;); ... app.use(cors()); 3. 在路由中获取数据，然后发送数据 res.json(data); 优点： 支持 get/post方法 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与 示例代码： http.service.ts import {Injectable} from &quot;@angular/core&quot;; import {Http, Jsonp} from &quot;@angular/http&quot;; import &quot;rxjs/add/operator/map&quot;; @Injectable() export class HttpService { constructor(public http:Http, public jsonp:Jsonp) { } httpGet(url, params) { return this.http.get(url, {search: params}).map(result=&gt;result.json()); } httpPost(url, params) { return this.http.post(url, {search: params}).map(result=&gt;result.json()); } jsonpGet(url, params) { return this.jsonp.get(url, {search: params}).map(result=&gt;result.json()); } } label.component.ts import {Component, OnInit} from &quot;@angular/core&quot;; import {HttpService} from &quot;../services/http.service&quot;; @Component({ selector: &quot;blog-label&quot;, templateUrl: &quot;../templates/label.tpl.html&quot; }) export class LabelComponent implements OnInit { data: Array&lt;Object&gt;; constructor(public httpService:HttpService) { this.data = []; } ngOnInit() { var url = &quot;http://localhost:3000/skill&quot;; this.httpService.httpGet(url, &apos;&apos;).subscribe(res=&gt; { console.log(res); this.data = res; }, err=&gt; { console.log(err); }); } } // express app.js 部分用到的代码 var express = require(&apos;express&apos;); var cors = require(&quot;cors&quot;); var app = express(); app.use(cors()); // express label.js var express = require(&quot;express&quot;); var router = express.Router(); var connection = require(&quot;../conf/db&quot;); router.get(&quot;/&quot;, function (req, res, next) { connection(&quot;select * from skill&quot;, function (err, rows, fields) { res.json(rows); console.log(rows); }) }); module.exports = router; 在list里面滑动删除数据添加ion-item-sliding &lt;!--滑动删除列表效果--&gt; &lt;ion-item-sliding *ngFor=&quot;let item of items&quot;&gt; &lt;ion-item (click)=&quot;itemClick($event,item)&quot;&gt; &lt;ion-avatar item-left&gt; &lt;img src=&quot;../images/{{item.id}}.jpg&quot; alt=&quot;&quot;&gt; &lt;/ion-avatar&gt; &lt;h2&gt;{{item.name}}&lt;/h2&gt; &lt;p&gt;{{item.desc}}&lt;/p&gt; &lt;/ion-item&gt; &lt;!--滑动的时候出现的按钮--&gt; &lt;ion-item-options&gt; &lt;button ion-button color=&quot;danger&quot; (click)=&quot;removeItem(item)&quot;&gt; &lt;ion-icon name=&quot;trash&quot;&gt;&lt;/ion-icon&gt; 删除 &lt;/button&gt; &lt;/ion-item-options&gt; &lt;/ion-item-sliding&gt; 集成极光推送进行消息推送极光推送 https://www.jiguang.cn/dev/#/app/94fe861ff71e13a19318359d/info ParryQiu/GuGuJianKong https://github.com/jpush/jpush-phonegap-plugin JPush极光推送详解http://blog.csdn.net/zhangxing52077/article/details/52864132 h5 消息推送 jpush-phonegap-plugin 插件的使用http://blog.csdn.net/u013087907/article/details/52849590 注意的问题为ionic2调用极光插件提供符合angular2及TS的调用方式https://www.npmjs.com/package/ionic2-jpush https://www.npmjs.com/package/ionic2-jpush http://blog.sina.com.cn/s/blog_a7b21e5c0102wyea.html 在jspush的网站创建应用，并设置应用包名，比如： cn.kigsir.momentApp 先安装官方的cordova插件 $ cordova plugin add jpush-phonegap-plugin –variable APP_KEY=your_jpush_appkey 在安装本库 $ npm install ionic2-jpush –save 一篇参考博客http://blog.csdn.net/a348639336/article/details/70312733 2.打开插件目录下的plugin.xml文件，找到 用刚才在极光推送创建的应用的appkey 替换 “your appkey”。 3.打开插件目录\src\android\JPushPlugin.java 文件，找到import your.package.name.R，将其替换为：cn.kigsir.jpushdemo.R。 因为是使用第三方插件，所以需要全局声明 // 全局声明windowdeclare var window; 否则会报错 然后初始化： //推送插件 if (window.plugins &amp;&amp; window.plugins.jPushPlugin) { window.plugins.jPushPlugin.init(); } // System events document.addEventListener(&quot;resume&quot;, resume, false); function resume() { if (window.plugins.jPushPlugin.isPlatformIOS()) { window.plugins.jPushPlugin.setBadge(0); window.plugins.jPushPlugin.setApplicationIconBadgeNumber(0); } else if ((&lt;any&gt;window).plugins.jPushPlugin.isAndroid()) { window.plugins.jPushPlugin.setLatestNotificationNum(3); window.plugins.jPushPlugin.clearAllNotification(); } } 登陆之后需要设置推送的对象： //设置客户端的别名，用于定向接收消息的推送 window.plugins.jPushPlugin.setAlias(&quot;Client&quot; + res.UserId); var arrayObj = new Array(&apos;Tags&apos; + res.UserId); console.log(window.plugins) window.plugins.jPushPlugin.setTags(arrayObj); 如果要定义公共方法，可以抽取，然后注入util.server.ts import { Injectable } from &apos;@angular/core&apos;; @Injectable() export class utilService { checkMail(mail) { const reg = /^[A-Za-z0-9]+([-_.][A-Za-z0-9]+)*@([A-Za-z0-9]+[-.])+[A-Za-z0-9]{2,4}$/; return reg.test(mail); } } import { utilService } from &apos;../../app/util.service&apos; @Component({ selector: &apos;page-regester&apos;, providers: [utilService], templateUrl: &apos;regester.html&apos; }) public util: utilService Ionic+Cordova WebApp Android打包及环境搭建参考博客地址：https://segmentfault.com/a/1190000008137785http://www.jianshu.com/p/7ec74328f6e5http://blog.csdn.net/a348639336/article/details/70312733 ionic开发中一些问题http://blog.csdn.net/taohai123/article/details/51492726 Todolist开发http://www.jianshu.com/p/627ee2d23f0f]]></content>
      <categories>
        <category>ionic2 + angular2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue音乐webApp项目总结]]></title>
    <url>%2F2017%2F07%2F16%2Fvue%E9%9F%B3%E4%B9%90webApp%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWA技术研究]]></title>
    <url>%2F2017%2F06%2F25%2FPWA%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[最近老大换了，新来的老大是个技术控，想法也很多，国际站手机端的技术栈开始使用新技术，很开心有这个机会学习，实践。 vue的技术就不介绍了，这里介绍一个比较好玩的东东，因为android版本还在开发中，并且面世估计还需要几个月，所以想先用这个webApp版的作为移动端过渡版本，要求就是开发速度快，适配多屏幕。国内站，面对国内供货商的M站已经有了，国际M站新增了自营模块。 在这个背景下，上上周开例会的时候，邱哥介绍了一下饿了么的一篇分享PWA的实践文章，让我们去学习一下，看这个项目是否可以考虑使用。于是，这个类似于谷歌版的小程序就出现在了我眼前。看官容我上面赘述这么多，才揭开这层神秘的面纱。 PWA是什么http://www.jianshu.com/p/9caf2d527431 https://zhuanlan.zhihu.com/p/25459319https://zhuanlan.zhihu.com/p/25800461 https://github.com/sitepoint-editors/pwa-retrofit PWA（Progressive Web Apps）是谷歌家开发的一门技术，目的是使webApp更好的实现类似于原生的效果。 第一次用这个app的用户，不需要下载安装安卓版本，直接通过浏览器访问即可，可以通过谷歌扩展程序，在主屏幕建立一个图标，点击可以全屏使用。 在离线的情况下，也可以通过缓存快速加载 并且可以实现原生app效果的推送 特性 渐进式的Web应用，在基本功能实现的基础上，支持的浏览器将可以实现PWA提供的离线、推送、桌面访问的这三个能力，它是可以在开发完app之后，单独添加的。 核心机制是ServcieWorker：一个单独的后台线程，不依赖于某一个WebView，它是一个Proxy，用于监听以及管理服务的请求以及返回 允许用户将PWA在桌面上创建图标，并且不必到应用商店去下载搜索下载应用 保持最新，serive worker使得应用总是保持在最新版本的状态 独立的网络连接，增强式的服务使PWA可以在无线环境下或网络及其不稳定的环境下工作 我们需要实现的需求 让我们的国际站app可以在离线的情况下工作 存储数据，在离线时也可以使用 需要的环境 谷歌浏览器版本52及以上 Web server for chrome或其他的网络服务器。 开发app shell架构 pp的shell包含了构建一个PWA所需要的最基本的html，css，javascript文件，并且是确保app有良好的性能的必要组件之一，它的第一次加载非常的快速，并且第一次加载后就能被缓存下来，这意味着在app shell第一次加载完成后，用户再打开app后，app shell将从本地缓存中加载，这是非常快速的。 app shell架构将app的基础架构和ui分离，所有的基础架构和ui都将在本地缓存，这样在后续加载的时候，PWA只需要检索必要的数据，并不需要再次加载所有数据。 开发app shell需要设计核心组件，将第一次加载使需要立刻呈现在屏幕上的，或者是重要的ui组件，js文件，图片文件 我们的国际站里面需要的是头部的搜索，back按钮，标题，banner，热门商品推荐，热门商家推荐，底部的tab栏切换 写一个Service Worker.jsService Worker 在网页已经关闭的情况下还可以运行, 用来实现页面的缓存和离线, 后台通知等等功能。sw.js 文件需要在 HTML 当中引入: worker.js用法：https://www.villainhr.com/page/2016/08/22/Web%20Worker http://chuansong.me/n/1616385052717 这里是一篇详细的教程：https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6 https://github.com/goldhand/sw-precache-webpack-plugin https://kymjs.com/code/2017/02/15/01/ https://segmentfault.com/a/1190000008929656 首先安装SW // 需要缓存的版本 const cacheVersion = &quot;v1&quot;; const cacheList = [] // 缓存的列表清大，根据情况注入 //安装SW self.addEventListener(&apos;install&apos;, event =&gt; { // 缓存文件 event.waitUntil( // 从路径中抓取资源写入缓存 caches.open(cacheVersion) .then(cache =&gt; cache.addAll(cacheList)) .then(() =&gt; self.skipWaiting()) // 让新的SW即刻生效，而不是等旧的销毁了才生效 ) }) 处理动态缓存： //catch fetch self.addEventListener(&apos;fetch&apos;, event =&gt; { event.respondWith( caches.match(event.request).then(response =&gt; { //有缓存则先取缓存 if(response){ return response; } //由于fetch请求的request和response都是stream所以多次使用要用副本 let requestClone = event.request.clone(); return fetch(requestClone).then(response =&gt; { //checking if(!response || response.status!==200|| response.type !== &apos;basic&apos;){ return response; } //response要用于缓存和渲染 let responseClone = response.clone(); caches.open(cacheVersion).then(cache =&gt; { cache.put(event.request, responseClone); }) return response; }) }) ) }) 这里的caches是浏览器用来控制缓存专门分离出来的一个对象，fetch是现代浏览器代替xmlhttp请求发送ajax的方法。 以上代码的原理就是，caches会根据发送的request,先去缓存空间里面找缓存文件，如果有，就做出reponse,如果没有，就通过fetch去获取 更新静态资源 当 service worker 开始启动时，就会触发 activate 事件。 所以我们监听 activate 在这里更新缓存。 缓存的资源随着版本的更新会过期, 所以会根据缓存的字符串名称(这里变量为 cacheVersion, 值用了 “v1”)清除旧缓存, 可以遍历所有的缓存名称逐一判断决决定是否清除: //update self.addEventListener(‘activate’, event =&gt; { event.waitUntil( // 遍历caches里所有缓存的keys的值 caches.keys().then(cacheNames =&gt; { return Promise.all(cacheNames.filter(cachename =&gt; { if(cacheList.includes(cachename)){ return caches.delete(cachename); } }) ) }).then(() =&gt; { return self.clients.claim() }) ) }) 或者类似这种写法是一样的： self.addEventListener(&apos;activate&apos;, function(e) { console.log(&apos;[ServiceWorker] Activate&apos;); e.waitUntil( caches.keys().then(function(keyList) { return Promise.all(keyList.map(function(key) { console.log(&apos;[ServiceWorker] Removing old cache&apos;, key); if (key !== cacheName) { return caches.delete(key); } })); }) ); }); 在新安装的 Service Worker 中通过调用 self.clients.claim() 取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面之后会被停止。 注册service-worker&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./dist/build.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 先判断浏览器是不是支持 if(navigator.serviceWorker != null){ navigator.serviceWorker.register(&apos;sw.js&apos;).then((registration) =&gt; { console.log(`registration events at scope: ${registration.scope}`) }) } &lt;/script&gt; &lt;/body&gt; manifest.json文件maifest文件用来在桌面生成图标的，写法如下：https://developer.mozilla.org/en-US/docs/Web/Manifest 需要在你的文件里面引用]]></content>
      <categories>
        <category>PWA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[M站项目记录]]></title>
    <url>%2F2017%2F05%2F15%2F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[感觉很久没有写博客了，一方面是工作紧张，一方面是觉得文档详细，用的时候看文档，感觉不需要记录。 感谢这次国际m站项目，让我的学习热情又被点燃了。 要点首页轮播图 项目里面轮播图直接去找了饿了么的ui组件库：mint-ui 地址：https://www.npmjs.com/package/mint-ui 路由拦截 router.beforeEach((to, from, next) =&gt; { // ... }) // 设置一个meta字段，在路由跳转的时候匹配，做判断 请求拦截结算，个人中心这个都需要获取登陆权限才可以进入的，需要设置局部axios配置，然后用拦截器处理。 组件按需加载https://router.vuejs.org/zh-cn/advanced/lazy-loading.html http://blog.csdn.net/take_dream_as_horse/article/details/64922998 const Home = resolve =&gt; require([&apos;@/views/Home.vue&apos;], resolve) routes: [ { path: &apos;/home&apos;, name: &apos;Home&apos;, component: Home, meta: { needLogin: false } }, function generateComponentFunction (path) { return resolve =&gt; require([`@/views${path}`], resolve) } const Home = generateComponentFunction(&apos;/Home.vue&apos;) 事件转换格式的方法，es6&lt;script type=&quot;text/javascript&quot;&gt; // 扩充js的内置对象Date方法 Object.assign(Date.prototype, { switch(time) { let date = { &quot;yy&quot;: this.getFullYear(), // 这里月份的key采用大写，为了区别分钟的key &quot;MM&quot;: this.getMonth() + 1, &quot;dd&quot;: this.getDate(), &quot;hh&quot;: this.getHours(), &quot;mm&quot;: this.getMinutes(), &quot;ss&quot;: this.getSeconds() }; //输出年 y+:匹配1个到多个y,i:忽略大小写 if (/(y+)/i.test(time)) { time = time.replace(RegExp.$1, (this.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length)); } //输出月、日、时、分、秒 Object.keys(date).forEach(function(i){ // &quot;(&quot; + i + &quot;)&quot;的结果是字符串&quot;(i+)&quot;, // 只有写成&quot;(&quot; + i + &quot;)&quot;形式，才能在正则表达式中捕获子匹配，进而才能用到RegExp.$1的值 if (new RegExp(&quot;(&quot; + i + &quot;)&quot;).test(time)) { // 判断，如果时间为一位数，则在前面加&apos;0&apos; // ps：这里有一个小知识点：number类型+string类型 = string类型 if(RegExp.$1.length == 2){ date[i] &lt; 10 ? date[i] = &apos;0&apos; + date[i]: date[i]; } //替换初始化函数时候传入yyyy-mm-dd hh:mm:ss(这里可以打印出time、RegExp.$1、date[k]) time = time.replace(RegExp.$1, date[i]); } }) return time; } }) let newDate = new Date(); // newDate.switch()传参的大小写要和方法内定义的key匹配 document.write(newDate.switch(&apos;yyyy-MM-dd hh:mm:ss&apos;)); //结果为：2017-03-24 20:24:36 document.write(newDate.switch(&apos;yyyy-MM-dd&apos;)); //结果为：2017-03-24 &lt;/script&gt; 登陆状态判断页面多处都需要有登陆权限才可以查看，其中header的menu按钮里面有order,wishlist,browing history, address， account setting，购物车checkout的时候都是需要判断登录状态的。 登陆状态既可以在进入页面的时候判断，也可以在路由即将进入的时候判断，路由判断，又可以分为设置一个meta字段，在全局钩子里面判断，或者是单个路由独享钩子 router.beforeEach((to, from, next) =&gt; { // ... }) routes: [ { path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } }] 方法二： const DEFAULT_PATTERN = &apos;yyyy-MM-dd&apos; const SIGN_REGEXP = /([yMdhsm])(\1*)/g function padding (s, len) { var len1 = len - (s + &apos;&apos;).length for (var i = 0; i &lt; len1; i++) { s = &apos;0&apos; + s } return s } export default { formatDate: { format: function (date, pattern) { pattern = pattern || DEFAULT_PATTERN return pattern.replace(SIGN_REGEXP, function ($0) { switch ($0.charAt(0)) { case &apos;y&apos;: return padding(date.getFullYear(), $0.length) case &apos;M&apos;: return padding(date.getMonth() + 1, $0.length) case &apos;d&apos;: return padding(date.getDate(), $0.length) case &apos;w&apos;: return date.getDay() + 1 case &apos;h&apos;: return padding(date.getHours(), $0.length) case &apos;m&apos;: return padding(date.getMinutes(), $0.length) case &apos;s&apos;: return padding(date.getSeconds(), $0.length) } }) } } } 这里面要判断的组件比较多，所以就放在全局钩子里面了。 登陆的时候已经将登陆状态保存在了cookie里面，这里查询，没有就跳转到登陆页面，用的是编程式导航 如果需要登陆，在登陆页面校验输入信息的合法性 校验通过发送登陆请求，校验不成功反馈给用户，其中注册需要有验证码请求环节，注意请求的时候的参数，需要每次都不一样，get请求有缓存。 密码要加密，可以用md5或者是哈希加密 请求如果发送成功，返回的登陆信息及登陆状态存储在store的state里面，将token和头像等设置到cookie里面，并设置cookie的过期时间，用action方法更新，同时执行next 注销的时候，执行mutations的注销的方法，从cookie里面删除注销信息，改变state里面的登陆状态 数据下拉刷新其实当时首先想的是使用mintui-loadmore的方法，但是觉得以前用iscroll比较熟悉一些，最近又看过饿了么的vue案例，所以选了黄老师的方案，better-scroll. munt-ui地址：https://mint-ui.github.io/docs/#/zh-cn2/loadmore http://blog.csdn.net/di315362886/article/details/73920779 其实better-scroll的原理就是懒加载的原理，会监听touch,scroll事件，如果快到底部了，就去加载新的数据 因为页面里面多次使用，所以将scroll专门抽取成一个组件 search搜索关键词的时候要做优化输入框输入的时候，间隔一段时间才去服务器请求数据，用到setTimeout,加延迟事件节流，且移动端列表滚动的时候，键盘需要隐藏，就需要让文本框失去焦点 vuex管理登陆状态，用户信息，放在vuex里面，另外最近浏览数据，在多处组件里面需要，所以，将其作为共享数据 购物车数据操作，操作徽标数量，即商品的总量，多处组件都需要设置 购物车增删改查添加时候的逻辑处理 根据列表项里面的路由： &lt;router-link :to=&quot;&apos;/goods/goodsinfo/&apos; + item.id&quot;&gt; 通过： this.$route.params.goodsId获取到商品的id，发送请求获取商品列表，页面渲染。 购物车的数量加减组件需要多次复用，所以就单独抽取为一个组件cartNumCtrol组件，控制数量增减，基本逻辑是 &lt;div class=&quot;shopCartNum&quot;&gt; &lt;div class=&quot;left&quot; @click=&quot;subtract&quot;&gt;-&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;{{count}}&lt;/div&gt; &lt;div class=&quot;right&quot; @click=&quot;add&quot;&gt;+&lt;/div&gt; &lt;/div&gt; export default { data() { return { count: 1 } }, methods: { subtract() { if (this.count &lt;= 1) { return } this.count -- this.notify() }, add() { this.count ++ this.notify() }, // 子组件触发事件向父组件传值 // 第一个参数是负组件里面定义的事件 // 第二个参数是需要向负组件里面传递的值 notify() { this.$emit(&quot;numberchange&quot;, this.count) } } 按照之前的思路，点击添加到购物车时，通过bus去传递购物车徽标的值 addToShopCart() { // 1.传值给App.vue,让它去更新徽标值 bus.$emit(&apos;updateBadge&apos;, this.subNum) 但是这里，因为引入了vuex，就调用mutations方法，直接修改state里面的购物车总量。购物车徽标组件，直接getter方法获取数量 加入购物车，处理的细节比较多 1.判断有没有登陆，如果没有登陆，就存入cookie： 1）将购物车列表的增删改查方法，放在common来处理； 2）先取出cookie里面的商品列表； 3）.存储的方式是商品的id和数量作为对象的属性，存入这个商品列表数组； 4）mutattions，调用这个方法，来处理这个数组，添加购物车商品列表： 需要判断有没有添加过这个商品，有就增加数量，没有就增加id和数量，既可以用一个空对象来存储，判断id值存不存在，也可以用es6的方法： const index = this.goodLists.findIndex(value, index, arr) =&gt; { return value.id === this.goodItem.id //新加入的 } index == 1 ? this.goodLists.push(this.goodItem) : Object.assign(this.goodLists[index], this.goodItem); //合并 然后保存这个处理后的数据到cookie里面； 5）发送ajax请求，获取到id返回的商品信息，然后将单价、数量等展示在页面上 2.如果是登陆状态的话，需要先查询cookie里面的购物车数据，取出来，然后把当前款添加进入，然后把购物车数据写入到数据库，id和数量，发送请求，然后清空cookie 坑。。。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue项目遇到的问题总结]]></title>
    <url>%2F2017%2F04%2F25%2FVue%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前习惯在项目里面总结问题，这里把一些共性的总结一下，方便查找。 Vue项目back按钮问题问题 需求是back按钮放在app.vue里面的，但是希望只有二级菜单才返回，一级菜单不显示。 思路 1.为按钮绑定@click=’goback’事件，点击的时候，触发methods里面的路由的返回上一级事件： this.$router.go(-1); 2.因为back按钮只有在二级菜单之后才会返回，一级菜单应该是不显示的，所以需要在back按钮上绑定v-show=”isShow”，在一级菜单的时候不显示。 3.如何判定是一级菜单还是二级菜单呢？可以通过watch来监控$route的值，里面有path,根据path来判断 watch: { &apos;$route&apos;: function(newVal, oldVal) { console.log(newVal); //里面有path路径，判断做处理就可以了 } } 4.一个bug就是刷新之后，按钮又恢复默认情况了。这个时候watch不起作用了，因为路由没有发生更改； 5.参考网上的资料，监听窗口的Load事件： mounted() { window.addEventListener(&apos;load&apos;, this.reload) } // 在reload()方法里面，可以获取this.$route的Path变化，再调用同样的方法，path是二级菜单的，就不显示 vue数据更新，dom不更新的问题问题： 一个数组，改变这个数组中的一个序号为index的值，dom不能更新，代码为： this.lists[index] = newValue 解决办法： Vue.set(items, index, newValue) // 原对象，要改变的对象的索引，新值 items.splice(index, 1, newValue) 给一个对象扩展新属性Vue.set(原对象，属性名，属性值) 或者this.$set(obj, key, val) 或者es6方法 Object.assign({}, obj, {key: val, key: val}) nextTick的使用methods: { updateMessage: function () { this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () { console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; }) } Vue组件和非父子组件传值父子组件之间传值—–父组件传值给子组件(父组件view里绑定，子组件props接收) 这个项目里面，有新闻页面，有图片页面，每个页面里面都有一个相同的模块，评论功能，考虑到复用，维护，抽取评论为子组件 但是子组件里面要发送http请求给后台的时候，需要父组件传递当前这条新闻列表的id值，涉及到父子组件传值。 1.创建子组件： subcomment.vue &lt;template&gt;&lt;/template&gt; &lt;style&gt;&lt;/style&gt; &lt;script&gt;&lt;/script&gt; 2.在父组件里面注册子组件 1）引入子组件： import subcomont from &apos;../subcomment.vue&apos; components: { subcomment: subcomment } 2) 父组件的tempalta模板里面，使用我们的子组件，并让子组件渲染出来 template里面： &lt;subcomment&gt;&lt;/subcomment&gt; 3.父组件将组要的值传递给子组件-id 3.1 在父组件里面的子组件view视图里面绑定要传递的值，用key=value的形式 &lt;subcomment :commentId=&quot;this.$route.params.newsId&quot;&gt;&lt;/subcomment&gt; 3.2 在子组件里面用props接收key值，props是一个数组，可以接收多个值 props: [&apos;commentId&apos;] 3.3 子组件根据commentId实现数据请求和渲染 子组件传值给父组件（父组件里用v-on自定义事件来监听，子组件里用this.$emit来触发事件） 项目里面有个商品列表模块，商品件数，可以用+-按钮操作里面的数量，需要在按钮点击的时候把数量传递给父组件，便于存进购物车，也便于更改购物车的徽标。 子组件里面需要： 1.写好子组件的代码； 2.在需要传值给父组件的地方调用 this.$emit(key, 值) //这个key在父组件里面需要用到 // 例如：this.$emit(&apos;numberChange&apos;, this.count); //numberChange是自定义事件名称 父组件里面需要： 1.导入子组件； 2.在components里面注册子组件 3.在template里面使用子组件 4.在父组件视图子组件的标签中，注册接收子组件值的事件 &lt;subnumber v-on:key=&quot;函数名称&quot;&gt;&lt;/subnumber&gt; 5.在父组件的methods中，写好接收子组件传递过来值的函数 methods: { 函数名称(子组件传递过来的值) { // 具体代码 } } 或者 4.在父组件的子组件标签里面，自定义事件来接收： &lt;subnumber @numberChange=&quot;函数名称，比如receiveCount&quot;&gt;&lt;/subnumber&gt; 5.父组件方法里面定义函数，将子组件传递的值通过参数来接收： methods: { receiveCount(count) { // } } 方法2：利用ref属性 1.在子组件的元素里设置: &lt;div id=&quot;app&quot;&gt; &lt;subnumber ref=&quot;subNum&quot;&gt;&lt;/subnumber&gt; &lt;/div&gt; 2.在父组件方法里面获取： new Vue({ el: &apos;#app&apos;, mounted: function() { // 直接访问sub子组件里面的值 this.$refs.subNum //拿到了子组件的dom元素，进而操作值 } }) 但是在这个项目里还是不希望父组件主动去取值，而是希望子组件变化的时候传递给父组件，父组件被动接收修改，否则不符合模块化的思想。 非父子组件之间传值（通信）：bus中间件 不能再用this，而是要再创建一个空白的vue实例bus，引用进两个组件 1.创建一个空的bus.vue: export default new Vue(); 2.两个组件都需要导入bus 1)传值方：bus.$emit(&apos;updateCount&apos;, 值)； 2)接收方：bus.$on(&apos;updateCount&apos;, function(值) { // 回调里面执行代码 }) 双向数据绑定问题 vue的v-model双向数据绑定，确实是很方便，不用直接再繁琐的去操作dom，但是一个项目里面，有个商品列表，前面用switch开关组件来控制，这个组件是利用v-model=”value”来关联是true或false，来显示是否计算这个商品，value是布尔值类型 因为双向绑定的特性，导致所有的商品列表项都共享这一个value,一个变化了，其他的就联动。 当时解决的办法是，v-model不能写死为value，里面是一个动态变化的数组switchvalue,用列表项的index来控制，每一个都给一个默认值。 html &lt;!--开关--&gt; &lt;mt-switch @change=&quot;jisuanTotalCountAndTotalPrice&quot; v-model=&quot;switchValues[index]&quot;&gt;&lt;/mt-switch&gt; // 对http请求返回来的数据 //给switchValues的i添加默认值 // 返回的列表数据有几个项目，就对应设置 this.switchValues[i] = true]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue打包上线流程总结]]></title>
    <url>%2F2017%2F04%2F18%2Fittun%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目打包上线方法总结1.将压缩上线的dist目录及下面的文件，再用一个目录，比如sell1，将index.html和bundle.js放置进去 2.在sell1目录下打开npm，运行npm install express 3.直接安装会报错，所以需要先npm init -f生成package.json文件 4.再创建server.js文件，开启express，监听传递过来的请求，返回数据 vue-cli打包上线scripts对象下面有build属性，node build/build.js 在项目文件夹下执行npm run build build文件需要通过http请求来访问，本地打开将不能工作 完毕之后，会多一个dist目录，目录下面有一个static文件夹，下面有css和js，和static并行的还有一个index.html css里面有个app,js里也有app，且文件都是 开启http请求的server 在根目录下创建一个prod.server.js,里面定义路由，包括异步请求的路由。 然后node ./prod.server.js，开启node服务，将本地请求的端口号改为上线环境的端口号9000，即可看到现在加载的是打包后的dist目录下的文件 此时还可以通过设置config下面的index.js里面的productionSourceMap:false,再重新打包，运行npm run build dist目录下面将没有map文件了 再运行node ./prod.server.js，就不会再加载map调试文件了]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue项目和angular项目的懒加载]]></title>
    <url>%2F2017%2F04%2F02%2FVue%E9%A1%B9%E7%9B%AE%E5%92%8Cangular%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[vue路由懒加载官方文档：懒加载：https://router.vuejs.org/zh-cn/advanced/lazy-loading.html 懒加载： https://cn.vuejs.org/v2/guide/components.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6 个人博客：http://www.cnblogs.com/Kummy/p/5254754.html 在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验； 运用懒加载可以将页面进行划分，按需加载页面，可以分担首页所承担的加载压力，减少加载用时。目的在路由被访问到的时候再加载对应的组件 用法const Foo = resolve =&gt; require([&apos;./Foo.vue&apos;], resolve); const router = new VueRouter({ routes: [ { path: &apos;/foo&apos;, component: Foo } ] }) // router/index.js import Vue from &apos;vue&apos; import Router from &apos;vue-router&apos; Vue.use(Router) const router = new Router({ routes: [ { mode: &apos;history&apos;, path: &apos;/home&apos;, name: &apos;home&apos;, component: resolve =&gt; require([URL], resolve),//懒加载 children: [ { mode: &apos;history&apos;, path: &apos;/home/:name&apos;, name: &apos;any&apos;, component: resolve =&gt; require([&apos;@/components/any&apos;], resolve),//懒加载 }, ] } ] });]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-高仿饿了么项目总结]]></title>
    <url>%2F2017%2F03%2F25%2FVue-%E9%AB%98%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[把慕课网上的Vue高仿饿了么项目学习完了，记录一下课程里面的所得。 环境搭建，用vue-cli1.npm i -g vue-cli; 2.可以用vue 命令 例如vue init / vue list 3.有多种选择的模板：用vue init webpack sell(自己取的名字) / vue init webpack-simple去安装 4.安装完毕之后，切换到文件夹 cd sell npm install npm run dev 注意：同时会安装vue-router 项目上线依赖&quot;dependencies&quot;: { &quot;vue&quot;: &quot;^2.3.3&quot;, &quot;vue-router&quot;: &quot;^2.3.1&quot;, &quot;vue-resource&quot;: &quot;^1.3.4&quot;, &quot;better-scroll&quot;: &quot;^0.2.1&quot; }, 项目开发依赖1.css部分用stylus语法编译，stylus语法需要把{}和；都去掉 2.安装loader时遇到的坑 stylus-loader@2.5.1 requires a peer of stylus@&gt;=0.52.4 but none was installed. 3.解决办法 在package.json里面增加： &quot;stylus-loader&quot;: &quot;^3.0.1&quot;, &quot;stylus&quot;: &quot;0.52.4&quot;, 再执行npn install 和 npn run dev cli生成的项目文件介绍1.static里面的.gitkeep表示即使文件夹为空，也可以提交到git仓库，因为空文件夹会忽略 2..babelrc是把es6转成es5，方便浏览器识别，其中有依赖的插件，comment是注释不会显示； 3.editorconfig是编码风格文件，比如字体缩进，换行，去除首尾空格等 4.eslintignore是忽略对里面的文件做语法检查； 5.eslintrc是es6的语法标准的配置 css 设置的关键点编码习惯如果有一个元素，绑定class是为了在js里面做选择，而不是为了设置样式，用类似food-list-hook 1像素边框的制作设置伪元素，用media+scale .border(@borderColor){ position: relative; &amp;::after{ content: &quot;&quot;; position: absolute; bottom: 0; left: 0; width: 100%; border-top: 1px solid @borderColor; } } @media (min-device-pixel-ratio: 1.5) { .border{ &amp;::after{ transform: scaleY(0.7); } } } @media (min-device-pixel-ratio: 2) { .border{ &amp;::after{ transform: scaleY(0.5); } } } 自适应宽，flex布局左边宽度固定，右边宽度自适应 .food{ display: flex; width: 100%; .nav{ flex: 0 0 80px; width: 80px; } .foodList{ flex: 1; } } Sticky footer解决的问题：如果页面内容不够长的时候，页脚块固定在视窗底部；如果内容足够长，需要滚动的时候，页脚块随着内容向下推送，而不是固定视窗底部，挡住了页面的文字 解决办法： 1.设置三个层，一个内容的包裹层，里面再有一个层，是内容；再有一个层是底部层 &lt;div v-show=&quot;detailShow&quot; class=&quot;detail&quot;&gt; &lt;div class=&quot;detail-wrapper clearfix&quot;&gt; //clearfix样式另外自己写 &lt;div class=&quot;detail-main&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;detail-close&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; 2.设置css .detail position: fixed z-index: 100 top: 0 left: 0 width: 100% height: 100% overflow: auto background-color: rgba(7, 17, 27, 0.8) // filter: blur(10px) .detail-wrapper min-width: 100% height: 100% .detail-main margin-top: 64px padding-bottom: 64px(这个是关键，设置一个下padding，给底部留出空间) .detail-close // 和wrapper层一个层级，wrapper层占有100%的高度，所以footer层永远在视口之外，需要下面用-margin-top调整至视口之内 position: relative width: 32px height: 32px margin: -64px auto 0 auto // 设置一个-margin,将自己放置在上面预留的-margin处 clear: both font-size: 32px 自适相等宽高需要设置一个宽高相等的图片，但是每张图的宽高比例是不同的，需要做到自适应，就可以设置父元素的高度为0，上边距为100%，子元素设置宽为100%，高为100% .image-header position: relative width: 100% height: 0 padding-top: 100% // 让图片的宽高一致，保持同等比例 img position: absolute top: 0 left: 0 width: 100% height: 100% 媒体查询，适用于ipone5@media only screen and (max-width: 320px) // 仅仅当屏幕最大尺寸为320px时适用 padding-left: 6px Vue知识要点vue动画设置看文档，此处是需要设置页面从右向左移入给需要动画的元素的外层设置包裹，在html里面设置： html: &lt;transition name=&quot;move&quot;&gt; &lt;div class=&quot;food&quot; v-show=&quot;showFlag&quot; ref=&quot;food&quot;&gt; &lt;/food&gt; &lt;/transition&gt; css: .food transform: translate3d(0, 0, 0) &amp;.move-enter-active, &amp;.move-leave-active transition: all 0.2s linear // 过渡效果 &amp;.move-enter, &amp;.move-leave-active transform: translate3d(100%, 0, 0) // 动画开始的位置，从右到左飞入 transition动画不能用在一个v-for循环生成的一组元素上面，可以写在每一个的里面&lt;div class=&quot;ball-container&quot;&gt; &lt;div v-for=&quot;ball in balls&quot;&gt; &lt;transition name=&quot;drop&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;ball.show&quot;&gt; &lt;div class=&quot;inner inner-hook&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt; vue路由设置重定向路由首页进入希望停在商品页面，可以在路由里面设置重定向 const router = new VueRouter({ routes: [ {path: &apos;/&apos;, redirect: &apos;/goods&apos;}, // 重定向 {path: &apos;/&apos;, component: goods}, {path: &apos;/seller&apos;, component: seller}, {path: &apos;/ratings&apos;, component: ratings}, {path: &apos;/goods&apos;, component: goods} ] }) 或者在后面用router.push({path: &apos;/goods&apos;}) //测试可以成功 路由激活样式修改《router-link to=‘’》有默认的class,可以在路由里面配置修改 linkActiveClass: &apos;active&apos;，在router实例里面 组件设置滚动效果食物左侧的菜单导航，以及食物容器自身，在内容超出浏览器可视区域的时候，会出现滚动条，但是移动端设计效果是希望可以滚动，触摸上去的时候，滑动，移动端常用的插件是Iscroll，这里使用的是better-scroll插件。Iscroll插件（http://iscrolljs.com/）因为已经很久不维护了，所以采用的是这个仿写的。 安装时候的问题：npm 安装better-scroll时报错 npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\browser-sync\node_modules\chokidar\node_modules\fsevents) npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.0.14: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;}) 是因为$sevents不兼容win系统，忽略警告，执行下面的既可以安装成功 npm -g install npm 用法：关键在于给需要设置的滚动的容器外层添加一个div，滚动的时候会计算要滚动的容器的高度，外层div的高度是固定的，超出的部分隐藏，里层的高度超出就可以滚动。 &lt;div class=&quot;food&quot; v-show=&quot;showFlag&quot; ref=&quot;food&quot;&gt; &lt;div class=&quot;food-content&quot;&gt; &lt;/div&gt; &lt;/div&gt; 用法：初始化，进行实例化 new BScroll(dom对象， { //options }); 如果需要直接对dom做操作，需要在html标签里面绑定ref=&quot;div&quot; 用this.$refs.div获取 为了让子元素可以被点击，设置click: true, VUE里面数据更新是异步的，在数据还没有加载完成之前，BScroll是无法获取目标容器的高度的，就会出现无法滚动的情况，即数据改变，dom没有变化 所以需要放在this.$nextTick里面去实例化 methods: { // 定义food详情页面显示或隐藏的方法 show () { this.showFlag = true this.selectType = ALL // 每一次进入商品详情页面都初始化，显示全部内容 this.onlyContent = false // 进入商品页面初始化显示有内容的评价 this.$nextTick(() =&gt; { // 实例化better-scroll方法，使food详情页面可以滚动 if (!this.scroll) { this.scroll = new BScroll(this.$refs.food, { click: true }) } else { this.scroll.refresh() } }) } } nextTick应该被用在某些计算属性或者watch再或者某个按钮click事件绑定的methods当中。这时，nextTick才能保证你的数据更新完成之后再执行你绑定的函数。 实例用法： this.$nextTick(() =&gt; { this.initScroll(); }) better-scroll的点击事件注意事项1.为了能点击，在实例化的时候，需要设置参数： click: true 2.在pc上，点击事件会执行两次。因为pc端不会阻止默认事件，由于better-scroll派发的事件有event_constructed: true属性，可以去判断原生事件有没有这个属性。 在html里面点击事件传递一个参数$event,在后面接收获取 &lt;div @click=&quot;addFirst($event)&quot; class=&quot;buy&quot; v-show=&quot;!food.count || food.count===0&quot;&gt;加入购物车&lt;/div&gt; // 点击加入购物车按钮，添加商品 addFirst (event) { if (!event._constructed) { return } Vue.set(this.food, &apos;count&apos;, 1) this.$emit(&apos;add&apos;, event.target) // 父子组件传值，在子组件触发 } vue给对象新增属性vue.set(this.food.count, &quot;1&quot;) vue非父子组件传值这个项目里面，cartcontrol组件需要在每个增加或减少的按钮被点击的时候，将被点击的元素，传递给另外一个组件shopcart，这两个组件之间不是包含和被包含的关系解决的思路1：因为他们有同一个父组件，goods.vue，可以先将按钮所在的子组件的值传递给父组件，再由父组件传递给另外一个子组件shopcart 1.cartcontrol里面用下面的代码来触发 this.$emit(&apos;addFood&apos;, event.target) // 父子组件传值，在子组件触发 2.父组件good.vue里面在子组件标签上面用自定义事件来接收 &lt;cartcontrol @addFood=&quot;receiveAddFood&quot; :food=&quot;food&quot;&gt;&lt;/cartcontrol&gt; 3.父组件methods方法里面，调用函数 // 接收cartcontrol里面传递过来的事件对象 receiveAddFood (target) { console.log(target) } 解决思路2：利用bus vue阻止事件冒泡vue里面阻止事件冒泡，只是为了点击处理一个点击事件，但是因为父元素上面也定义了点击事件，用stop.prevent来阻止 &lt;div class=&quot;content-right&quot; @click.stop.prevent=&quot;pay&quot;&gt; // 只会触发content-right上面的事件，不会触发它的父元素上面的点击事件 vue父组件调用子组件里面定义的方法1.先在子组件methods里面定义方法，比如show(); 2.在父组件的子组件元素上面写ref=&quot;foodEl&quot;; 3.在父组件methods里面先获取子组件 this.$refs.foodEl.show() v-show用计算属性返回boolean// 绑定函数，计算点击吐槽或推荐时，评论列表里面显示的内容 needShow (type, text) { if (this.onlyContent &amp;&amp; !text) { // 只显示有内容的评价，而没有文本，返回false，v-show不显示 return false } if (this.selectTypeNum === ALL) { // 选择的是类型是全部时 return true } else { // 选择的是推荐或吐槽的时候，判断当前的这条评论的类型是否和选择的类型一致，一致就显示，不一致就不显示 return type === this.selectTypeNum } } 时间格式的过滤器vue里面日期时间字符串格式化为yyyy-mm-dd hh:mm之类的方法，用过滤的方法 全局过滤器1.用moment插件，因为为了复用性，写一个全局的过滤器 // 导入moment模块 var moment = require(&apos;moment&apos;); // 全局过滤器 Vue.filter(&apos;dmtDate&apos;, (input, formatString) =&gt; { const lastFormatString = formatString || &quot;YYYY-MM-DD HH:mm:ss&quot; // 在format中指定要把我们前面的时间按照什么样的格式输出 // 参数1：格式化的原始时间 // 参数2： 把院士时间，最终要格式化的字符串 // 参数：http://momentjs.cn/docs/ return moment(input).format(lastFormatString) }) &lt;p&gt;{{newsdetail.add_time | dmtDate('YYYY-MM-DD')}}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{{newsdetail.click}}次浏览&amp;nbsp;&amp;nbsp;&amp;nbsp; 分类：民生经济 &lt;/p&gt; 局部过滤器局部过滤器，在输出模块里面，和methods方法平级，定义一个过滤器 1.// 时间过滤器方法 filters: { formatDate (time) { let date = new Date(time) // 先转换成date类型的对象 return formatDate(date, &apos;yyyy-MM-dd hh:mm&apos;) } } 2.在common的js里面定义一个date.js方法， export function formatDate(date, fmt) { if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length)); } let o = { &apos;M+&apos;: date.getMonth() + 1, &apos;d+&apos;: date.getDate(), &apos;h+&apos;: date.getHours(), &apos;m+&apos;: date.getMinutes(), &apos;s+&apos;: date.getSeconds() }; for (let k in o) { if (new RegExp(`(${k})`).test(fmt)) { let str = o[k] + &apos;&apos;; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)); } } return fmt; } 3.用import 导入这个方法 import {formatDate} from &apos;../../common/js/date.js&apos; // 引入日期方法 正则相关正则提取url里面的参数，把参数分割成以&amp;为分隔符的key=value形式 var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g 解析：/表示分隔符，g表示全局匹配，匹配到第一个之后会继续向后查找 （）表示子组 [^]表示字符类取反，比如[^abc]匹配的就不是a和b和c的单个字符，[^?&amp;=]匹配不是^和?和=的单个字符 字符类[]后面的+和*表示量词 +等价于{1, }表示1次或多次 *等价于{0，}表示重复0次或多次 var str = &quot;foo=bar&amp;lang=js&quot;; var reg = /[^?&amp;=]{1,}=[^?&amp;=]{0,}/g console.log(str.match(reg)); // 输出[&quot;foo=bar&quot;, &quot;lang=js&quot;] var str = &quot;foo=bar&amp;lang=js&quot;; var reg = /[^?&amp;=]+=[^?&amp;=]*/; console.log(str.match(reg)); // 输出[&quot;foo=bar&quot;] var str = &quot;foo=bar&amp;lang=js&quot;; var reg = /([^?&amp;=]{1,})=([^?&amp;=]{0,})/; console.log(str.match(reg)); //输出 [&quot;foo=bar&quot;, &quot;foo&quot;, &quot;bar&quot;] &quot;http:/www.baidu.com/?a=1&amp;b=2&quot;.match(/([^?&amp;=]+)=([^?&amp;=]*)/g); // [&quot;a=1&quot;,&quot;b=2&quot;] 总结：将url里面的参数解析成key=val的对象的方法 /** * 解析url参数 * @example ?id=12345&amp;a=b * @return Object {id:12345,a:b} */ export function urlParse () { let url = window.location.search let obj = {} let reg = /[^?&amp;=]+=[^?&amp;=]*/g let arr = url.match(reg) // [&apos;id=12345&apos;, &apos;a=b&apos;] if (arr) { arr.forEach((item) =&gt; { let tempArr = item.split(&apos;=&apos;) // [&quot;id&quot;, &quot;12345&quot;] let key = decodeURIComponent(tempArr[0]) let val = decodeURIComponent(tempArr[1]) obj[key] = val }) } return obj } keep-alive缓存组件keep-alive缓存vue组件，当请求的数据没有变化的时候，不希望再发送请求，可以用keep-alive将组件缓存起来，缓存的同时也会记录上一次的滚动的位置 使用场景： 比如一个列表和一个详情，那么用户就会经常在打开详情=》返回列表=》打开详情之间切换，切换频率高，这样每次从详情返回列表的时候，都能从缓存里面快速渲染，而不是重新渲染 原理是把组件的状态缓存在内存里 如果并不想所有的组件都被缓存，有些切换回来的时候是已经加载过的，解决方法：在app.vue里面设置 &lt;!-- 这里是需要keepalive的 --&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;!-- 这里不会被keepalive --&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 然后在设置路由信息的时候这样 { path: &apos;&apos;, name: &apos;&apos;, component: , meta: {keepAlive: true} // 这个是需要keepalive的},{ path: &apos;&apos;, name: &apos;&apos;, component: , meta: {keepAlive: false} // 这是不会被keepalive的} 或者这里利用active的方法：http://www.cnblogs.com/zion0707/p/6213159.html]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue登陆拦截学习]]></title>
    <url>%2F2017%2F03%2F20%2Fvue%E7%99%BB%E9%99%86%E6%8B%A6%E6%88%AA%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[项目里面需要用到拦截，用这个demo加深对vue全家桶的学习，以及通过axios实现登录、拦截和登出功能，利用axios的http拦截器拦截请求和响应，这是之前没有用过的。 这里记录一下学习及项目构建的整个过程。 接口准备github接口文档：https://developer.github.com/v3/ &apos;https://api.github.com/user/repos?page=2&amp;per_page=100&apos; 默认返回30条，可以调整参数获取 利用github提供的个人token作为登录的token，通过token直接访问仓库列表 所以需要先在github生成自己的token,步骤如下： 在settings里面找到获取token的选项，创建后复制黏贴即可。 用vue-cli生成项目目录1 // install vue-cli 安装依赖包 npm install --g vue-cli 2 // 使用vue-cli初始化项目 vue init webpack my-project 3 // install dependencies and go! //进入项目目录 cd my-project 4 //在项目中安装依赖包 npm install 5 //运行项目 npm run dev 布局使用vue-material英文文档：http://vuematerial.io/#/中文文档：http://vuematerial.com/#/ 安装npm install vue-material 使用1.引入css和js文件 import Vue from &apos;vue&apos; import VueMaterial from &apos;vue-material&apos; import &apos;vue-material/dist/vue-material.css&apos; 或者按需加载，只加载需要的组件 import Vue from &apos;vue&apos; import VueMaterial from &apos;vue-material&apos; import &apos;vue-material/dist/components/mdCore/index.css&apos; //Required to boot vue material import &apos;vue-material/dist/components/mdButton/index.css&apos; import &apos;vue-material/dist/components/mdIcon/index.css&apos; import &apos;vue-material/dist/components/mdSidenav/index.css&apos; import &apos;vue-material/dist/components/mdToolbar/index.css&apos; 使用： Vue.use(VueMaterial.mdCore) //Required to boot vue material Vue.use(VueMaterial.mdButton) Vue.use(VueMaterial.mdIcon) Vue.use(VueMaterial.mdSidenav) Vue.use(VueMaterial.mdToolbar) 安装依赖安装项目依赖 // 项目依赖 &quot;vue&quot;: &quot;^2.3.3&quot;, &quot;vue-material&quot;: &quot;^0.7.4&quot;, &quot;vue-router&quot;: &quot;^2.6.0&quot;, &quot;vuex&quot;: &quot;^2.1.2&quot;, &quot;axios&quot;: &quot;^0.15.3&quot; // 项目开发依赖 // sass &quot;node-sass&quot;: &quot;^4.5.0&quot;, &quot;sass-loader&quot;: &quot;^5.0.1&quot;, // 需要先把package.lock删除,再执行npm install,否则就需要直接安装包名 vuex仓库数据的建立在src下面再建立一个store文件夹 1.state.js定义需要共享的用户的初始信息 2.mutation-types.js用来设置修改状态值的方法的常量 3.mutation.js用来设置修改方法 import * as types from &apos;mutation-types.js&apos; // 定义matutaions const matutaions = { // 相关的修改方法，同步的修改状态 [types.SET_LOGIN](state, token) { // 登录的时候将获取到的token数据设置到本地和state跟新 localStorage.setItem(&apos;token&apos;, data) state.token = data }, [types.SET_LOGOUT](state) { // 退出的时候，从本地删除token localStorage.removeItem(&apos;token&apos;) state.token = null }, [types.SET_TITLE](state, title) { state.title = title } } // 导出 export default matutaions // 以上写法相当于下面的写法，是定义一个函数，有传递参数 // [types.SET_LOGIN]: (state, token) =&gt; { // // 登录的时候将获取到的token数据设置到本地和state跟新 // localStorage.setItem(&apos;token&apos;, data) // state.token = data // } 4.建立一个包装用来获取state数据的方法 // 包装获取数据 export const user = state =&gt; state.user // 相当于 // function user(state) { // return state.user // } export const token = state =&gt; state.token export const title = state =&gt; state.title 5.建立一个index.js的文件，导入这些方法，进行store的初始化 // store的初始化 import Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; import state from &apos;./state.js&apos; import mutations from &apos;./mutations.js&apos; import getters from &apos;./getters.js&apos; import createLogger from &apos;vuex/dist/logger&apos; // 每次修改state的时候会在控制台打印，之前的状态和现在的状态 Vue.use(Vuex) // 注册插件 // 调试工具，调用webpack编译的时候，如果说是npm run dev的话，是dev环境，如果是build的话，是生产环境，线下调试的时候，可以开启测试 const debug = process.env.NODE_ENV !== &apos;production&apos; export default new Vuex.Store({ state, mutations, getters, strict: debug, // 开发环境开启严格模式，上线环境关闭，因为损耗性能 plugins: debug ? [createLogger()] : [] // 打印state的值 }) 6.在main.js里面引入vuex的store，并挂在到vue实例上 import store from &apos;./store&apos; // 引入vuex的store new Vue({ el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: { App }, render: h =&gt; h(App) }) 简化版如果不考虑需要设置的对象比较多的情况，可以简单的写在一个里面 import Vuex from &apos;vuex&apos; import Vue from &apos;vue&apos; import * as types from &apos;./types&apos; Vue.use(Vuex); export default new Vuex.Store({ state: { user: {}, token: null, title: &apos;&apos; }, mutations: { [types.SET_LOGIN]: (state, data) =&gt; { localStorage.token = data; state.token = data; }, [types.SET_LOGOUT]: (state) =&gt; { localStorage.removeItem(&apos;token&apos;); state.token = null }, [types.SET_TITLE]: (state, data) =&gt; { state.title = data; } } }) 获取vuex里面定义的数据import { mapGetters, mapMutations } from &apos;vuex&apos; // 通过计算属性，获取到state里面的数据 computed: { // 获取到state里面的数据 ...mapGetters([ &apos;title&apos;, &apos;token&apos; ]) }, // 在method里面提交Mutations ...mapMutations({ setLogoutToken: &apos;SET_LOGIN&apos;, // 前面是起的别名，直接 }) 官方文档里有mutations调用的详细方法：https://vuex.vuejs.org/zh-cn/mutations.html 路由导航this.$router.push({}) 命名路由User 拦截导航，vue-router钩子vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消 全局钩子const router = new VueRouter({ ... }) router.beforeEach((to, from, next) =&gt; { // ... }) 每个钩子方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(&apos;/&apos;) 或者 next({ path: &apos;/&apos; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 确保要调用 next 方法，否则钩子就不会被 resolved。 ## babel-polyfill的使用 ## 相当于一个垫片，会模拟es6环境，安装之后，可以使用新的内置的东西如Promise和weakMap等。静态方法如Array.from Object.assign等。实例方法Array.prototype.include，generator函数(建议你使用regenator插件).polyfill会添加到全局的环境中，作为原生的原型如String那样的方式执行。 vuexstate,是存放变量的，是共享的数据，相当于data()里面的数据，是保存在计算属性上的，所以使用的时候可以通过mapState来导入，然后在计算属性里面获取 getter是存放公共函数供组件调用的，从getter里面获取state的值 mutations存放的是改变state数据的方法，不能直接调用mutaitons事件，必须通过store.commit(‘函数名’)来调用，必须是同步函数 比较多的时候，用types常量来保存事件类型 mutation 像事件注册，需要相应的触发条件。actions是管理触发条件的 http://www.cnblogs.com/huansky/p/6517237.html axios发送ajax请求的使用文档：https://github.com/mzabriskie/axios 通用的get\post请求就不特别说明了 如果想在全局使用，可以挂在在vue的原型上： // 将axios挂载到prototype上，在组件中可以直接使用this.axios访问 Vue.prototype.axios = axios; 如果只在几个组件里使用，可以直接导入，然后直接用axios.get来访问 如果组件比较多的情况下，可以抽象出来，放在api里面处理，用一个函数来请求对应的数据，然后在需要的页面将这个函数引入 axios的配置如果有需要，是可以对axios做一些定制的，这样，每一次请求的时候，都会基于这些配置，如下： 全局配置 axios.defaults.baseURL = ‘https://api.example.com‘; axios.defaults.headers.common[‘Authorization’] = AUTH_TOKEN; axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’; 某一个实例里面配置 // Set config defaults when creating the instance var instance = axios.create({ baseURL: &apos;https://api.example.com&apos; }); // Alter defaults after instance has been created instance.defaults.headers.common[‘Authorization’] = AUTH_TOKEN; 请求拦截axios中文文档：https://www.kancloud.cn/yunye/axios/234845 拦截器，在请求发送之前进行处理 注意设置自定义头部时候的跨域问题：https://segmentfault.com/q/1010000009530504]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础知识学习总结]]></title>
    <url>%2F2017%2F03%2F01%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学习文档目录官网:http://cn.vuejs.org/ http://cn.vuejs.org/v2/guide/ https://www.awesomes.cn/subject/vue MVVM机制M:model 数据模型:提供数据(ajax) V:view 视图 视图、负责展现在我们浏览器端东西 VM:view-model 相当于是控制器 和angular对比，数据双向绑定原理的不同angular是脏检查机制 脏数据就是之前的数据已经更新了，有了新数据，但是视图不知道，没有更新数据，就需要检查数据有没有更新，有就去通知视图更新。 原生的dom事件、ajax事件、timer事件、Location变更事件，会阻断angular的脏检查机制，如果需要手动触发脏检查，要把执行的代码放在$apply()的回调里面； angular对这些事件做了封装，在事件触发的时候，执行$digest()或$apply. https://github.com/xufei/blog/issues/10 步骤就是： Angular 在作用域$scope上设置了一个监听队列，用来监听数据变化并更新 view 。 当每次给view绑定一个事件，比如ng-click的时候，AngularJs内部 就会往 $watch 队列里插入一条新 $watch，用来检测它监视的 model 里是否有变化的东西。$watch对象里面有三个参数，其中getNewValue()方法可以得到$scope上的最新值，listener方法可以比较新旧值，做操作。 当view接收到可以被 angular context 处理的事件，比如说dom事件，ng-click,ajax事件（angular里面是$http），$timeout,$interval定时器事件,主要是异步事件，$digest 循环就会触发，遍历所有的 $watch队列，有变化，就会更新$scope里面的val值对应的 dom。 Vue.js通过属性劫持再结合发布者-订阅者模式来绑定 比如说有一份数据a.b，a对象里面有属性b，在Vue实例化的过程中（new Vue()）,会用Object.defineProperty()方法给a.b添加getter和setter方法； 同时，vue.js的compile会解析模板，生成一个指令对象，比如v-text=”a.b”，每一个指令对象都会关联一个watcher（a.b），指令对应的a.b的有值时候，就会触发到它上面的getter，会被通知到watcher，a.b的值再有变化的时候，就会触发setter，watcher会再次获取a.b的值，并对比新旧的值，发现值改变了，就会通知指令v-text。 指令v-text是vue内部封装好的dom操作方法，会调用原生的innerText更改值。 vue和angular对比的优缺点 vue比angular1好用的多，更轻量，大小只有26k，移动端开发很占优势，就是环境搭建比较复杂，但是组件化开发，维护成本低；学习成本地，学习曲线平稳。 vue借鉴了angular的指令和react的组件化，把页面抽成组件树，每个组件都有完整的生命周期 vue.js 2.0 新增了虚拟dom，提升了加载速度http://www.cnblogs.com/lvyongbo/p/5931636.html angular1后面从2开始就重写了，$scope变成zone.js，控制器也变成了component组件，学习成本太高了。现在都发展到4了，1早晚会被淘汰的。 angular1和vue的数据双向绑定机制是不一样的。如上。 vue指令v-text&amp;v-html v-text：显示文本 v-html：解析并且显示html字符串 v-on: 给我们的dom元素上绑定事件的 v-bind: 给我们标签绑定属性，它的目的是让我们的某些标签属性上面的值来自我们model v-model: 用来实现数据双向绑定（模型更改之后，会更新视图，视图更改之后，会影响模型） v-if/v-else: 判断是否需要渲染我们标签 v-for: 循环渲染html标签 注意点: 1、指令要和html元素作用在一起 2、v-bind和我们v-on都有缩写的方式 v-bind: 可以缩写成 `:` v-on: 可以缩写成`@` 3、v-model只会作用于哪些有value值的标签(input checkbox...) 4、v-else/v-else-if必须紧跟在上一个v-if后面 vue路由步骤: 1、写好html中的代码 1&lt;router-link to=&quot;/xxxx&quot;&gt;&lt;/router-link&gt; 1&lt;router-view&gt;&lt;/router-view&gt; 2、写好js中的代码 1、定义好组件 2、将组件和具体跳转路径配置在路由中 3、将路由和vue实例关联起来 vue-resource步骤:参考:https://github.com/pagekit/vue-resource/blob/develop/docs/http.md 1、导入vue-resource 2、调用方法 this.$http.get/post/jsonp(url).then(成功的回调，失败的回调) 注意:post请求，在我们第三个参数中，一定得设置{emulateJSON:true}]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js基础知识]]></title>
    <url>%2F2017%2F01%2F13%2Fnode-js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[学习资源网站:国内NodeJS开发者社区：https://cnodejs.org/ 书籍:《深入浅出Node.js》：作者：阿里巴巴.朴灵 阿里开源论坛:http://code.taobao.org/ 360下面的:https://75team.com/ http://stackoverflow.com/ 全世界最牛的程序员问答网站 百度 接收请求，响应的通用步骤&quot;use strict&quot; // 1.引入模块 const http = require(&quot;http&quot;); const path = require(&quot;path&quot;); const fs = require(&quot;fs&quot;); // 2.创建服务 const server = http.createServer(); // 3.请求/响应 server.on(&quot;request&quot;, (req, res) =&gt; { if (req.url.includes(&quot;index.html&quot;)) { fs.readFile(path.join(__dirname, &quot;index.html&quot;), (err, data) { res.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;); res.end(data); }) } }); // 4.启动服务(三个参数：端口，IP地址， 回调) server.listen(8899; &quot;127.0.0.1&quot;, (err) =&gt; { if (err) { console.log(err); } console.log(&quot;start OK&quot;) }); path(处理路径)用法： 1.引入模块 const path = require(&quot;path&quot;); 2.path.join()来拼接文件的路径 path.join(__dirname, &quot;index.html&quot;); 03-fs: 在node的eprl软件里读取服务器里面的文件 // 先引入fs模块 const fs = require(&quot;fs&quot;); // 读取服务器硬盘里面的文件 fs.readFile(path.join(__dirname, &quot;index.html&quot;), (err, data) =&gt; { // 读取成功，操作文件 }) // ——dirname是nodejs的全局模块（Globals文档里）,使用时不需要再导入 04-Node后台中模板引擎的使用（xtempalte） Node后台中模版引擎(xtemplate)注意点: xtemplate:他就是在html页面中进行占位的 xtpl:它是在node中利用数据，生成html元素，替换xtemplate的占位符，最终生成完整的网页 xtemplate : https://www.npmjs.com/package/xtemplate 用法: xtpl: 在node中，根据数据去index.html中，根据他的语法，将 123&#123;&#123;#each(foods)&#125;&#125; &lt;li&gt;&#123;&#123;this&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; 数据: [&quot;茶叶蛋&quot;,&quot;卫龙辣条&quot;,&quot;麻辣小龙虾&quot;] 最终生成 &lt;li&gt;茶叶蛋&lt;/li&gt; &lt;li&gt;卫龙辣条&lt;/li&gt; &lt;li&gt;麻辣小龙虾&lt;/li&gt; 注意点: 这两个必须配置起来用，否则不起作用 使用xtmplate&amp;xtpl来动态生成网页的步骤0、使用`npm init -y` 生成项目的配置文件package.json（注意:项目名称不能是中文,不能有空格，文件夹名称可以用下划线） 1、从npmjs中安装我们模版需要的包(注意，要安装两个xtpl xtemplate) 1npm install xtpl xtemplate --save 2、在html页面中使用xtemplate的语法，进行占位 123&#123;&#123;#each(foods)&#125;&#125; &lt;li&gt;&#123;&#123;this&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; 3、在nodejs中利用xtpl，使用renderFile方法，进行动态生成页面 Node、Vue、React项目中凡是使用npm的方式全装包都会有一个配置文件(package.json)package.json它的作用就是用来描述我们项目的 如何生成 1、切换到项目根路径 2、利用 `npm init -y` 注意事项: 以后我们项目中的node_modules下面的第三方包是不会提交到git/svn上面去得，那我们的小伙伴只能拿到我们自己写的代码，但是因为他下载下来的代码是没有第三方包的，所以跑不起来，怎么解决 你的小伙伴只需要切换到项目跟路径下，然后执行`npm install`就可以了，npm会去读取项目根路径下面的package.json,让后找到`dependencies`，就会自动去下载安装 自定义模块写法：先写一个js文件 &quot;use strict&quot; const addFunc = (x, y) =&gt; { return x + y; } const name = &quot;张三&quot;; module.exports = { add: addFunc, name } // 在另外一个地方引入的时候 导入自己写的模块，需要写全路径名称 const addObj = require(path(__dirname, &quot;全路径名称&quot;))； const result = addObj.add(1,3);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web安全之xss学习]]></title>
    <url>%2F2017%2F01%2F05%2Fweb%E5%AE%89%E5%85%A8%E4%B9%8Bxss%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[xss攻击概念就是利用各种手段把恶意代码添加到网页中, 并让受害者执行这段脚本 xss攻击的类型反射型 我们可以用node,express来模拟，客户端在url的search里面传入一段xss攻击的脚本， 比如说img标签，让&quot;xss=&lt;img src=&quot;null&quot; onerror=&quot;alert(1)&quot;&gt;&quot; 这个时候会服务器会接收并解析，xss:req.query.xss,render渲染到模板返回。这个时候如果在服务器设置res.set(‘x-xss-protection’, 0)不让浏览器拦截xss响应，那么就会在页面弹出1。 如果是恶意的，在search栏里面嵌入了iframe，那么会在页面嵌入一个页面，通常见到插入恶意广告，或者直接嵌入一段让用户登陆个人信息的页面，客户输入登陆时，就会泄露了个人的隐私信息。 存储型不是放在search栏里面，而是会存储到服务器端，如数据库，内存，文件系统里面，并不会马上响应回来，下次请求的时候也不用再每次都提交xss代码，通过服务端读取seq里面的文件返回 防御措施编码对用户输入的数据进行HTML Entity编码，一些实体字符，编码成十进制的 过滤移除用户上传的DOM属性，如onerror等移除用户上传的style节点，可以控制页面的显示不显示，js节点，iframe节点 校正避免直接对HTML Entity解码使用DOM Parese转换，校正不匹配的DOM标签 后台接收到之后，对接收到的数据做解码，用正则替换&amp;&lt;等符号为实体字符，进行转义。 前台对后台返回的数据用domParse.js里面的HTMLParse(he.unescape(str, {strict: true}))方法进行先解码，反转义，再解析。domParse会有start,end,char,comment几个函数分别对传入的字符串做html或注释解码，拼接，拼接成一个html元素 这就是前端解码的过程 第三方库的地址：encode.js：可以使用https://github.com/mathiasbynens/he 中的he.js domParse：可以用楼上说的 https://github.com/blowsie/Pure-JavaScript-HTML5-Parser 接下来就是过滤，在前面的函数里面，就将这几个script等的标签过滤掉。校正. 上面的模拟过程在github上有fork的案例 写的比较全面的一个博客：http://www.cnblogs.com/wqhwe/p/5416976.html Cookies如何防范XSS攻击？XSS(Cross-Site Scripting，跨站脚本攻击)是指攻击者在返回的HTML中插入JavaScript脚本。为了减轻这些攻击，需要在HTTP头部配置set-cookie: * HttpOnly - 这个属性可以防止cross-site scripting，因为它会禁止Javascript脚本访问cookie。 * secure - 这个属性告诉浏览器仅在请求为HTTPS时发送cookie。 结果应该是这样的: Set-Cookie: sid=; HttpOnly. 使用Express的话，cookie-session默认配置好了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[angular.js解决跨域问题]]></title>
    <url>%2F2016%2F12%2F15%2Fangular-js%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在使用angularjs做一个demo的时候，出现了跨域问题： app.controller(&apos;move_listCtrl&apos;, [&apos;$scope&apos;, &apos;$routeParams&apos;, &apos;$http&apos;, function($scope, $routeParams, $http) { // 请求豆瓣的aip时，使用angularjs 的 $http模块的jsonp方法： // 豆瓣提供的api &apos;http://api.douban.com/v2/movie/in_theaters&apos;; // 使用jsonp时需要跨域接收 url = &apos;http://api.douban.com/movie/in_theraters?callback=JSON_CALLBACK&apos; $http.jsonp(url).success(function(result) { }).error(function(error) { }) // 结果会报错，因为angularjs内部的机制，会在请求时将请求的url转化为：url=&quot;http://api.douban.com/movie/in_theraters?callback=angular.callback._0&quot;，不符合豆瓣callback请求的要求。因为后台可能就是用&quot;.&quot;来拼接，这样传参过去，会造成返回数据错误，所以要自己封装jsonp，请求参数设置为可以合理的 }]) 封装自己的jsonp 封装自己的jsonp &lt;script&gt; var myJsonp = function(url, params, callback) { // 1.参数拼接 // url = &quot;http://api.douban.com/v2/movie?satrt=0&amp;counts=20&amp;callback=mycallback&quot; // 拼接提供的跨域接口后面的参数 var queryString = &quot;?&quot;; // 2.参数的形式 // var params = { // start: 0, // count: 20 // } // 遍历参数，获取key=value&amp;key=value的形式 for(var key in params) { queryString += key + &quot;=&quot; + params[key] + &quot;&amp;&quot;; } url += queryString; // 为了解决每一次请求的mycallback同名，返回的mycallback也是同名，导致函数执行的时候，同名函数后面的会覆盖前面的 // 所以需要每一次请求的参数mycack的名字不一样，是一个随机字符串 var myCallback = &apos;callback_&apos; + Math.random().toString().substring(4); console.log(myCallback); // 3.将callback=mycallback拼接在后面 // url = url + &apos;callback=myCallback&apos;; url = url + &apos;callback=&apos; + myCallback; // 相当于： // function dosomething() { // } // url = url + &apos;callback=dosomething&apos; // 或者页面可以定义一个 // function mycallback() { // } // 这个页面里面已经有一个类似于dosomething的函数了，即传入的参数--&gt;回调函数callback // 只是这里已经有一个key值设置为callback了，所以就不直接使用callback，而是另外定义一个变量var mycallback来接收返回值，但是还是让它等于callbak // 如果直接用window.myCallback = callback,就写死了 // window[myCallback] = callback; // callback指传入的参数 window[myCallback] = function(result) { callback(result); } // 以上均为对参数的处理 // 开始封装jsonp的功能 // 1.动态创建script标签 var script = document.createElement(&quot;script&quot;); // 2.设置script的src属性 script.src = url; // url已经在上面做了处理 // 3.将script标签添加到页面上 document.body.appendChild(script); } // 以上已经封装好一个自己的jsonp文件，开始调用 var url = &apos;http://api.douban.com/v2/movie/in_theaters&apos;; // 需要根据豆瓣的api接口文档来传递参数，类似： // var url = &apos;http://api.douban.com/v2/movie/in_theaters?start=0&amp;count=20?callback=mycallback&apos;; // 调用myjsonp方法 var params = { start: 0, count: 20 } myJsonp(url, params, function(result) { console.log(&quot;请求数据到了1&quot;, result); }); myJsonp(url, params, function(result) { console.log(&quot;请求数据到了2&quot;, result); }); myJsonp(url, params, function(result) { console.log(&quot;请求数据到了3&quot;, result); }) &lt;/script&gt;]]></content>
      <categories>
        <category>angular</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node快捷键]]></title>
    <url>%2F2016%2F12%2F01%2F%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[安装系统环境变量 作用： 在终端即ｃｍｄ，在任何目录下，敲指令的时候，都可以使用ｎｏｄｅ．ｅｘｅ这个程序，类似于桌面的快捷方式，否则需要专门打开ｎｏｄｅ．ｅｘｅ所在的文件夹，打开ｃｍｄ才能运行。 npm简写方法：其余的简写请阅读 npm 的简写列表 含义 安装命令 简写方式 安装包 npm install pkg npm i pkg 安装包在全局 npm i --global pkg npm i -g pkg 安装包作为依赖 npm i --save pkg npm i -S pkg 安装包作为开发依赖 npm i --save -dev pkg npm i -D pkg 初始化一个新的包 npm init 创建一个新的包时，需要使用 避开初始配置新的包 npm init -y | npm init -f 运行测试 npm test npm t 列举可运行的脚本 npm run 列举已安装的包 npm ls --depth 0 列举全局安装的包 npm ls -g --depth 0]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发]]></title>
    <url>%2F2016%2F10%2F19%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[微信公众号申请流程基本功能群发功能个人每天只能群发一条消息，在首页新建群发里面 消息自动回复 关键词自动回复 e-learning微信项目： 首页菜单分为：资讯、学习、服务，其中服务又分为：培训签到、在线问答、微课制作、微社区 培训签到有员工编号、员工姓名、部门、手机号码，绑定，重置，签到数据转到学习平台绑定，数据导入。 学习模块，集成了学习平台的业务，比如精品课堂，在线考试，吸引学院进入，完成考试任务 在线测试，下一题，查看，提交 底部按钮返回，或刷新 进入为微课堂，有header,首页，学习，搜索菜单 下面是导航菜单，最新，最热，专题，分类 中间轮播图 下面是课程列表及课程详情 微社区-学员提问和回复 服务器，没有办法使用在线上ngrok node开启npm install -g localtunnel lt –port 3100 实现端口映射 开发用node的koa开发，相当于express 安装koa 和加密的sh1 然后写验证的server.js再用node –harmony server.js开启服务器 http://uxd.baidu.com/2014 图文组件，图标组件，组件化开发，折线图，雷达图，饼图，环图，canvas markman做标注，2倍分辨率 页面组织fullPage.js插件 组织H5报告的内容结构 设置报告的切换效果，page1,page2,fullpage有load和leave事件，加载的时候，通知页面内的component，页面离开的时候通知component 内容组织： 添加一个页 addPage添加一个组件 addComponet展现所有的页面 loader]]></content>
      <categories>
        <category>微信公共号</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[国际站项目技术记录]]></title>
    <url>%2F2016%2F09%2F30%2F%E8%8F%9C%E5%8D%95%E5%BB%B6%E8%BF%9F%E5%88%87%E6%8D%A2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[菜单延迟优化最近对项目里面的一级菜单切换到二级菜单进行了优化，发现需求简单，但是实现起来，要考虑的技术细节问题很多： bug: 鼠标经过一级菜单的时候，会显示二级菜单，但是如果想从一次菜单移动到二级菜单，只能平移，否则触发了鼠标移出事件； 解决思路： 细节： 1.一级菜单和二级菜单基本结构： 一级菜单外层容器： &lt;div class=&quot;main-menu&quot; id=&quot;mainMenu&quot;&gt; &lt;ul&gt; // 一级菜单项 &lt;li data-id=&quot;a&quot;&gt; &lt;span&gt;一级类目&lt;/span&gt; &lt;/li&gt; .... &lt;/ul&gt; // 二级菜单项目 &lt;div class=&quot;hide&quot; id=&quot;subMenu&quot;&gt; &lt;div id=&quot;a&quot; class=&quot;sub-content hide&quot;&gt; &lt;dl&gt; &lt;dt&gt; &lt;a href=&quot;#&quot; target=&quot;blank&quot;&gt;二级类目&lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;#&quot; target=&quot;blank&quot;&gt;二级类目子类&lt;/a&gt; ... &lt;/dd&gt; &lt;dl&gt; &lt;/div&gt; &lt;div id=&quot;b&quot; class=&quot;sub-content hide&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2.css样式： 一级菜单相对定位，二级菜单绝对定位 一级菜单lihover的时候，设置active样式 3.js 菜单移入移出事件，既可以用mouseover和mouseout,也可以用mouseover和mouseleave，但是两者是有区别的： mouseover和mouseout支持事件冒泡，所以鼠标从一级菜单移动到二级菜单上面的时候，即使没有离开父元素，也触发了父元素的mouseout事件 而mouseenter和mouseleave则没有事件冒泡，鼠标离开了一级菜单，进入到二级菜单subMenu的时候，浏览器认为还是在该元素内，不会触发mouseleave行为 所以这里只用mouseenter和mouseleava比较好，否则还要阻止事件冒泡 因为是根据ajax数据动态生成的一级菜单和二级菜单，所以对一级菜单Li操作的时候，没有直接给Li绑定事件，而是绑定在父元素mainMenu上，做了事件代理 鼠标滑过一级菜单Li项目时，mouseenter事件绑定在父元素mainMenu上面，根据e.target来确定触发的是哪一个Li，给这个li添加active样式 二级菜单显示的项目，根据对应的id来确定，取自定义属性data-id来拼接成字符串选择器 bug1:从激活的一级菜单移入到二级菜单的时候，必须平移到当前项的边缘，再进入二级菜单，而不是斜上、斜下，所以需要处理 分析： 进入另外一个li太快了，所以来不及切到二级菜单，那就延迟300ms 解决： 1.在移出当前Li,隐藏当前二级菜单，进入另一个li，显示对应二级菜单的时候，加一个setTimeout定时器，让这一系列事件延迟300ms执行。 2.还需要设置一个标志位，判断鼠标是不是在当前激活项的二级菜单内 var mouseInSub = false sub.on(&apos;mouseenter&apos;, function() { mouseInSub = true; }) 对应离开的时候还原 3.setTimeout的时候，判断一个标志位，如果没有在二级菜单内，就进入下一个菜单。 bug2:在一级菜单Li切换到另外一个li的时候，快速切换，也会显示每一项对应的子菜单，这样会消耗性能。所以需要采用类似于节流的debounce去抖技术，就是事件短时间内频繁触发的时候，只执行最后一次的。 在鼠标在一级菜单上移动的时候，判断前面的定时器timer有没有存在，如果有，再定时器事件开始执行前，就清除掉。 在定时器还没有出发的时候，就把定时器清除掉，定时器里面，也设置timer = null bug3:前面设置的300ms延迟，虽然解决了切换到二级菜单的问题，但是如果不想切换到二级菜单，只想在一级菜单里面移动，还是会有明显的延迟效果，等到300ms之后，判断没有进入二级菜单事件才会执行，这种体验也不好。 分析：判断鼠标下一步要移动的去向，是下一个一级菜单，还是二级菜单 解决：引入向量的概念，鼠标上一次的位置，还有对应的二级菜单的左上角，左下角，形成的一个三角区域，判断鼠标的当前位置落不落在这三个点组成的三角形里面，如果在，就说明，是要移动到二级菜单，不在，移动到下一个一级菜单。 代码思路： 1.设置一个存储位置信息的数组：[]； 2.给document绑定mousemove事件，将鼠标当前位置push进数组,只需要保存当前和上一次的位置就可以了，所以多的就清除掉 var moveHandler = function (e) { mouseTrack.push({ x: e.pageX, y: e.pageY })// 获取当前鼠标相对于页面的坐标保存到mouseTrack里 if (mouseTrack.length &gt; 3) { mouseTrack.shift() }// 只保存三个信息 } 3.算法，涉及到的公式： 向量： Vab = Pb - Pa 二维向量叉乘公式： a(x1, y1) * b(x2, y2) = x1 * y2 - x2 * y1 4.另外封装一个判断点在不在三角形内的函数： // 判断两个数的符号是否相同 (用异或运算判断) function sameSign (a, b) { return (a ^ b) &gt;= 0 } // 向量的计算，终点坐标减去起点坐标 function vector (a, b) { return { x: b.x - a.x, y: b.y - a.y } } // 向量的叉乘公式：向量1的x坐标*向量2的y坐标-向量1的y坐标*向量2的x坐标 function vectorProduct (v1, v2) { return v1.x * v2.y - v2.x * v1.y } // 判断鼠标当前点是否在三角形内 // 点p是鼠标当前的位置，其他是三角形三个点的位置 function isPointInTrangle (p, a, b, c) { // p是鼠标当前点 // 向量 var pa = vector(p, a) var pb = vector(p, b) var pc = vector(p, c) // 向量叉乘 var t1 = vectorProduct(pa, pb) var t2 = vectorProduct(pb, pc) var t3 = vectorProduct(pc, pa) // t1 t2 t3 符号相同时点在三角形内 // 判断叉乘结果的符号是正还是负，如果是正，就在三角形内 return sameSign(t1, t2) &amp;&amp; sameSign(t2, t3) } // 根据p在不在三角形里面，来判断是否需要延迟，即进入到二级菜单，否则不延迟，就直接进入下一个一级菜单 function needDelay (elem, leftCorner, currMousePos) { // 利用Jquery的offset方法获取二级菜单的上下边缘的坐标 var offset = elem.offset() // 先获取二级菜单的偏移位置 var topLeft = { x: offset.left, y: offset.top } var bottomLeft = { x: offset.left, y: offset.top + elem.height() } // 调用点位置判断函数，传入鼠标当前位置，上一次鼠标位置，子菜单左上角坐标、左下角坐标 return isPointInTrangle(currMousePos, leftCorner, topLeft, bottomLeft) } 根据这个工具函数，去传入各个点的位置参数，获取是否需要延迟的结果： var currMousePos = mouseTrack[mouseTrack.length - 1] // 当前点的坐标 var leftCorner = mouseTrack[mouseTrack.length - 2] // 鼠标上一次位置的坐标 var delay = needDelay(sub, leftCorner, currMousePos) // 是否需要延迟 如果需要延迟，就执行setTimeout这个延迟300ms的函数，否则就直接进入下一个菜单 以上主要思想其实在于充分的运用了节流、debounce这一技术，这个很值得研究，因为项目里面，做优化的时候，往往会涉及到这个技术点。哪天专门写一篇总结。 侧边栏滚动特效有一个需求，是两栏布局的情况下，侧边栏要求既有固定，又有滚动特效。 这个其实还是比较好实现的，只要侧边栏的高度比滚动高度 + 屏幕的高度小的时候，用position:fixed，其他时候，设置position:static就好了。 但是实际上，写的时候，遇到了两个bug: 1.滚动的时候：设置position:fixed之后，再设置top: 0, right: 0,结果一下子跳到最顶端去了，实际效果是希望这个时候还是停留在当前滚动的位置，左侧固定边栏下面一点的位置。 最后解决办法是设置一个-top值，这个值是边栏的高度 - 屏幕的高度。 2.窗口缩小的时候，发现左侧边栏不见了，需要滚动一下，边栏才会出来。 解决办法就是监听window.resize事件，用trigger(‘scroll’)事件来触发。 其中：滚动高度：$(window).scrollTop() 屏幕高度：$(window).height() 滚动事件：$(window).scroll(function(){}) 窗口大小改变事件：$(window).resize(function(){}) 图片剪切问题这个项目里面需要用到图片上传，剪裁，做了一下技术选型，最后选了jQuery-photoClip.js,图片可以实现放大，缩小，移动，旋转，和剪裁，剪裁后的图片以base64的形式返回，通过ajax发送给服务器，返回jpg格式图片http://www.023xs.cn/Article/60http://www.qdfuns.com/notes/17791/7b62eebb2eb0a6340a3891ee3457a937.html 图片svg不会失真，比较小 图片使用：如果颜色比较丰富，可压缩性比较高，用jpg.如果是比较通用的动画，用gif，不支持半透明和icon清晰的图片，显示颜色丰富的图片，用png，降低图片质量， 小图标，自己合成sprite精灵图 响应式图片的未来理念]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Promise学习]]></title>
    <url>%2F2016%2F09%2F25%2FPromise%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[作用 是一个异步对象，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 使用var promise = new Promise(function(resolve, reject) { if (/* 异步操作成功 */){ resolve(value); // 将成功的结果抛出去 } else { reject(error); } }); promise.then(function(value) { // success }, function(value) { // failure }); 学习文档阮一峰大神的：http://es6.ruanyifeng.com/#docs/class-extends https://mp.weixin.qq.com/s?__biz=MzIyMzAwNzExNg==&amp;mid=209354478&amp;idx=1&amp;sn=edd70e826b6f9e8a570024f431c5f7fe&amp;scene=1&amp;key=c76941211a49ab58efed75a0405e3ca61338952103fe9eabf8528d801906e4522737274eecca5489d635a5c1aa5d8b12&amp;ascene=0&amp;uin=MTYxMDY3MjU1&amp;devicetype=iMac+MacBookPro11%2C3+OSX+OSX+10.10.4+build(14E46)&amp;version=11020113&amp;pass_ticket=ws1Ar8vSXgH8%2FuRvUaFkiKCA57pR8100%2BhwA5Ifuc00%3D demo &lt;script&gt; console.dir(Promise); // 构造函数，有all()、reject()、resolve(),原型上有then()方法 var P = new Promise(function (resolve, reject) { setTimeout(function () { console.log(&apos;执行完成&apos;); resolve(&apos;等待数据&apos;); }, 2000); }); function runAsync1() { var p = new Promise(function (resolve, reject) { //做一些异步操作 setTimeout(function () { console.log(&apos;执行完成&apos;); resolve(&apos;随便什么数据&apos;); }, 2000); }); return p; } // var result = runAsync(); // 返回promise对象 runAsync1() .then(function (data) { console.log(data); return runAsync2(); }) .then(function (data) { console.log(data); return runAsync3(); }) .then(function (data) { console.log(data); }); var myFirstPromise = new Promise(function (resolve, reject) { //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...) //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法. setTimeout(function () { resolve(&quot;成功!&quot;); //代码正常执行！ }, 2000); }); myFirstPromise.then(function (successMessage) { //successMessage的值是上面调用resolve(...)方法传入的值. //successMessage参数不一定非要是字符串类型，这里只是举个例子 console.log(&quot;Yay! &quot; + successMessage); }); &lt;/script&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片优化之预加载]]></title>
    <url>%2F2016%2F09%2F22%2F%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E4%B9%8B%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[背景慕课网学习记录： 页面里面图片资源比较丰富的时候，加载比较慢，但是又需要全部展示出来给用户看，一张张加载很容易造成假死，效果很不好。 比如首页有很多图片，展示性的，所以可以用一个loading进度条，显示加载的进度，等加载完毕之后，再全部显示，就需要预加载 或者局部加载，一个评论框，下面可以选择表情，也需要把表情全部展示出来，如果不适用预加载，会看到那些表情是一个个加载的，有快有慢，体验不好。 或者是上一页下一页的图片，点击当前一页图片的时候，提前加载下一页的图片。 概念提前加载图片，当用户需要查看时可直接从本地缓存中渲染，可以保证图片无缝的展示，用户体验更好。 分类有序加载 无序加载 封装插件image-preLoad提供了三个实例： 1.先loading进度条显示进度，图片再无序预加载，进度条加载完毕，展示所有图片。 2.qq表情无序加载，点击选择表情按钮时，loading进度条显示完毕，显示所有图片 3.柯南漫画的有序加载，翻页时提前展示下一页 原理就是： 进度条无序加载的原理是先用一个loading进度条显示的图片覆盖住要显示的页面，然后遍历图片的所有地址，在每次循环的时候new 一个 image图片，然后监听图片的load事件，图片加载完毕，就把地址赋值给图片。直到所有的图片都加载完毕，再让进度条消失，让图片显示出来。 原生代码： &lt;script&gt; var imgs = [ &apos;http://i2.hoopchina.com.cn/user/308/15960308/13383588090.jpg&apos;, &apos;http://img.article.pchome.net/00/44/23/20/pic_lib/wm/2.jpg&apos;, &apos;http://lcd.yesky.com/imagelist/2009/044/404q4y8g4m0p.jpg&apos;, &apos;http://lcd.yesky.com/imagelist/2009/044/cgro54wt2t2x.jpg&apos; ]; var index = 0, // 当前是第几张图片 len = imgs.length, // 图片的总长度 $progress = $(&apos;.progress&apos;), var count = 0 // 当前加载的数量 // 遍历所有图片的src $.each(imgs, function (i, src) { // 创建图片 var imgObj = new Image(); // 当前图片加载完毕的时候 $(imgObj).on(&apos;load error&apos;, function () { // 每加载一次,显示加载 $progress.html(Math.round((count + 1) / len) + &apos;%&apos;); // 如果所有的都加载完毕，就将loading页面隐藏起来 if (count &gt;= len - 1) { $(&apos;loading&apos;).hide(); // 当前页是第一张 document.title = &apos;1/&apos;; } count++; }); imgObj.src = src }) &lt;/script&gt; 封装插件：这里就不详细贴代码了，按照jquery插件封装的方法： 1.一个自执行函数，不会污染全局变量； 2.面向对象的方法，创造一个preload构造函数，传入参数； 3.设置默认参数，用$extend{target, obj1, obj2}进行合并； 4.将有序时执行的方法和无序时的方法挂载在构造函数的原型上； 5.用$.extend({ preLoad: funciton() {new PreLoad()}的方法将其作为工具函数，合并到jquery函数中， // 调用的时候直接：$.perload(传参)即可 如果是$.fn.extend话，是实例方法，要用一个元素去调用。 })]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery插件的封装]]></title>
    <url>%2F2016%2F09%2F21%2Fjquery%E6%8F%92%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[因为项目里面要用tab栏切换和轮播图的地方有多处，为了增强复用性，而且本来需求也比较简单，就没有用网上的swipe插件，自己写了两个。 tab栏切换;(function($) { $.fn.tab = function(options) { var defaults = { currentClass: &apos;active&apos;, tabNav: &apos;.tab-nav&gt;li&apos;, tabContent: &apos;.tab-content&gt;div&apos;, eventType: &apos;click&apos; } var options = $.extend(defaults, options); this.each(function() { var _this = $(this); _this.find(options.tabNav).on(options.eventType, function() { $(this).addClass(options.currentClass).siblings().removeClass(options.currentClass); var index = $(this).index(); _this.find(options.tabContent).eq(index).show().siblings().hide(); }) }) } }(jQuery) // 调用的时候，必须用实例方法调用 $(function(){ $(&apos;.tab&apos;).tab({ currentClass:&apos;current123&apos;, eventType:&apos;click&apos; ..... }); }); 轮播图插件;(function($){ $.fn.slider = function(options){ var defaults = { auto: true, //是否自动播放 sliderLi : &apos;.slider_main li&apos;,//轮播图片盒子 dotLi:&apos;.slider_nav li&apos;,//轮播图的点点图标 sliderprev:&apos;.slider_pre&apos;, slidernext:&apos;.slider_next&apos;, currrent:&apos;on&apos;,//为当前的数据添加背景颜色或者其他 easing : &apos;ease&apos;,//特效方式，ease-in,ease-out,linear duration : 1000,//每次动画执行的时间 direction : &apos;vertical&apos;,//滑动的方向 horizontal,vertical, eventType :&apos;click&apos; }; var settings = $.extend({}, defaults, options); // this.each(function(index, el) { var _this = $(this), currentIndex = 1,//第一个 interval = null,//设置自动播放程序 length = $(settings.sliderLi).length, _sliderLi = $(settings.sliderLi,_this), _dotLi = $(settings.dotLi,_this), _sliderprev = $(settings.sliderprev,_this), _slidernext = $(settings.slidernext,_this); /*点击小点显示索引轮播*/ _this.find(settings.dotLi).on(settings.eventType , function(){ var index = $(this).index(); $(this).addClass(settings.currrent).siblings().removeClass(settings.currrent); $(_sliderLi).eq(index).fadeIn().siblings().fadeOut(); console.log(&quot;sdfs&quot;); }); /*上下页面点击事件*/ _sliderprev.add(_slidernext).click(function(){ clearInterval(interval); $(this).is(_slidernext) ? next() : prev(); }); /** * 下一页 */ function prev(){ var preIndex=currentIndex; currentIndex=(--currentIndex+length)%length; play(preIndex,currentIndex); } /** * 下一页 */ function next(){ var preIndex=currentIndex; console.log(preIndex); currentIndex=(++currentIndex+length)%length; play(preIndex,currentIndex); } /* *开始循环播放 */ function play(current, currentOther){ _this.find(settings.dotLi).removeClass(settings.currrent); _this.find(settings.dotLi).eq(current).addClass(settings.currrent); _this.find(settings.sliderLi).eq(current).fadeIn().siblings().fadeOut(); } function auto(){ settings.auto ? interval = setInterval(next,settings.duration) : false; } auto(); //hover $(this).hover(function() { console.log(&quot;sdfs&quot;); clearInterval(interval); }, function() { auto(); }); }); //返回 return this; } })(jQuery); // 调用的时候 $(&quot;#sliderBox&quot;).slider({ auto:false, duration:1000 }); http://blog.csdn.net/chenxi1025/article/details/53888759]]></content>
      <categories>
        <category>Javascript</category>
        <category>jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[es6]]></title>
    <url>%2F2016%2F08%2F29%2Fes6%2F</url>
    <content type="text"><![CDATA[const和let可以根据阮一峰大神的博客学习 其他：http://jspang.com/2017/06/03/es6/ let 用来声明变量，用法类似于var，所声明的变量，只在let命令的代码块内有效，var在{}外面也可以访问到。 例子： function test() { if (flag) { var a = &quot;js&quot; } // 可以访问 } 但是let: function test() { if (flag) { let a = &quot;js&quot; // 只在这个代码快内有效 } // 不可以访问a } let声明的变量没有变量提升，不是undefined，而是直接报错，is not defined for循环的时候，只能在循环体内使用 存在封闭作用域，不允许同时声明同一个变量 const命令声明一个只读的常量，一旦声明，常量的值就不能改变，一旦声明，必须赋值，否则报错也只在块级作用域内有效，也不会有变量提升 箭头函数var f = v =&gt; v // 相当于： var f = function (v) { return v; } var sum = (num1 + num2) =&gt; num1 + num2; // 相当于： var sum = function (num1, num2) { return num1 + num2; } 比如立即执行函数： (function() { console.log(1); })() // 简写成： (() =&gt; { console.log(1) })() 除了写法简化，很重要的一点就是它有词法作用域this值，可以很好的解决this的指向问题，使用了，就不需要像原来一样，要用that = this或_this = this, 使用注意点 箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。]]></content>
      <categories>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复杂数据类型之深度克隆和浅克隆问题]]></title>
    <url>%2F2016%2F08%2F28%2F%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最早是在做百度ife题目的时候，看到了这个问题，发现对理解js复杂数据类型很有帮助，就陆陆续续的记录了一下，后来又总结了其他的一些方法。 js原生方法 /** 需求：实现一个深度克隆，可以复制一个目标对象，返回一个完整拷贝 被复制的对象类型会被限制为数字、字符串、布尔、日期、数组、Object对象。不会包含函数、正则对象等 分析：根据数据类型不同，采用不同的复制方法，因为如果是复杂数据类型的。 不能直接赋值，因为对象的名字只是一个指针，指向实际地址，如果直接赋值，得到的是同一个对象，两者是相关的，操作其中的一个，会影响到两外一个 **/ // 根据参数数据类型判断是否要遍历 function deepClone(src) { // src 是string number boolean null undefined类型 if (src == null || typeof src != &quot;object&quot;) { return src; } // src是object类型 var dataType = Object.prototype.toString.call(src).slice(8, -1); // console.log(Object.prototype.toString.call([])); // [object Array] // src是日期 if (dataType == &quot;Date&quot;) { return new Date(src.getDate()); } // src是Array或Object属性，需要递归去遍历对象上面扩展的属性 if (dataType == &quot;Array&quot;) { var clone = []; for(var key in src) { clone[key] = arguments.callee(src[key]); } return clone; } if (dataType == &quot;Object&quot;) { var clone = {}; for(var key in src) { if(src.hasOwnProperty(key)) { clone[key] = arguments.callee(src[key]); } } return clone; } } // 测试示例 var srcObj = { a: 1, b: { b1: [&quot;hello&quot;, &quot;hi&quot;], b2: &quot;JavaScript&quot; } }; var target = deepClone(srcObj); srcObj.a = 2; console.log(target.a); // console.log(target.b.b1[0]); // target.b.b1[0] = &apos;xiaoming&apos;; // console.log(srcObj.b.b1[0]); // hasOwnProperty是Object构造函数原型上的方法，但是某一个对象本身也可能有hasOwnProperty作为属性名的属性，只有使用原型或构造函数上面的hasOwnProperty才能获取到正确结果 // var foo = { // hasOwnProperty: function () { // return false; // }, // bar: &apos;Here be dog&apos; // } // console.log(foo.hasOwnProperty(&apos;bar&apos;)); // 会先找到自己内部的属性 // false //可以使用call或apply调用原型链上的方法 // ({}).hasOwnProperty.call(foo, &apos;bar&apos;); // true //或者是Object原型上的hasOwnProperty属性 // Object.prototype.hasOwnProperty.call(foo, &apos;bar&apos;); // true 继承的方法 因为实例化对象可以继承原型上的属性，所以我考虑用继承的方法来实现 var srcObj = { a: 1, b: { b1: [&quot;hello&quot;, &quot;hi&quot;], b2: &quot;JavaScript&quot;, b3: { c1: &quot;html5&quot;, c2: &quot;css3&quot; } }, c: [&quot;xiaoming&quot;, &quot;xiaohong&quot;, &quot;xiaofeng&quot;] }; var target = Object.create(srcObj); // console.log(target.__proto__ == srcObj); // target可以引用原型上的值 target.b.b3.c2 = &quot;animation&quot;; console.log(srcObj.b.b3.c2); // &quot;animation&quot; target.a = 2; console.log(srcObj.a); // &quot;1&quot;; target.d = &quot;string&quot;; console.log(srcObj.d); // &quot;undefined&quot; /** 总结： 1.实例化对象从原型上继承的属性值是基本类型时，改变实例化的属性值不会影响到原型的值； 2.实例化对象从原型上继承的属性值是引用类型时，改变实例化的属性值，会影响原型的属性值 **/ 但是发现继承来的属性，如果是引用数据类型，会改变原型的值，这种方法不可取 JSON序列化克隆的方法 // JSON序列化克隆的方法 // 测试示例 var srcObj = { a: 1, b: { b1: [&quot;hello&quot;, &quot;hi&quot;], b2: &quot;JavaScript&quot;, b3: { c1: &quot;html5&quot;, c2: &quot;css3&quot; } }, c: [&quot;xiaoming&quot;, &quot;xiaohong&quot;, &quot;xiaofeng&quot;] }; var target = JSON.parse(JSON.stringify(srcObj)); // console.log(target); target.b.b1[0] = &quot;world&quot;; target.c[1] = &quot;dahong&quot;; console.log(srcObj.b.b1[0]); // &quot;hello&quot; console.log(srcObj.c[1]); // &quot;xiaohong&quot; // 问题：1.不能实现函数的deepClone var srcObj1 = { a: 1, b: function() { console.log(&quot;deepClone&quot;); } } var target1 = JSON.parse(JSON.stringify(srcObj1)); console.log(target1); // { a: 1 } // JSON序列化实现对象深度克隆的方法 var cloneObj = function(obj) { var str, newobj = obj.constructor === Array ? [] : {}; if (typeof obj !== &apos;object&apos;) { return; } else if(window.JSON) { str = JSON.stringify(obj); // 把json对象序列化为json字符串 newobj = JSON.parse(str); // 还原 } else { for(var key in obj) { newobj[key] = typeof obj[key] === &apos;object&apos; ? cloneObj(obj[key]) : obj[key] // 递归处理对象上扩展的属性 } } return newobj; } jQuery中的$extend()方法可以实现深度克隆和浅复制 /** * jQuery中的$.extend()方法可以实现深复制和浅复制 * 语法： * 1.deep copy：$.extend(true, {}, obj)； * 2.shallow copy: $.extend({}, obj); **/ // 测试示例 var srcObj = { a: 1, b: { b1: [&quot;hello&quot;, &quot;hi&quot;], b2: &quot;JavaScript&quot;, b3: { c1: &quot;html5&quot;, c2: &quot;css3&quot; } }, c: [&quot;xiaoming&quot;, &quot;xiaohong&quot;, &quot;xiaofeng&quot;] }; var target1 = $.extend(true, {}, srcObj); var target2 = $.extend({}, srcObj); console.log(target1); console.log(target2); target1.b.b1[0] = &quot;world&quot;; console.log(srcObj.b.b1[0]); // &quot;hello&quot; target2.b.b1[0] = &quot;shadow&quot;; console.log(srcObj.b.b1[0]); // &quot;shadow&quot; srcObj.b.b1 === target2.b.b1; // true 指向同一个地址 srcObj.b.b1 === target1.b.b1; // false 内存中的地址不一样 // 可以实现函数的deep copy var srcObj1 = { a: 1, b: function() { console.log(&quot;deepClone&quot;); } } var target3 = $.extend(true, {}, srcObj1); console.log(target3); $.extend的使用 /** * 语法：$.extend(target, obj1, obj2, ...objN); 参数可选 * 用法：合并obj1、obj2到target对象，第一个参数是要合并的对象 * 返回合并后的对象target **/ var obj1 = { name: &apos;Tom&apos;, age: 21 } var obj2 = { name: &apos;Jerry&apos;, sex: &apos;boy&apos; } // $.extend(obj1, obj2); // {name: &quot;Jerry&quot;, age: 21, sex: &quot;boy&quot;} // obj1 // {name: &quot;Jerry&quot;, age: 21, sex: &quot;boy&quot;} // obj2 // {name: &quot;Jerry&quot;, sex: &quot;boy&quot;} // 将obj2合并到obj1，改变了obj1的结构 // 不改变结构 console.log( $.extend({}, obj1, obj2) ); // {name: &quot;Jerry&quot;, age: 21, sex: &quot;boy&quot;} console.log(obj1); // {name: &quot;Tom&quot;, age: 21} console.log(obj2); // {name: &quot;Jerry&quot;, sex: &quot;boy&quot;} // 后面的参数如果和前面的参数有相同的名称，合并后，后面的会覆盖前面的 // $.extend()方法在写插件的时候用的比较多，通常设置一个默认参数，然后用这个方法将用户设置的参数合并到默认参数中 ;(function($) { // 定义默认值 var Bird = function() { this.defaults = { name: &apos;parrot&apos;, age: &apos;2&apos;, sex: &apos;male&apos; } } Bird.prototype = { doSomething: function(options) { // 合并用户传入的参数，覆盖默认属性 // 用户没有传递的属性，使用默认值，传递了，替换默认值 var options = $.extend(this.defaults, options); } } window.Bird = Bird; })(Jquery) es6的拷贝方法ES6 中对象拷贝方法： * 方法一： Object.assign() // 对象浅拷贝， 复制所有可枚举属性 const obj1 = {a: 1}; const obj2 = {b: 2}; // copy obj1 and obj2 to a new obj; Object.assign({}, obj1, obj2) * 方法二 ：Res参数 //等同于方法一， 属于对象浅拷贝 const obj1 = {a: 1, b: 2}; // obj2 equal obj1 const obj2 = {...obj1}; * 方法三 //在对象的拷贝方法中比较困扰的就是深层拷贝，此方法为深层拷贝； function deepCopy (data) { return JSON.parse(JSON.stringify(data)); } 实现一个函数clone， 可以对JavaScript中的5种主要的数据类型（ 包括Number、 String、 Object、 Array、 Boolean） 进行值复制 考察点1： 对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚考察点2： 是否知道如何判断一个变量是什么类型的考察点3： 递归算法的设计 // 方法一： Object.prototype.clone = function () { var o = this.constructor === Array ? [] : {}; for (var e in this) { o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e]; } return o; } //方法二： /** * 克隆一个对象 * @param Obj * * @returns */ function clone(Obj) { var buf; if (Obj instanceof Array) { buf = []; //创建一个空的数组 var i = Obj.length; while (i--) { buf[i] = clone(Obj[i]); } return buf; } else if (Obj instanceof Object) { buf = {}; //创建一个空对象 for (var k in Obj) { //为这个对象添加新的属性 buf[k] = clone(Obj[k]); } return buf; } else { //普通变量直接赋值 return Obj; } }]]></content>
      <categories>
        <category>Javascript</category>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[angular.js基础]]></title>
    <url>%2F2016%2F08%2F25%2Fangular-js%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[angular的指令：ng-app 入口指令，表示html使用angular; ng-model 将input/select/textarea的value赋值给变量; &lt;input type=&quot;text&quot; ng-model=&quot;val&quot;&gt;{{ val }}; ng-init 设置变量的初始值 &lt;body ng-init=&quot;val=1&quot;&gt;; ng-click 给元素注册事件 ng-click=&quot; val=val+1 &quot;; angularJs控制器/作用域&lt;div ng-app=&apos;myApp&apos; ng-controller=&apos;myCtrl&apos;&gt; 名:&lt;input type=&apos;text&apos; ng-module=&apos;name1&apos;&gt; 姓：&lt;input type=&apos;text&apos; ng-model=&apos;name2&apos;&gt; 姓名：{{ name1 + "" + name2}} &lt;ul&gt; &lt;li ng-repeat=&apos;x in name3&apos;&gt; {{ x.name + ',' + x.country }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;myCtrl&apos;, [&apos;$scope&apos;, function($scope) { $scope.name1 = &apos;小黄&apos;; $scope.name2 = &apos;小黑&apos;; $scope.name3 = [ {name:&apos;Jani&apos;, country: &apos;Norway&apos;}, {name: &apos;Hege&apos;, country: &apos;Sweden&apos;}, {name: &apos;Kai&apos;, country: &apos;Denmark&apos;} ]; $scope.sayHello = function() { $scope.greeting = &apos;Hello&apos; + $scope.name + &apos;!&apos;; } }]) $scope作用域的问题&lt;div ng-app ng-controller=&gt; &lt;h1&gt;{{lastname}}家族成员&lt;/h1&gt; &lt;ul&gt; &lt;li ng-repeat=&apos;x in names&apos;&gt; {{x}} {{lastname}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;myCtrl&apos;, [&apos;$scope&apos;, &apos;$rootScope&apos;, function($scope, $rootScope) { $scope.names = [&apos;name1&apos;, &apos;name2&apos;, &apos;name3&apos;]; $rootScope.lastname = &apos;Resefre&apos;; }]); &lt;/script&gt; angularJs过滤器 通过一个管道字符（|）和一个过滤器添加到表达式 &lt;div ng-app=&apos;myApp&apos; ng-controller=&apos;personCtrl&apos;&gt; &lt;p&gt;姓名为{{ lastname | uppercase }} // 将其转化为大写 &lt;/div&gt; date格式化 {{new Date().getTime() | date: 'yyyy-mm-dd hh:ss:mm'}} // 2017-03-22 12:03:44 number格式化，保留小数 angular双向数据绑定采用什么机制？简述原理理解为脏检查机制： 1.angularjs里面有一个概念是脏数据，脏数据是过时的数据，比如说两个人都像存钱罐里面存了2元硬币，共4枚，其中一人偷偷拿了1枚，另一个人不知道，以为里面还有4枚。实际上只有三个，但是以为里面有4个这种已经过时的数据就是脏数据； 2. ng-repeat&lt;ele ng-repeat=&apos;item in items&apos;&gt; // items是数组,item相当于数组for循环的value &lt;/ele&gt; // 属性 $even: 模板在html的DOM节点中位置是否是偶数； $odd: 是不是奇数； $first/$last： html的DOM节点中位置是否是首个/最后一个 $index: 代表模板在DOM节点中的索引，不是数组的索引 &lt;ele ng-repeat=&apos;item in items track by $index&apos; // angularjs 默认不允许重复元素，靠数组元素的名字来进行遍历，如果要重复，换成索引来遍历 $watch监听值的变化、数组的长度的变化语法： &lt;input type=&apos;text&apos; ng-model=&apos;value&apos;&gt; 1.$scope.$watch(&apos;value&apos;, function(newVal, oldVal) {}) // value是$scope.value; 2.$scope.$watchCollection(&apos;arr&apos;, function(newVal, oldVal) {}); 3.$scope.$watch(&apos;arr&apos;, function() {}, true); // 既可以监控属性值的变化，也可以监控数组长度的变化 工作中要使用第三种方法，第三种方法包括对象里面更深层次的属性值的变化，都可以被监听到 angularjs提供的jqlite,是部分jquery操作方法，不支持选择器使用： 1.原生方法获取dom元素； var box = document.getElementById(id); 2.封装jqlite var $ = angular.element; 3.利用angular.element提供的方法，来操作DOM,如果有方法不生效，先检测支持行 $(box).on(&apos;mouseenter&apos;, function() { if (!$(box).hasClass(&apos;large&apos;)) { $(box).addClass(&apos;large&apos;); } }).on(&apos;mouseleave&apos;, function(){}) 解决闪烁问题： 1. 问题的产生： 在angularjs的库没有加载完成的情况下，不会按照规则解析{{}} 2. 解决方法： ng-bind=&apos;value&apos; $scope.value = &apos;xiaoming&apos;; 将双标签之间的innerHTML用ng-bind=&apos;value&apos;来替代，不需要再设置，是单项绑定，只输出，不能编辑，只能作用于一行，这样需要绑定的多了，就很麻烦 3. 针对多个需要解决的问题，使用ng-cloak:用法是，多个双标签之间的{{}}绑定，需要把ng-cloak放在根元素上 &lt;html ng-cloak&gt; 在样式里面定义：[ng-cloak]{display: none !important} 原理：浏览器开始解析html页面的{{}}，将通过这个属性选择器选择的元素都以藏起来，等angularjs加载完毕，开始解析时，再将这个元素上面的ng-cloak样式移除，那么这个元素会显示出来 引用外部的模板，类似于项目里面的用include来加载公共模板的功能引入外部模板： ng-include=&apos;变量&apos;，变量在controller中赋值，表示外部外部的模板的路径 页面是靠发送ajax请求的方式将外部的模板加载到页面中的 &lt;div ng-include=&apos;headerPath&apos;&gt;&lt;/div&gt; &lt;div ng-include=&apos;footerPath&apos;&gt;&lt;/div&gt; angular.module(&apos;myApp&apos;, []).controller(&apos;myCtrl&apos;, [&apos;scope&apos;, function($scope) { $scope.headerPath = &apos;./template/header.html；&apos; }]) 缺点： 多个ajax的使用造成发起请求多，效率底，但是页面结构清晰，易于维护 引用内部模板 创建指令时，使用驼峰式命令，使用的时候需要分开 &apos;mouseEnter&apos; --&gt; &apos;mouse-enter&apos; 1.先在内部创建 &lt;script type=&quot;text/ng-template&quot; id=&quot;header&quot;&gt; &lt;h1&gt;内容&lt;/h1&gt; &lt;/script&gt; 2.引用内部模板,不需要在controller里面定义 &lt;div ng-include=&quot; &apos;header&apos; &quot;&gt;&lt;/div&gt; // 这里引入的是模板的id 缺点：对http加载次数有要求的情况下，可以使用； 但是html模板都放在主页里面，代码冗余，难以维护。 自定义指令问题// 1.使用方式 &apos;E&apos; &lt;hello&gt;&lt;/hello&gt; &apos;A&apos; &lt;div hello&gt;&lt;/div&gt; &apos;C&apos; &lt;div class=&apos;hello&apos;&gt;&lt;/div&gt; &apos;M&apos; &lt;!-- directive: hello --&gt; // 2.定义模板 &lt;script type=&quot;text/ng-template&quot; id=&quot;myTemplate&quot;&gt; &lt;ng-transclude&gt;&lt;/ng-transclude&gt; &lt;div&gt;这是自定义指令&lt;/div&gt; &lt;/script&gt; // 3.在controller里面引用 angular.module(&apos;myApp&apos;, []).directive(&apos;hello&apos;, [&apos;$http&apos;, function($http) { return { // template: &apos;&lt;div&gt;这是自定义指令&lt;/div&gt;&apos;； templateUrl: &apos;myTemplate&apos;; // 因为直接在controller里面写会很麻烦，所以可以从外部引用 restrict: &apos;EACM&apos; // E是直接作为元素使用 replace: true //如果没有这一项，模板里的内容输出的在&lt;hello&gt;标签里面，如果定义了就会覆盖页面写的标签 transclude: true; // 原始内容保留,并且需要在模板里面放置需要保留的内容 scope: {} // 表示为一个模板创建自己的作用域，进行隔离 require: &apos;^?common&apos;, // common是另外一个指令的名称，需要引用这个指令里面的controller，^是允许查找父元素的controller？找不到不要抛出异常，只是可选 link: function(scope, element, attrs){} // 定义函数，类似于controller里面定义的方法,参数： scope是模板的作用域, element = angular.element(&quot;box&quot;),使用这个指令的元素的jqueryLITE方法 用法： element.on(&apos;mouseenter&apos;, function&amp;(){}) attrs 是使用这个指令的元素上面的所有属性的集合，是对象 } }]) ng-show 和 ng-hide 和 ng-ifng-show=&quot;true&quot;则显示，否则隐藏 原理是元素的display属性none或者是block ng-if=&apos;true&apos; // 也是一样的用法，但是显示的时候是将这个元素添加到dom树上 隐藏的时候将其从dom树上清除 ng-class用法： 1.可以添加多个样式： &lt;div class=&quot;{&apos;calss名1&apos;： true(或变量名1), &apos;calss2&apos;: 变量名2, &apos;class3&apos;: 变量名3}&quot; 2.只能添加1个样式： &lt;div class=&quot;{true: &apos;large&apos;, false: &apos;color&apos;}[size]&quot; ng-class=&quot;{匹配值1：&apos;样式1&apos;， 匹配2： &apos;样式2&apos;}[匹配变量]&quot; 只能添加一个样式 作用域$scope的用法： 控制器可以层层嵌套，如果子控制器在自己里面没有找到某个属性，会先找父元素，没有再找祖先作用域，最后到达$rootScope; 如果需要对一个全局变量在页面加载的时候初始化，供各个控制器引用，可以用： app.run([&apos;$rootScope&apos;, function($rootScope) { $rootScope.name = &apos;zhangsan&apos;; }]) app.service和app.factory的区别第一、两者的用法： 都是为了不使所有的业务逻辑代码都放在app.controller里面，造成代码冗余，复用性低，所以把复用的功能抽取出来，相当于创建一个util。 可以供多个模块使用 第二、不同点： factory的用法： // 返回的是一个对象，包括数组、函数、对象,必须要有返回值，否则在controller里面加载时会报错 app.controller(&quot;myCtrl&quot;, [&quot;$scope&quot;, &quot;myFactory&quot;, &quot;mySerive&quot;, function($scope, myFactory, myService) { // 执行代码 myFactory.name; myService.get(); }]) app.factory(&quot;myFactory&quot;, [function() { return { name: &apos;xiaomign&apos; } }])； //返回的是一个构造函数 app.service(&quot;myService&quot;, [&quot;$http&quot;, function(#http) { // 在构造函数里面定义方法： this.set = function() {}; this.save = function() {}; }]) app.value 和 app.constant对传递的参数做出定义,使用时注入 app.value(&apos;myValue&apos;, { type: &apos;get&apos;, url: &apos;&apos; }) $location对象angular对location对象做了封装，使用$location; 1.获取完整的url地址： $location.absUrl( ); 2.获取url里面#后面的内容： $location.url( ) --&gt; http://baidu.com#/news?key=value; 3.获取url里面#号-？号之间的内容： $location.path( ) --&gt; http://baidu.com#/news?key=value; 4.设置url地址： $location.url(&apos; /index &apos;);]]></content>
      <categories>
        <category>angular</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ECharts学习笔记]]></title>
    <url>%2F2016%2F08%2F24%2FECharts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[之前做H5页面的时候，有需要做散点图，折线图，柱状图，但是当时是原生方法来写的，没有用插件。 最近研究了一波EChart,发现有大量的可用图表，只需要配置即可，记录一下学习过程。 实现柱状图、折线图1.项目里面引入echarts.js，其中官网可以下载开发，通用，精简多个版本，根据项目需要下载； 2.为ECharts准备一个具备大小（宽高）的Dom容器； 3.基于dom元素，初始化echarts实例 4.指定图表的配置项 5.使用配置项 &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 900px;height:600px;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(&apos;main&apos;)); // 指定图表的配置项和数据 var option = { // 标题 title: { text: &apos;ECharts 入门示例&apos; }, // 工具箱 toolbox: { show: true, feature: { saveAsImage: { // 设置保存图片，可下载图片 show: true } } }, // 图例（表头） legend: { // legend的data的名称和series的data关联 data: [&apos;衣服销量&apos;] }, // x轴 xAxis: { data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;] }, yAxis: {}, // 数据，设置bar类型是柱状图，设置的line类型是折线图 series: [{ name: &apos;销量&apos;, type: &apos;bar&apos;, // 图表的类型，比如柱状图 data: [5, 20, 36, 10, 10, 20] }，{ name: &apos;产量&apos;, type: &apos;line&apos;, data: [7, 30, 50, 11, 40, 80] }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 柱状图和折线图配置的关键在于series数组里面的对象的type不同 标题组件配置项里面设置 // 标题设置 title: { show:true, text: &apos;ECharts 学习&apos;, subtext:&apos;标题组件学习&apos;, left:&apos;100&apos;, // 数字就是像素值 ，也可以是 center left right这种值 top: &apos;0&apos;, borderColor:&apos;red&apos;, borderWidth:5, textStyle:{ fontSize:20 } }, 工具栏组件设置 toolbox: { show: true, feature: { dataView:{ // 数据视图 show:true }, restore:{ // 还原 show:true }, dataZoom:{ // 区域缩放 show:true }, saveAsImage: { // 下载图片 show: true }, magicType: { // 折线图和柱状图切换 type: [&apos;line&apos;, &apos;bar&apos;] } } }, tooltip悬浮框文字设置 效果是设置的时候，鼠标滑过图表时，显示当前的数据项 tooltip: { trigger: &apos;axis&apos; // 触发x轴data }, legend: { data: [&apos;销量&apos;] }, xAxis: { data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;] }, yAxis: {}, 标记线和标记点设置类型均可以设置最大值，最小值，平均值，并且可以设置线的样式，比如arrow series: [{ name: &apos;销量&apos;, type: &apos;line&apos;, data: [5, 20, 36, 10, 10, 20], markPoint: { // 可以设置任意点的位置 data: [ {type: &apos;max&apos;, name: &apos;最大值&apos;}, {type: &apos;min&apos;, name: &apos;最小值&apos;,symbol:&apos;arrow&apos;} // 点的样式 ] }, markLine: { data: [ {type: &apos;average&apos;, name: &apos;平均值&apos;} ] } }] 饼图 展示百分比 type是pie // 指定图表的配置项和数据 var option = { title : { text: &apos;某站点用户访问来源&apos;, subtext: &apos;纯属虚构&apos;, x:&apos;center&apos; }, tooltip : { trigger: &apos;item&apos;, formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot; }, legend: { orient: &apos;vertical&apos;, left: &apos;left&apos;, data: [&apos;直接访问&apos;,&apos;邮件营销&apos;,&apos;联盟广告&apos;,&apos;视频广告&apos;,&apos;搜索引擎&apos;] }, series : [ { name: &apos;访问来源&apos;, // 图例名字 type: &apos;pie&apos;, radius : &apos;55%&apos;, // 半径 center: [&apos;50%&apos;, &apos;60%&apos;], // 圆心坐标 data:[ {value:335, name:&apos;直接访问&apos;}, {value:310, name:&apos;邮件营销&apos;}, {value:234, name:&apos;联盟广告&apos;}, {value:135, name:&apos;视频广告&apos;}, {value:1548, name:&apos;搜索引擎&apos;} ] } ] }; 仪表图series: [ { name: &apos;业务指标&apos;, type: &apos;gauge&apos;, detail: {formatter:&apos;{value}%&apos;}, data: [{value: 32, name: &apos;完成率&apos;}] } ] 如果需要动态设置，可以用setTimeout来动态设置数据的值 setInterval(function () { option.series[0].data[0].value = (Math.random() * 100).toFixed(2) - 0; myChart.setOption(option, true); },2000); // toFixed是保留的小数数位 异步数据加载和更新1.先设置数据为空2.异步获取数据 // 异步加载数据 myChart.showLoading(); $.get(&apos;data.json&apos;).done(function (data) { // 填入数据 myChart.setOption({ xAxis: { data: data.categories }, series: [{ // 根据名字对应到相应的系列 name: &apos;销量&apos;, data: data.data }] }); myChart.hideLoading(); myChart.setOption(...); }); 移动端自适应根据media来配置，query里面写规则]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[比较好的博客收录]]></title>
    <url>%2F2016%2F08%2F23%2F%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[博客目录web前端开发大牛信息总结http://blog.sina.com.cn/s/blog_12c2338570102vsju.html 醉牛前端：http://f2er.club/ ionic、vue课程视频比较多的一个大牛的博客：http://parryqiu.com/ https://chenhuichao.com/ vue开启keep-alive的时候的注意事项：http://www.jianshu.com/p/42429f4d8f9e?nomobile=yes vue的nextTick的详细介绍：http://www.cnblogs.com/xujiazheng/p/6852124.html 滴滴的github页面，分享干货：https://github.com/DDFEhttps://github.com/DDFE/DDFE-blog/issues better-scroll的文档：https://www.npmjs.com/package/better-scrollvue better-scroll插件：http://www.cnblogs.com/zhaobao1830/p/7056759.html http://blog.csdn.net/qq_35844177/article/details/54629666 javascript实现两个父子窗口之间通信：http://blog.csdn.net/a352193394/article/details/7487223 正则：http://blog.csdn.net/qq_30632003/article/details/60866241 http://blog.csdn.net/Take_Dream_as_Horse/article/details/70153646 http://blog.csdn.net/FungLeo/article/category/5764167 seo优化：http://www.cnblogs.com/st-leslie/p/5045648.html 组件库地址 饿了么ui：mint-ui https://www.npmjs.com/package/mint-ui https://mint-ui.github.io/docs/#/en2/swipe 这里只用了swipe组件，所以并没有全部引用 import { Swipe, SwipeItem } from ‘mint-ui’; import Vue from ‘vue’ Vue.component(Swipe.name, Swipe); Vue.component(SwipeItem.name, SwipeItem); 在babel里面添加插件 .babelrc { &quot;plugins&quot;: [&quot;other-plugin&quot;, [&quot;component&quot;, [ { &quot;libraryName&quot;: &quot;mint-ui&quot;, &quot;style&quot;: true } ]]] } 项目里面swipe单独作为一个base组件，传入数组数据，用props接收。 Jquery插件库：http://www.jq22.com/jq1-jq3 雪碧图制作工具：http://alloyteam.github.io/gopng 腾讯http://fis.baidu,com 百度http://gruntjs.com]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ajax请求中断]]></title>
    <url>%2F2016%2F08%2F22%2Fajax%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[项目里面经常需要通过ajax发起请求向后台请求数据，有时候一个ajax请求成功发出了，很长时间没有响应，也没有报错。 虽然经常都是后台规定多长时间没有响应就报错，但是有遇到需要自己写的情况。 这个时候就需要主动中断ajax请求，研究jquery或js高程之后，查询到abort()方法，就是我把ajax发出去后，返回有一个jqXHR对象，就是整个发出去的请求。 我就可以用settimeout函数去对这个请求做操作，如果他的状态不是4 ,就调用abort()方法中断。代码如下:取消成功的话，error函数会被打印。 原理是：建立一个空数组，把发出去的ajax请求，依次push进这个空数组里面，然后需要全部中断的时候，for循环遍历这个数组，调用jquery的abort（）方法中断 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;jQuery中终止Ajax请求&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;script src=&quot;http://common.cnblogs.com/script/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; var arrayAJAX = new Array(); $(function(){ $(&quot;#btn&quot;).bind(&quot;click&quot;,function(){ for(var i=0;i&lt;100;i++){ starAJAX(i); } }); $(&quot;#bt2&quot;).bind(&quot;click&quot;,function(){ stopAJAX(); alert(&quot;终止AJAX请求&quot;); }); }) function stopAJAX() { for(var i=0;i&lt;arrayAJAX.length;i++) { arrayAJAX[i].abort(); } arrayAJAX = new Array(); } function starAJAX(i) { var options = { url: &apos;/Home/addallrecommandbook&apos;, data: &quot;html=&quot;+i, success: function (data, textStatus) { if (textStatus == &apos;success&apos;) { alert(&quot;添加成功！&quot;); } else { } }, error: function (x, msg, err) { } }; arrayAJAX.push($.ajax(options)); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;btn&quot;/&gt; &lt;input type=&quot;button&quot; id=&quot;bt2&quot; value=&quot;stopAjax&quot;/&gt; &lt;/body&gt; &lt;/html&gt; 连续发送两个请求，第二次发送的不执行问题问题原因:浏览器缓存造成的，请求的时候再添加一个随机数，发送的是一样的，但是可以欺骗浏览器。 应用场景: 1.登录模块验证码点击更换，是点击的时候向后台发一个请求，后台把新验证码返回，写的时候为了防止连续点击多次，发送请求返回一样的，就在请求后面添加了随机数 2 .用jsonp跨域的时候遇到过，开始用jq的jsonp方法，没有什么问题，后来做angular的单页面应用的时候，发现angular内部机制会在]]></content>
      <categories>
        <category>Javascript</category>
        <category>ajax</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闭包对事件处理程序的封装]]></title>
    <url>%2F2016%2F08%2F20%2F%E9%97%AD%E5%8C%85%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[看js高程的时候，闭包讲的并不多，研究了网上很多资料，但是实际用的时候还是不多的，一个是因为会携带其他的作用域，容易造成内存泄漏，一个是没有多少意识去用闭包，前面在性能优化总结的章节里面讲了一个闭包来保存兼容性判断结果的优化思想，这里详细的用代码阐述一下。 js高程里面的eventHandler方法，实际上并不完善，使用的时候，为了做兼容性处理，如果直接使用封装的函数，会导致每一次都要去判断。 普通事件处理程序封装函数：评价以下代码并给出改进意见 if(window.addEventListener){ var addListener = function(el,type,listener,useCapture){ el.addEventListener(type,listener,useCapture); }; } else if(document.all){ addListener = function(el,type,listener){ el.attachEvent(&quot;on&quot;+type,function(){ listener.apply(el); }); } } 来找一找问题： 1：应该用能力检测的方法，没有兼容dom0级事件，且这个函数会每次被调用时都判断浏览器兼容情况，应该用一个闭包函数来优化，一次调用，后面就不用再检测了。 2.addEventLister第三个参数用时间捕获方法不好，多数情况下还是应该用事件冒泡方法； 3.attachEvent事件中listener调用时，因为IE和chrome调用的方式不同，chrome调用时是将e作为参数传入进入的，el.onclcik = function (e) ;而IE是var func = el.onclcik; func()； 没有传递event参数，且执行时this指向window对象，所以listener执行的时候，无法直接获取event事件对象，也无法让直接调用this = el， 所以需要想办法将listener执行时获取window.event参数，且this指向el.onclick的el对象。 评价： 不应该在if和else语句中声明addListener函数，应该先声明；不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测；由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下改进如下： 1 function addEvent(elem, type, handler){ 2 if(elem.addEventListener){ 3 elem.addEventListener(type, handler, false); 4 }else if(elem.attachEvent){ 5 elem[&apos;temp&apos; + type + handler] = handler; 6 elem[type + handler] = function(){ 7 elem[&apos;temp&apos; + type + handler].apply(elem); 8 }; 9 elem.attachEvent(&apos;on&apos; + type, elem[type + handler]); 10 }else{ 11 elem[&apos;on&apos; + type] = handler; 12 } 13 } 闭包封装事件处理程序封装eventRegister.js：/** * 判断浏览器支持的注册事件的方式， 获取一个注册事件的函数 * 闭包封装事件处理程序 * 1.解决IE和普通浏览器的兼容性问题； 2.解决了每次调用方法都判断浏览器是否支持某方法的问题，利用闭包； 3.解决了IE方法调用时无法直接适用event事件对象和this指向window的问题 */ function createEventRegister(){ //如果浏览器支持的是addEventListener if(document.addEventListener){ //就返回一个函数，这个函数内部使用addEventListener来注册事件 return function(ele, type, eventHandler){ ele.addEventListener(type, eventHandler); } }else if(document.attachEvent){ return function(ele, type, eventHandler){ ele.attachEvent(&quot;on&quot; + type, function(){ //这里手动通过上下文调用模式调用这个eventHandler //将里面的this指向当前对象，并且将事件对象作为参数传给了eventHandler eventHandler.call(ele, window.event); }); //var func = div.onclick //func(); } }else{ return function(ele, type, eventHandler){ ele[&quot;on&quot; + type] = eventHandler; } } } 使用方法：&lt;div id=&quot;box&quot;&gt;&lt;/div&gt; // 引入 &lt;script src=&quot;eventRegister.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var div = document.getElementById(&quot;box&quot;); // 保存每次的结果 var eventRegister = createEventRegister(); // 在被监听的元素上使用 eventRegister(div, &quot;click&quot;, function(e){ // console.log(e); // this }) &lt;/script&gt; 解决绑定的封装，js高程写法删除事件：1.dom0级事件：div.onclick = null; 2.IE: var EventUtil = { addHandler: function(element,type,handler) { if (element.addEventListener) { element.addEventListener(type,handler,false); } else if (element.attachEvent) { element.attachEvent(&apos;on&apos;+type,handler); } else { element[&apos;on&apos;+type] = handler; } }, removeHandler: function(element,type,handler) { if (element.removeEventListener) { element.removeEventListener(type,handler,false); } else(element.detachEvent) { element.detachEvent(&apos;on&apos; +type,handler); } else { element[&apos;on&apos;+type] = null; } } }]]></content>
      <categories>
        <category>Javascript</category>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目里面用过的性能优化]]></title>
    <url>%2F2016%2F08%2F18%2F%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E7%94%A8%E8%BF%87%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[谈到性能优化，好像是一个很大的命题，其实只要代码写的久一些，总会去思考怎么写才可以让网页速度加载的更快，节约更少的带宽，这并不是在项目实现效果后才会去考虑的问题，要在一开始分析需求，组织结构的时候就有意识去用，去思考。 看过雅虎36条军规，但是很多还是没有实践过的，或者说有些是一开始写js的规则，觉得不值一提的，这里总结一下，开发时候用到过的。 一、尽量减少HTTP请求次数浏览器解析的时候，从上往下执行，页面中的图像，css、js等文件，都需要去外部下载。用gulp或webpack,将文件合并、压缩； 二、图片优化1.写css布局的时候，要给图片一个宽高，给标签一个class名，尽可能不用标签查找2.精灵图页面有很多小图片的时候，做成精灵图，通过控制background-image和background-position来显；缺点是维护起来麻烦，改一张要改整个图片，合并图片麻烦，要合理安排空间。 3.iconfont页面里面的icon比较小，又比较多的时候，用字体图标，制作网站：iconmon 4.base64格式图片图片个数比较少，不超过2kb，请求的频率又比较高，比如网站头部的logo图片，可以用base64,不会发送http请求。webpack-cli默认设置是不超过1kb的用base64.实际使用看业务情况，既考虑大小，也考虑请求的频率。base64制作方法： 1、html5的FileReader()方法里面的readAsDataURL转化， var imgFile = new FileReader(); imgFile.readAsDataURL(img.files[0]); 网址：http://blog.csdn.net/qq_30632003/article/details/61201093 2、canvas的 toDataURL(imgurl)方法也可以转 3、在线工具 5.svg画图标之前项目里面用svg画过两个圆形交叠的图标，去控制进度条显示，这个和canvas很类似，可以在以后项目里多做实践，也不用发送请求 6.移动端2x、3x图按需加载这个在移动端项目里面总结过用法，其实加载还有一个比较新的属性，srcset，只是兼容性不好。 三、懒加载、预加载技术针对页面大图片比较多的情况下，要保证高清效果，还要保证加载速度，不能造成假死，用lazyload插件或者是预加载技术，懒加载是先不给图片src设置真正的地址，等到页面滚动到图片的位置的时候，再给src赋值。 四、缓存思想遇到有用递归来获取的，先把前面的结果缓存起来，下一次递归的时候，先去取值。项目里几乎没用到递归，只是总结一下这个思想。 几种cache： 1. 浏览器缓存 浏览器缓存会将部分资源缓存在本地，当用户向服务器发送请求的时候，这部分资源会直接从本地读取，避免了网络传输数据内容过多，导致访问效率变差的问题！ 2. CDN Content delivery Network 提升网站打开速度！ 3. 硬件缓存 也是为了提升访问效的！ 4. 数据库缓存 硬盘型数据库： MySQL MSSQL ORACLE 内存型数据库： MongoDB Redis 内存型数据经常被用来做缓存，提升数据存取速度！ 补充：2017.5在vue项目里面，有一个很好的方法，keep-alive，可以在当前组件切换到其他组件的时候不销毁页面和数据，而是保存在缓存里面，下一次再调用。另外lazyload也可以使用在vue里面。 五、闭包的去保存事件处理程序的兼容性测试结果js文件写的时候，比如事件处理程序兼容性封装的时候，可以考虑利用闭包的方法，不用每次都去判断浏览器是否支持某种方法，用一个浏览器，检测一次，用变量保存。这个觉得可以专门写一篇分析一下。 六、减少页面的重绘在一个后台项目里面，用模板把请求回来的数据填入模块，渲染到页面上，再下一次，只是部分数据发生变化，有几种方案可以解决，把原来的数据替换，原数组更换，渲染，或者只是把这部分用html字符串拼接方法来改变局部。最后选了后者，虽然看起来麻烦一些，但是渲染的速度更快，减少了dom操作。 七、动态创建元素，添加到页面时候的优化在页面某一部分重新请求了数据，需要重新渲染,在页面添加节点和内容的时候，既可以用document.createElement(‘p’)的方法； 也可以使用innerHTML实行字符串拼接，对于比较多的dom元素创建，比如for循环一个arr数组，然后根据里面的每一项来创建Li标签，采用innerHTML方法效率会更高； 同时，因为字符串品拼接具有不可变性，，频繁拼接会造成内存的浪费，可以考虑优化的方法： 先把每一次循环的字符串push进一个[],然后循环结束，采用arr.join(“”),转成字符串输出 一个展示在线人员图像的示例： &lt;script&gt; var datas = [ // json对象，这是一种数据传输的格式 每个大括号就是一个对象 {&quot;name&quot;: &quot;tdxy01&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;}, {&quot;name&quot;: &quot;沉眠楚人&quot;, &quot;icon&quot;: &quot;images/avatar_11.jpg&quot;}, {&quot;name&quot;: &quot;爱上karina&quot;, &quot;icon&quot;: &quot;images/75_avatar_small.jpg&quot;}, {&quot;name&quot;: &quot;today&quot;, &quot;icon&quot;: &quot;images/avatar_02.jpg&quot;}, {&quot;name&quot;: &quot;hlg&quot;, &quot;icon&quot;: &quot;images/avatar_03.jpg&quot;} ] var arr = []; for (var i = 0; i &lt; datas.length; i++) { var str = &apos;&lt;li&gt;&apos; + &apos;&lt;p&gt;&apos; +datas[i].name+ &apos;&lt;/p&gt;&apos; + &apos;&lt;span&gt;&apos;+datas[i].icon+&apos;&lt;/span&gt;&apos; + &apos;&lt;li&gt;&apos;; arr.push(str); // 将li标签添加到数组里面 } var html = arr.join(&apos;&apos;); // 将数组中的元素连接成字符串 ul.innerHTML = html; &lt;/script&gt; 。。。。未完待续，想到就补充]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面样式设置的一些总结]]></title>
    <url>%2F2016%2F08%2F16%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[移动端的页面写了几个了，除了前面的1px，rem这些坑，还有一些要考虑的问题，在这里再开一个坑，记录下来，下次少踩一点。 扩展点击区域手机端的，header部分的back按钮，需要将其点击的区域扩大，方便点击，这个用过的方法主要有两种： 利用伪元素// 扩展点击区域 extend-click() position: relative &amp;:before content: &apos;&apos; position: absolute top: -10px left: -10 right: -10px bottom: -10px 在common/css/mixin.styl里面设置，需要的时候导入 back按钮使用精灵图的时候，利用css3的background-clip和background-origin属性// back按钮，a标签设置的，利用精灵图 header a.back { left: 0px; top: 1px; background-position: -20px 0; padding: 12px 10px; // 扩展的点击区域 box-sizing: content-box; // 默认的盒子模型 background-origin: content-box; // 设置背景图片的起始位置 background-clip: content-box; // 切割，只保留content内容 } 文本超出不显示，显示省略号为文字的父元素设置，且父元素不能设置width:100% div.test { white-space: nowrap; text-overflow:ellipsis; overflow: hidden; } chorme浏览器默认的字体大小是12px，如果要设置为10px的话，会失效，需要设置-webkit-text-size-adjust: none 点击高亮问题处理ios设备上，点击按钮的是时候，屏幕会闪动一下，这是因为移动端，有事件监听的元素被点击的时候会被高亮显示，而-webkit-tap-highlight-color属性会在当用户点击iOS的Safari浏览器中的链接或JavaScript的可点击的元素时，覆盖显示的高亮颜色 -webkit-tap-highlight-color:rgba(0,0,0,0) //webkit是苹果浏览器引擎，tap点击，highlight背景高亮，color颜色，颜色用数值调节。]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“线上测试工具ngrok的使用教程]]></title>
    <url>%2F2016%2F07%2F18%2F%E2%80%9C%E7%BA%BF%E4%B8%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7ngrok%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[之前本地的移动端项目，一直都用将内网ip地址用草料二维码，再用手机扫描做测试，但是只能在内网或同一个wifi环境下使用，无法在外网做线上测试，没有测试服务器的情况下，很麻烦。 还好发现了一个工具，可以把本地的服务映射到线上做测试。 这里把使用教程记录一下。 从最早使用到现在，经历了几次变化了，经常用着用着发现换多少端口，域名都用不了。 下载地址： http://ittun.com/ web interface的启用办法修改配置文件：config.yml 其中subdomain对应着启动文件里面的二级域名，自己自定义 缓存的清除方法 使用的二级域名后面加 /cache 修改startup.bat文件 @echo on cd %cd% #ngrok -proto=tcp 22 #ngrok start web ngrok -subdomain sellapp 8080 //去掉注释，启用 #ngrok 80 // 注释掉 注意：其中sellapp是二级域名，8080是访问端口，比如通过node,listen监听发送的请求，127.0.0.1，端口号是8080，就写8080 双击启动startup.bat文件 online则成功 访问线上地址 http://sellapp.ittun.com/index.html则可以访问到当前的页面]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端dpr不同时，2x图，3x图的处理方法]]></title>
    <url>%2F2016%2F06%2F16%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFdpr%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C2x%E5%9B%BE%EF%BC%8C3x%E5%9B%BE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前面总结了移动端页面怎么利用rem实现不同屏幕的适配，解决了尺寸一样，随页面缩放时发生变形的问题。 但是因为不同手机的屏幕分辨率不同，尤其是受高清屏的影响，有了设备的物理像素和设备的独立像素（css中的px像素）的区别，同样的页面，独立像素是640 1280，但是物理像素是320 640，写页面的时候，就需要按照 比例为2， 即 640 * 1280来准备图片。 dpr(device pixel ratio).设备像素比window.devicePixelRatio = 物理像素 / 独立像素 浏览器默认的视口获取document.documentElement.clientWidth 首先需要对视口做设置，不允许用户随意缩放： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; // 让viewport宽度 = 设备的宽度 dpr 不同，造成图片再dpr比较大的情况下，被放大，图片失真，所以需要在切图的时候准备对应的2X图和3x图，普通屏幕下，加载高清图又浪费dpr &lt;= 2时，使用2x图 apr &gt;= 2时，使用3x图 比如ipone6是375的屏，切750的2x图，3x图切1125px尺寸下的图 在项目里面，两种写法都用过，没有区别： 1.在common的mixin公共样式里面，写 // 2x和3x图切换的样式，根据media-query来判断 bg-image($url) background-image: url($url + &quot;@2x.png&quot;) @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3) background-image: url($url + &quot;@3x.png&quot;) // $url是前缀，用的时候，先@import引入公共样式，然后 img { bg-image(&apos;beijing&apos;) } 2.也是在公共样式mixin里面写，这个时候根元素里面也需要设置了data-dpr img-dpr(){ background-image: url(image.jpg);//默认 [data-dpr=&quot;2&quot;] &amp; { background-image: url(image@2x.jpg);//两倍高清 } [data-dpr=&quot;3&quot;] &amp; { background-image: url(image@3x.jpg);//三倍高清 } } 先引入mixin样式 .content{ img-dpr(); } 雪碧图使用rem造成像素偏差的问题解决办法：1.先放大100倍，提高图片精度，找到图片位置，再缩小100倍 .icon-fix { background: none; position: relative; overflow: hidden; } .icon-fix:after { content: &apos;&apos;; display: block; width: 10000%; height: 10000%; position: absolute; left: 0; top: 0; background-image: url(sprite.png); background-repeat: no-repeat; background-size: 140rem; -webkit-transform-origin: 0 0; -webkit-transform: scale(.01); transform-origin: 0 0; transform: scale(.01); } .icon3:after { background-position: 0 -280rem; }]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端高清、多屏幕适配方案总结-rem]]></title>
    <url>%2F2016%2F06%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%AB%98%E6%B8%85%E3%80%81%E5%A4%9A%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-rem%2F</url>
    <content type="text"><![CDATA[这篇文章，算是对学习rem及用在手机端项目里面的一个汇总。 rem是什么？在开发移动端h5页面的时候，一套设计图，需要适配不同尺寸的手机，手机的分辨率也不同。所以不能把单位写死为xxpx。 这里对rem、px、em做一个区分： px是绝对字体大小，但是页面缩放的时候因为字体不变，网页还是那么大，会变形。 em计算方式是乘以当前对象从父级遗传的字体大小，参考对象是一个变化的值 父级： height: 1em; // 16px,如果html的font-size是100% 子元素： font-size: 0.625em // 16 * 0.625 = 10px height: 1em // 实际上是10px rem是rem是基于根节点html的字体大小进行计算，浏览器一般默认字体是16px,1em = 16px;但是是css3的新属性，不支持ie678，兼容性处理，再写px或者100% 1.5rem = 根节点默认字体大小 * 1.5 = 24px; // 转化的时候，可以用 28px = 28/16 = 1.75rem 可以把根节点设置为10px或62.5%（100%是16px），方便以10计算而不是16，为了兼容IE7和ie8,默认字体可以设置为： html { font-size: 62.5%; } 利用rem实现多屏幕适配的思路相同的rem,只需要更改页面根元素html的font-size,把和元素尺寸有关的css，如width,height,line-height,margin,padding等都以rem作为单位,这样页面在不同设备下就能保持一致的网页布局，也解决了1px的问题。 怎么判断屏幕的尺寸（宽度），去动态的调整html的font-size？方法一、css media query@media screen and (max-width: 320px) { html{ font-size: 14px; } } @media screen and (min-width: 321px) and (max-width: 413px) { html{ font-size: 16px; } } @media screen and (min-width: 414px) and (max-width: 639px) { html{ font-size: 17px; } } @media screen and (min-width: 640px) { html{ font-size: 18px; } } 方法二、通过js来判断页面宽度，动态调整html的font-size 方法三、引入淘宝的lib-flexible地址：https://github.com/amfe/lib-flexible使用文档说明：http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html1.把flexible.js和flexible_css.js引入，放在head标签的utf-8meta标签下面此时不用再写 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; 2.此时,F12,会发现ip6下面，html的font-size会自动被设置为font-size: 75px（设计稿的尺寸是750），也会给html元素上增加一个data-dpr属性，js会根据不同的设备添加不同的data-dpr值，比如ip6是2. 3写css样式的时候，其他样式尺寸设置为rem，根据标注稿尺寸 / 标注稿基准字体大小来转换 1）实现定义了一个变量来保存基准字体大小 @font-size-base: 75; 2）某一个元素的尺寸设置方式： .item { width: 350rem/@font-size-base; // 350 / 70 = 5rem height: 80rem/@font-size-base; } 标注稿基准字体大小 = 标注稿宽度 / 10，如标注稿宽为750，标注稿基准字体大小为75；标注稿宽为640，标注稿基准字体大小为64；（所以淘宝这个方案是可以在任意设计稿尺寸下使用的） 4.如果还需要设置某一个元素的字体大小，可以根据html的data-dpr属性来处理，写法如下： [data-dpr=&quot;2&quot;] p { font-size: 16px; } [data-dpr=&quot;3&quot;] p { font-size: 24px; } dpr(device pixel ratio).设备像素比；i5,6 = 2;i6plus=3; 使用rem时候的问题，最多的问题就是 小数像素造成background-image 的问题，经常会因为小数像素导致背景图被裁掉一部分。所以可以的话，尽量使用iconfont,或者尽量给背景图设置一定的空白间隙]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对模块化的理解]]></title>
    <url>%2F2016%2F06%2F05%2F%E5%AF%B9%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么使用模块化最早的时候，模块化，我理解就是进行代码的封装，提供接口，便于代码的复用，使页面结构清晰，便于维护。用函数对同样功能的代码进行封装 比如两个功能fn1,fn2 function fn1(){} function fn2(){} 这样用的时候直接调用，但是这样写，都是全局变量，造成全局污染，容易起冲突，模块之间也没办法直观的看到哪一个依赖哪一个。 所以进一步封装，就用一个字面量的对象，把想要封装的属性和方法放在这个对象里面，使用的时候调用这个对象的属性和方法。 - varobj = { - age : 0, - func1 : function (){ - //... - }, - func2 : function (){ - //... - } - }; 但是别人使用的时候，是可以修改你这个对象里面的属性和方法的，所以为了保证只暴露接口给别人使用，但是里面的内容不能被访问，就有了沙箱模式，一个自执行函数 模块是独立的，如果需要引入全局变量，就作为参数传进来，在里面把对象挂在window上面，对外暴露。如果不用require.js加载的时候，一般都是这么写模块的。 - (function(window, undefined ) { - …… window.Jquery = $ - })(window ); 但是这个是在比较简单的页面里面，业务逻辑不是很多的时候，比较多的时候，就要考虑用模块化的库来开发了。一般都是用require.js，使用AMD规范。 因为你的js代码比较多的时候，你一排加载下来，他们加载的时间可能不一样，导致网页等待时间会比较长。而且这些js之间有依赖关系，就必须考虑，依赖性比较强的放在后面，怎么保证加载顺序，是比较困难的，也不方便维护。 require.js就是解决这个问题的： 1.能实现js文件的异步加载，避免网页失去响应； 2.管理模块之间的依赖性，便于编写和维护。使用的时候，先写一个入口文件，里面定义一个data-main属性，加载main.js文件，加载的时候就会先加载这个main.js主文件。 main.js文件里面，用require([],callback)来加载它需要依赖的模块。第一个参数是一个数组，需要加载的模块，第二个参数是callback，前面加载完毕才执行，所以说require.js是前置依赖加载的。 模块用AMD来写,define([],callback)，先写依赖模块，再写要执行的回调。 &lt;script src=&quot;reuqire.js&quot; defer async=&quot;true&quot;&gt;&lt;/script&gt; // async表示这个文件需要异步加载，ie不支持，IE支持defer. // 2. &lt;script sec=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; // main.js是主模块，是整个网页的入口代码，会最先被加载 // 3.主模块又依赖其他的模块 // main.js的写法 require([&apos;module1&apos;, &apos;module2&apos;, &apos;module3&apos;], function(module1, module2, module3) { // todo }) // 4.require.config({})用于配置，自定义模块的加载路径等 require可以这样直接加载，是因为他是一个全局变量； node.js里面，用common.js规范来加载的时候，直接写require(“模块”),就可以在后面执行业务逻辑了，因为这些js文件都存在硬盘里面的，所以服务器读取的时候很快。 但是到浏览器里面需要先请求，所以不能保证加载时间，就需要用回调，先加载，再执行。 弊端 require.js的弊端是多个js文件，增加了http的请求次数，但是模块部署完毕的时候，可以使用工具合并，减少http请求 没有用过CMD来写，但是怎么用的看过，是按需加载的，需要用到哪个模块，就用require来加载，但是依赖关系还是不好处理。所以基本上不考虑。 AMD模块的写法：采用define()函数来定义 // add.js文件 define([], function(){ var add = function(x,y) { return x + y; } return { add: add; } }) // 使用的时候 require([‘add’], function(add){ alert(add.add) }) 如果加载非规范的AMD模块，即不是用define()来写的，还需要用require.config({})来配置 shim: { &apos;jquery.scroll&apos;: { deps: [&apos;jquery&apos;], exports: &apos;jquery.fn.scroll&apos; } }]]></content>
      <categories>
        <category>Javascript</category>
        <category>requireJs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jsonp跨域相关]]></title>
    <url>%2F2016%2F05%2F25%2Fjsonp%E8%B7%A8%E5%9F%9F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[同源和跨域 同源是指域名、端口、协议（http\https\ftp）都一样，有一个不一样就是跨域，二级域名不一样的不算跨域。同源是为了保证信息安全，保护隐私信息，防止恶意纂改用户数据，比如用一个网址链接来获取用户的账户密码。 跨域：需要获取到其他的网站的公共数据，比如我们可能做得网页上希望得到豆瓣的电影，还有希望自己的网页上显示天气信息等。 跨域前端怎么解决jsonp方法jsonp的原理 首先发送的并不是一个ajax请求， 具体实现： 利用的是动态的创建一个script标签，因为script标签没有跨域限制； 把scrpit的src指向我们请求的地址，通过在src的url的参数里面附加callback=a, 然后服务器解析到callbak，返回的数据里面，用a去包裹一段数据，即数据作为a方法的参数：比如请求参数有callback=a,服务器根据callback获取到a,在响应里面返回字符串’a( {name: ‘xioamign’} )’; 客户端和服务器的数据交换格式是字符串形式的，浏览器收到服务器返回的a字符串，会自动对其进行eval（’ a({name: ‘xioaming’ })’) 解析，eval解析之后就会自动执行a()函数了，那么就获取到返回的数据了。 发送之前要先在window上面注册a方法：function a(data) {} 如果发送post请求，会报http状态码，报415错误，格式不正确 原理图： jquery的jsonp方法用法：$.ajax({ type: &apos;get&apos;, url: &apos;http://api.map.baidu.com/telematics/v3/weather&apos;, data: { ak: &apos;asdfhgf&apos; // 引用第三方api时，对方提供的密钥 location: &apos;深圳&apos; // 接口文档要求传递的参数 output: &apos;json&apos; }, dataType: &apos;jsonp&apos;, // 必须写jsonp才可以实现跨域 success: function(data) { console.log(data) { var pageResult = template(&apos;temp&apos;, data.result[0]); $(&apos;tbody&apos;).html(pageResult); } } }) 缺点：1.只支持get； 2.登陆注册时需要给后台传一堆数据，用参数的形式拼接在url后main的话太繁琐； 2.在登录模块中需要用到session来判断当前用户的登录状态,这时候由于是跨域的原因,前后台的取到的session是不一样的,那么就不 能就行session来判断. 3.由于jsonp存在安全性问题 jsonp的原理，js标签方法跨域function doSomething(data) { // 对data处理 } var script = document.createElement(&quot;script&quot;); script.src = &apos;http://www.b.com/b.html?callback=doSomething&apos;; document.body.appendChild(script); // 添加script标签后会向服务器发送请求； // 服务器会根据callback这个参数生成一个包含数据的函数 dosomething({&apos;a&apos;, &apos;1&apos;}); 例如： 在后台会对接收到请求的参数，并对参数做输出返回，callback.&apos;(&apos;.data.&apos;)&apos;; // 页面已经生成了dosomething函数，直接调用执行，就可以获取数据。 CORS(跨资源共享) 定义了跨资源时浏览器和服务器之间如何通信，自定义http头部允许浏览器和服务器相互交流，是否可以响应成功 传送信息量比较大或者时移动端比较适合，不存在兼容性问题 1、jsonp只能实现get请求，cors能支持所有类型的HTTP请求； 2、大多数现代浏览器都已经支持了cors；但是jsonp的兼容性好。 3、用法： 和不跨域的ajax写法一样，只是需要在服务器设置响应头：header(Access-Control-Allow-Origin: *); 也可以设置指定的域名： header(&apos;Access-Control-Allow-Origin:http://www.b.com&apos;); js部分： $.ajax({ url: a_cross_domain_url, crossDomain: true, method: &apos;POST&apos; }) document.domain+iframe(子域跨域) 这种方式适用于主域名相同，子域名不同，比如 http://www.a.com和http://b.a.com假如这两个域名下各有a.html和b.html // a.html里面设置 a.html document.domain = &apos;a.html&apos;; var iframe = document.createElement(&apos;iframe&apos;); iframe.src = &apos;http://b.a.com/b.html&apos;; document.body.appendChild(iframe); iframe.onload = function(){ var doc = iframe.contentDocument || iframe.contentWindow; // 相当于window/document doc.getElementById(id); // 用这个来寻找页面的元素 } // b.html里面设置 document.domain = &apos;a.com&apos;; 具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = &apos;a.com&apos;； 然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况。 HTML5的postMessage 假设在a.html里嵌套个,在这两个页面里互相通信 a.html window.onload = function() { window.addEventListener(&quot;message&quot;, function(e) { alert(e.data); }); window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.b.com/b.html&quot;); } b.html window.onload = function() { window.addEventListener(&quot;message&quot;, function(e) { alert(e.data); }); window.parent.postMessage(&quot;a data&quot;, &quot;http://www.a.com/a.html&quot;); } 这样打开a页面就先弹出 a data,再弹出 b data window.name + iframe window.name的原理是利用同一个窗口在不同的页面共用一个window.name，这个需要在a.com下建立一个代理文件c.html,使同源后a.html能获取c.html的window.name // a.html var iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;http://www.b.com/b.html&quot;; document.body.appendChild(iframe); // 现在a.html里建一个引用b.html的iframe，获得b的数据 var flag = true; iframe.onload = function() { if (flag) { iframe.src = &quot;c.html&quot;; // 判断是第一次载入的话，设置代理c.html使和a.html在同目录同源，这样才能在下面的else取到data flag = false; } else { // 第二次载入由于a和c同源，a可以直接获取c的window.name alert(iframe.contentWindow.name); iframe.contentWindow.close(); document.body.removeChild(iframe); iframe.src = &apos;&apos;; iframe = null; } } // b.html window.name = &quot;这是 b 页面的数据&quot;; window.location.hash + iframeb.html将数据以hash值的方式附加到c.html的url上，在c.html页面通过location.hash获取数据后传到a.html(这个例子是传到a.html的hash上，当然也可以传到其他地方) a.html var iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;http://www.b.com/b.html&quot;; document.body.appendChild(iframe); // 在a页面引用b function check() { // 设置个定时器不断监控hash的变化，hash一变说明数据传过来了 var hashs = window.location.hash; if (hashs) { clearInterval(time); alert(hashs.substring(1)); } } var time = setInterval(check, 30); b.html window.onload = function() { var data = &quot;this is b&apos;s data&quot;; var iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;http://www.a.com/c.html#&quot; + data; document.body.appendChild(iframe); // 将数据附加在c.html的hash上 } c.html // 获取自身的hash再传到a.html的hash里，数据传输完毕parent.parent.location.hash = self.location.hash.substring(1); h5的postMessageotherWindow.postMessage(message, targetOrigin); otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。 message: 所要发送的数据，string类型。 targetOrigin: 用于限制otherWindow，“*”表示不作限制 a.com/index.html中的代码： &lt;iframe id=&quot;ifr&quot; src=&quot;&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() { var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &apos;http://b.com&apos;; // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样 // 若写成&apos;http://c.com&apos;就不会执行postMessage了 ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin); }; &lt;/script&gt; b.com/index.html中的代码： &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;message&apos;, function(event){ // 通过origin属性判断消息来源地址 if (event.origin == &apos;http://a.com&apos;) { alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 } }, false); &lt;/script&gt; 后端代理解决跨域1、服务器的反向代理 需要对服务器做配置，前台发起跨域请求时，不写要请求的域名，还是写当前的，但是为了放便后台识别，可以在当前域名后面设置标示符，向服务器发起请求。因为在服务器端不会有跨域问题，服务器可以模拟http请求去访问其他域，再把返回的结果返回给前台。 之前有一个项目接口大量跨域的时候用的是反向代理来请求，文档，js文件都可以实现跨域。 2、nginx反向代理，在客户端和跨域请求的服务器直接搭建代理服务器，做处理，以同源的域名去访问需要跨域的资源 其实可以用nginx做web服务器，将请求转发，就没有跨域的问题了。 jsonp安全性防范分为以下几点： 1、防止callback参数意外截断js代码，特殊字符单引号双引号，换行符均存在风险 2、防止callback参数恶意添加标签（如script），造成XSS漏洞 3、防止跨域请求滥用，阻止非法站点恶意调用 针对第三点，我们可以通过来源refer白名单匹配，以及cookieToken机制来限制 而前两点，传统的做法分为以下几种： 1、纯手工过滤特殊字符，引号尖括号等，一旦发现潜在恶意字符则服务端拒绝，返回错误。此种方式较为严格，但是随之而来的问题是失败率会有所提升，尤其对于对外开发者。而且JS中恶意字符的变形十分多，此方式需要枚举所有非法字符，可能存在疏漏。我们不应该将潜在的恶意字符都一概屏蔽，因为确实有些需求需要传入并存储这些字符。 2、对于callback参数作严整的格式检查，或强制约定指定格式。基本可以彻底解决安全问题，但同样是对调用端不是完全透明，使用者需要额外去知晓相关限制和约定，可能会造成不必要的沟通成本。 3、返回包体添加header头部，强制指定MIME类型，避免按HTML方式解析，防止XSS漏洞。这似乎是个很完美的解决方案。但是十分诡异的是，在某些版本的火狐浏览器下，直接访问MIME类型为JavaScript的请求时，浏览器仍然会按照HTML解析。或许是该浏览器设计的缺陷，但它忽略了我们设置的header。无法保证所有浏览器严格按照MIME类型解析。 我们的关注点一直在于如何限制用户输入，但是请从另外一个层面去考虑该问题，或许就会豁然开朗。 我们先了解一下JS本身的特性。JSONP的本质是构造全局回调函数，之后加载script标签触发回调函数。通常我们使用函数可以这么写 [javascript] view plain copy print? 1. function test(){}test(); 而在全局的函数也就默认是window的成员。也可以显示书写为[javascript] view plain copy print? 1. window.test = function(){};window.test(); 而JS中对象的成员是可以使用字符串索引的方式访问的，故进一步改造为 [javascript] view plain copy print? 1. window[&apos;test&apos;]=function(){};window[&apos;test&apos;](); 现在有注意到么，如此一来我们已经把函数名已经完全限制在了字符串上下文，理论上只要做好了防注入工作，callback参数是不可能跳出字符串上下文意外执行代码的。以PHP为例，单字符串防止注入甚至可以直接使用json_encode该字符串实现. 1. window[&apos;alert(&quot;123&quot;);abc&apos;](); 上面的callback参数虽然有注入的风险，可以由于callback参数严格限制在字符串内部，仅会作为文本，不会意外执行,但仍然存在xss漏洞问题看下面例子 1. window[&apos;&lt;script&gt;alert(123);&lt;/script&gt;&apos;](); 我们虽然已经保证了严格限制在引号内部，不会造成js注入，但是直接在浏览器中输入该jsonp请求仍会按照HTML解析，产生XSS漏洞，即便设置了header也很难防范。 在进一步，我们只需要保证浏览器内不会明文出现&lt;&gt;标签，那么问题便可彻底解决。基本思路是在服务端做一次urlencode。而在output输出decodeURIComponent(‘#####’)来规避显示尖括号。Urlencode过的字符串，只可能包含字母数字%，也顺便解决了注入的问题. 最终附上一段简短的代码。根本解决jsonp的安全问题 1. &lt;?php header(&apos;Content-type: text/javascript&apos;); //加上此句可以消除chrome的警告 $callback = urlencode($_GET[&apos;callback&apos;]); echo &quot;window[decodeURIComponent(&apos;{$callback}&apos;)]({ret:0,msg:’OK’});&quot; 请求1：http://www.test.com/a.PHP?callback=alert(123);abc 响应1：window[decodeURIComponent(&apos;alert(123)%3Babc&apos;)]({ret:0,msg:&apos;OK&apos;}); 请求2：http://www.test.com/a.php?callback=&lt;script&gt;alert(123);&lt;/script&gt; 响应2：window[decodeURIComponent(&apos;%3Cscript%3Ealert(123)%3B%3C%2Fscript%3E&apos;)]({ret:0,msg:&apos;OK&apos;});]]></content>
      <categories>
        <category>Javascript</category>
        <category>ajax</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jquery源码学习]]></title>
    <url>%2F2016%2F05%2F02%2Fjquery%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近在github上面看到有源码分析的，自己也来学习一波，随意记录一下。 jquery实例jquery对外暴露两个对象，$和jquery $()如果不传参，是jquery对象自身，如果传参，也是jquery对象 jquery实例对象，是一个伪数组，有一个length属性 jquery创建伪数组的原理 伪数组：非数组对象，有一个属性是length function $() { return new init(); } // 构造函数 function init() { // 给实例对象添加属性 this.length = 0; this[1] = &apos;abc&apos;; // 相当于一个个的用下标来添加 [].push.call(this, &apos;abc&apos;, &apos;nbd&apos;, &apos;sff&apos;) } console.log($().length) 静态成员和实例成员实例成员 供实例使用的属性和方法就叫实例成员 function Person(age) { // 实例成员 this.age = age; } Person.maxAge = 28; // 静态成员 // 实例成员 Person.prototype = { add: function() { } } // 实例不能使用静态成员 // 构造函数也不能使用实例方法 jquery的静态方法 比如$.ajax() jquery框架结构自执行函数,防止全局污染 (function(global, factory) { // global对应的是window // factory对应的就是第二个函数，对应的工厂函数 })(typeof window !== &apos;undefined&apos; ? window: this, function() { // jquery的主体代码 // 这是jquery暴露的工厂函数 var jQuery = function() { return new jQuery.fn.init(); } // 置换原型，给原型起一个简称，方便用户和自己使用 jQuery.fn = jQuery.prototype = { constructor: jQuery } // 定义构造函数，将构造函数添加到jQuery工厂函数的原型中 var init = jQuery.fn.init = function() { // 这是jquery内部隐藏的构造函数 } // 让构造函数的原型和工厂函数的原型指向一个 init.prototype = jQuery.fn // 暴露两个变量，指向工厂函数 window.jQuery = window.$ = jQuery; return jQuery; }) Math是单例模式只有一个对象，不可以用new()new出来多个对象 封装jquery mini选择器编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。 var query = function (selector) { var reg = /^(#)?(\.)?(\w+)$/img; var regResult = reg.exec(selector); var result = []; //如果是id选择器 if (regResult[1]) { if (regResult[3]) { if (typeof document.querySelector === &quot;function&quot;) { result.push(document.querySelector(regResult[3])); } else { result.push(document.getElementById(regResult[3])); } } } //如果是class选择器 else if (regResult[2]) { if (regResult[3]) { if (typeof document.getElementsByClassName === ‘ function‘) { var doms = document.getElementsByClassName(regResult[3]); if (doms) { result = converToArray(doms); } } //如果不支持getElementsByClassName函数 else { var allDoms = document.getElementsByTagName(&quot;*&quot;); for (var i = 0, len = allDoms.length; i &lt; len; i++) { if (allDoms[i].className.search(new RegExp(regResult[2])) &gt; -1) { result.push(allDoms[i]); } } } } } //如果是标签选择器 else if (regResult[3]) { var doms = document.getElementsByTagName(regResult[3].toLowerCase()); if (doms) { result = converToArray(doms); } } return result; } function converToArray(nodes) { var array = null; try { array = Array.prototype.slice.call(nodes, 0); //针对非IE浏览器 } catch (ex) { array = new Array(); for (var i = 0, len = nodes.length; i &lt; len; i++) { array.push(nodes[i]) } } return array; }]]></content>
      <categories>
        <category>Javascript</category>
        <category>jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zepto的animate动画scrollTop方法封装]]></title>
    <url>%2F2016%2F04%2F28%2Fzepto%E7%9A%84animate%E5%8A%A8%E7%94%BBscrollTop%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在移动web项目的开发中，遇到一个通过点击页面自动到相应的楼层处的需求 最初的想法就是使用html的target属性进行切换，但实际效果十分死板，显得毫无交互性。 该前端架构采用zepto这个轻库进行开发，它具有类似jQuery的语法，之后采用了animate({scrollTop:”100px”})这个函数进行页面的动画滚动，结果就是毫无效果。 通过查询zepto fx包的源码 transform = prefix + &apos;transform&apos; cssReset[transitionProperty = prefix + &apos;transition-property&apos;] = cssReset[transitionDuration = prefix + &apos;transition-duration&apos;] = cssReset[transitionDelay = prefix + &apos;transition-delay&apos;] = cssReset[transitionTiming = prefix + &apos;transition-timing-function&apos;] = cssReset[animationName = prefix + &apos;animation-name&apos;] = cssReset[animationDuration = prefix + &apos;animation-duration&apos;] = cssReset[animationDelay = prefix + &apos;animation-delay&apos;] = cssReset[animationTiming = prefix + &apos;animation-timing-function&apos;] = &apos;&apos; 发现zepto的animate()源码采用css3的方式进行，而scrollTop属性不在css3的动画属性中，所以没有生效。接下来的方法就是自己写一个滚动条上下滚动的方法。初步的代码如下： $.fn.scrollTo =function(options){ var defaults = { toT : 0, //滚动目标位置 durTime : 500, //过渡动画时间 delay : 30, //定时器时间 callback:null //回调函数 }; var opts = $.extend(defaults,options), timer = null, _this = this, curTop = _this.scrollTop(),//滚动条当前的位置 subTop = opts.toT - curTop, //滚动条目标位置和当前位置的差值 index = 0, dur = Math.round(opts.durTime / opts.delay), smoothScroll = function(t){ index++; var per = Math.round(subTop/dur); if(index &gt;= dur){ _this.scrollTop(t); window.clearInterval(timer); if(opts.callback &amp;&amp; typeof opts.callback == &apos;function&apos;){ opts.callback(); } return; }else{ _this.scrollTop(curTop + index*per); } }; timer = window.setInterval(function(){ smoothScroll(opts.toT); }, opts.delay); return _this; }; 采用原型函数的方式，制做一个scrollTo方，效果还不错调用方式是$(“body”).scrollTo({toT:500});距离、时间还有回调函数参数传递就行了]]></content>
      <categories>
        <category>zepto</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[github使用]]></title>
    <url>%2F2016%2F03%2F15%2Fgithub%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[git常用命令 github使用之将项目推送到远程仓库总结一下在本地创建好项目之后，把项目推送到github上的步骤： 1 在github创建一个远程仓库2 进入你需要需要创建的文件夹下面，比如，我一般都放置在D/git目录下，点击git bush,运行： $ git clone 仓库地址 可以看到git文件夹下面已经有了一个和远程仓库同名的仓库 3 将你已经完成的项目拷贝过去 4 git切换到当前目录 5.git log 查看日志 6.git status 查看当前状态可以看到未追踪的和已修改的文件 7.如果有.project这样的隐藏目录，不需要提交到github,创建一个ignore文件 $ touch .gitignore 8.把需要忽略的文件写进gitignore里面，如果是忽略文件夹，在后面加/，如$ echo .dir/ &gt;&gt; .gitignore,忽略所有的隐藏文件，.* &gt;&gt; $ echo .project &gt;&gt; .gitignore 9.git status 查看状态 10.把.gitignore自身也忽略不提交 $ echo .gitignore &gt;&gt; .gitignore 如果想操作.gitnore里面的文件，用vi .gitignore进入操作，完成后退出 12.添加到本地仓库 git add -A 13.提交到本地仓库 git commit -m &apos;描述信息&apos; 14 git log 查看日志 15.push到远程仓库,第一次Push加-u $ git push -u origin master 16.下一次需要修改增加项目的时候，先去远程仓库上拉取 $ git pull origin master 在hithub建立自己的网页分支 a 远程clone，把github分支克隆到自己电脑上 git clone url b 将要上传的文件copy到本地仓库目录下 提交自己的文件（把本地电脑文件交给git，准备让git提交） git status 查看状态 git add . 跟踪所有改动过的文件 被git管理 准备好提交 c git commit -m &quot;modift&quot; git pull git push d 打开分支右上角的setting，在options找到github Pages栏，把Source 选为master branch 点击保存，然后输入后的网址加上自己的文件名即可 (1) 点击setting (2) 进入settings后下拉 找到github Pages栏，把Source 选为master branch 点击保存 (3) OK 输入网址即可访问你自己网页了 https://bootstet.github.io/case/map/index.html]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端底部tab或按钮显示问题-css sticky footer]]></title>
    <url>%2F2016%2F03%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BA%95%E9%83%A8tab%E6%88%96%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98-css%20sticky%20footer%2F</url>
    <content type="text"><![CDATA[问题： 项目里面需要设置一个弹出框，下面有一个浮层，浮层上面，分别是内容区块和底部关闭按钮，要求关闭按钮总是固定在窗口底部。 但是实际遇到的问题是，页面内容不够长的时候，页脚块固定在视窗底部；页面内容足够长，需要滚动的时候，页脚块随着内容向下推送，而不是固定视窗底部，挡住了页面的文字。 解决方法：设置三个层，一个内容的包裹层，里面再有一个层，是内容；再有一个层是底部层 // wrapper层 &lt;div class=&quot;detail&quot;&gt; // 和关闭按钮并列的层 &lt;div class=&quot;detail-wrapper clearfix&quot;&gt; // 里面的主题内容层 &lt;div class=&quot;detail-main&quot;&gt;&lt;/div&gt; &lt;/div&gt; // 关闭按钮层 &lt;div class=&quot;detail-close&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; // 样式 .detail /*设置全屏效果，占满视窗*/ position: fixed z-index: 100 top: 0 left: 0 width: 100% height: 100% overflow: auto background-color: rgba(7, 17, 27, 0.8) // filter: blur(10px) // 内容的wrapper层也宽高也占满100%，占满屏幕 .detail-wrapper min-width: 100% height: 100% .detail-main margin-top: 64px padding-bottom: 64px (这个是关键，设置一个下padding，给底部留出空间) .detail-close // 和wrapper层一个层级，wrapper层占有100%的高度， 所以footer层永远在视口之外，需要下面用-margin-top调整至视口之内 position: relative width: 32px height: 32px margin: -64px auto 0 auto // 设置一个-margin,将自己放置在上面预留的-margin处 clear: both font-size: 32px]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E-Learning项目总结]]></title>
    <url>%2F2016%2F03%2F11%2FE-learning%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[加入这个公司这么久了,好像现在才真正的松了一口气.才入职,看项目源码,官网还是用table布局的时候，真的让我倒吸一口气，很想立刻离职的，因为那个时候意识到传统公司，业务重心不在你的工作内容上面的时候，做开发，尤其是前台开发是一件多么无奈的事。 当你面临甚至没有产品经理，没有ui妹子，有的只是大领导的一个指示，有的只是hr培训人员不断变化的要求，更甚至一份需求确认书小小的变动都需要大领导审批一周的时候，只能感到深深的心累。但是还是庆幸坚持下来了，完成了这三十多个页面的静态页面的编写，终于要迎来业务逻辑的处理了。 吐槽这么多，进入正题，用以记录一下这个历程。 requireJS组织js的加载因为页面比较多，所以考虑之后，和老大商量，用requieJS来加载js逻辑部分的代码，为了结构更清晰，在html文件夹下放各个页面的html文件，在js文件夹下面放对应的页面的js文件，这样也便于页面的维护。 在js和html文件夹下面都建立了common，里面放置公共的html部分，比如header和footer,因为这一次后台环境是杨哥用php来写的，所以用了php的include方法来把公共页面加载到需要的页面里面。 common.js里面，把一些工具函数做了抽取，比如首页和分页都用的轮播图，没有用之前的轮播图插件，因为此处轮播图插件就只有上一页，下一页，自动轮播这几个基本功能，代码相对并不多，所以这里重新写了一遍，也算是加深记忆。 兼容性方面处理这次的项目对兼容性要求不高，不要求必须适配IE8以下，所以后台就用了bootstrap来写，但是多浏览器还是需要兼容的。 禁止ctrl+滚轮，放置页面放大缩小为兼容火狐滚轮事件用”DOMMouseScroll” if (document.addEventListener) { document.addEventListener(&apos;DOMMouseScroll&apos;, scrollFunc, false); } //W3C window.onmousewheel = document.onmousewheel = scrollFunc;//IE/Opera/Chrome/Safari /** * 禁用ctrl+滚轮，防止页面放大缩小 * @param e */ var scrollFunc = function (e) { e = document.all ? window.event : arguments[0] ? arguments[0] : e; if (e.wheelDelta &amp;&amp; event.ctrlKey) {//IE/Opera/Chrome e.returnValue = false; } else if (e.detail) {//Firefox e.returnValue = false; } } 首页做成了单页应用为了不用每次整个页面去请求数据，采用了单页面开发的方法，借助第三方库PathJS https://github.com/mtrpcic/pathjshttp://git.oschina.net/yswang/PathJS看了源码，是listen页面的hashchange的变化，然后去加载对应的js模块 在main.js里面处理，点击当前页面的时候，获取当前的location.hash common.js页面多出用到s.ajax方法，将其封装到common.js里面 //ajax统一请求 excommon.requestService = function (url, types, param, callback, requstType) { var result = {}; $.ajax({ async: false, timeout : 10000, //超时时间设置，单位毫秒 url: preurl.BATHPATH + url, type: types || &apos;get&apos;, data: param, success: function (data) { result = data; isJumpToLogin(data); if (callback) { callback(data); } }, error: function (XMLHttpRequest, textStatus, errorThrown) { if (callback) { //callback({error: errorThrown}) } } }); return result; }; sideBar的菜单导航，一级菜单和二级菜单登陆模块处理用jquery.validate插件做正则校验； 用jquery.form处理表单提交事件 github地址 提交 ajaxSubmit 根据form表单的数据发送ajax请求，适用于不能直接提交，需要先阻止表单的默认行为，处理表单请求数据的情况，这种情况下表单提交的数据可能从form表单厘米那不能直接完全获取。+处理之后，需要点击submit，手动提交1234567891011$('form').on('submit', function () &#123; $(this).ajaxSubmit(&#123; url: url, type: 'post', data: &#123;newProperty: '额外添加的属性'&#125;, success: function (data) &#123; console.log(data); &#125; &#125;); return false;&#125;); 项目里面的代码示例： //不能点击时直接提交，需要先或者后操作事件，手动提交 function profileSubmit(data) { $(&quot;.settings form&quot;).on(&quot;submit&quot;, function(e) { e.preventDefault(); //阻止表单的默认提交行为 //发起ajax请求 $(this).ajaxSubmit({ data: { //关键是添加的请求数据 tc_id: data.result.tc_id, tc_hometown: $(&quot;#p&quot;).find(&quot;:selected&quot;).text() + &quot;|&quot; + $(&quot;#c&quot;).find(&quot;:selected&quot;).text() + &quot;|&quot; + $(&quot;#b&quot;).find(&quot;:selected&quot;).text(), tc_province: $(&apos;#p&apos;).val(), tc_city: $(&apos;#c&apos;).val(), tc_district: $(&apos;#d&apos;).val() }, success: function() { location.reload(); //页面刷新 } }); //为了兼容老版本ie return false; }) } ajaxForm 监听表单submit事件，并阻止默认的提交,如果提交按钮不是type=”button”或者是用a标签来写按钮，要先把a标签换成button 然后根据form表单的数据发送ajax请求 12345678$(this).ajaxForm(&#123; url: url, type: 'post', data: &#123;newProperty: '额外添加的属性'&#125;, success: function (data) &#123; console.log(data); &#125;&#125;); 项目里面的代码示例： 12345678910111213//监听表单提交事件，转为ajax请求，请求成功，那么跳转到首页 $("#login-form").ajaxForm(&#123; success: function(data) &#123; //data.result是一个对象，将其转成字符串来作为cookie的key对应的value的值 var cookieVal = JSON.stringify(data.result); // 设置一个在当前域名下，根目录下面皆可以共享的cookie $.cookie("userInfo", cookieVal, &#123;path: '/', &#125;); location.href = '/'; &#125;, error: function() &#123; alert('登录失败！'); &#125; &#125;); jquery-ajax全局事件 如果使用了jquery的ajax相关方法发送请求，那么jquery就会在document触发上触发几个jquery定义的事件。 事件种类 ajaxStart 在请求刚刚发送出去时，该事件被触发。 如果同时发送多个请求，只有第一个请求会触发该事件。 ajaxSend 在请求刚刚发送出去时，该事件被触发。 如果同时发送多个请求，每一个请求都会触发该事件。 ajaxSuccess 每有一个请求成功，或数据按照指定的方式解析成功，就会触发该事件。 ajaxError 每有一个请求失败，或数据解析失败，就会触发该事件。 ajaxStop 请求完成后触发该事件，不在乎请求是否成功。 如果同时发送多个请求，只有最后一个请求会触发该事件。 ajaxComplete 请求完成后触发该事件，不在乎请求是否成功。 如果同时发送多个请求，每一个请求都会触发该事件。应用场景 我们的页面可能同时发送多个ajax请求， 通常我们会在第一个请求发送后展示一张loading图片， 最后一个请求结束后隐藏loading图片， 那么对应的两个事件就是ajaxStart和ajaxStop。 在util.js里面设置123456789101112131415161718192021222324252627282930313233343536/** * Created by gibson on 2017/5/11. */define(['jquery', 'jquery_cookie', 'nprogress'], function($, ud, nprogress) &#123; return &#123; //封装一个检测登陆状态的方法，如果还没有登陆过，链接到该页面时是不成功的，默认跳转到登陆页面 //但是这个规则对登陆页面不起作用，所以封装的时候不能直接执行，需要给一个接口，调用才执行 checkLoginStatus: function() &#123; if(!$.cookie("PHPSESSID")) &#123; location.href = '/html/home/login.html'; &#125; &#125;, // 设置网站的进度条，应用了一个插件 nprogress: function() &#123; //显示加载完成的画面 nprogress.done(); &#125;, loading: function() &#123; $(document).on("ajaxStart", function() &#123; $(".overlay").show(); &#125;).on("ajaxStop", function() &#123; $(".overlay").hide(); &#125;); &#125;, getSearchVal: function(searchKey) &#123; var searchObj = &#123;&#125;; var unitArr = []; var searchArr = location.search.slice(1).split("&amp;"); for(var i = 0, len = searchArr.length; i &lt; len; i++) &#123; unitArr = searchArr[i].split("="); searchObj[unitArr[0]] = unitArr[1]; &#125; return searchKey ? searchObj[searchKey] : ""; &#125; &#125;&#125;) 使用的时候，发起ajax请求前，先加载loading事件//发起ajax时，加载Loading事件 util.loading(); 登陆模块处理逻辑监听登陆注册表单提交事件，发送ajax请求，如果成功，那么后台会返回一个sessionId,浏览器会自动设置cookie,将其存储，并在每次发送ajax请求的时候，将sessionId传到后台，作为身份的标识。 对帐号密码做MD5加密处理补充：查找资料的时候，还有其他几种加密方法： base64加密sha1加密 博客地址：http://www.haorooms.com/post/js_my_passwordjm 用cookie将返回的信息存储起来，进入其他页面的时候取出来进行判断，即可进行权限验证 //data.result是一个对象，将其转成字符串来作为cookie的key对应的value的值 var cookieVal = JSON.stringify(data.result); // 设置一个在当前域名下，根目录下面皆可以共享的cookie $.cookie(&quot;userInfo&quot;, cookieVal, {path: &apos;/&apos;, }); IE8兼容placeholder问题解决表单验证模块用validate方法 //表单检验 $(&quot;#LoginForm&quot;).validate({ rules : { username : { required : true }, password : { required : true } }, messages : { username : {required : &apos;请输入用户名&apos;}, password : {required : &apos;请输入密码&apos;} }, errorElement : &quot;p&quot;, submitHandler: function(){ var username = $.trim($(&quot;#username&quot;).val()); var password = $.trim($(&quot;#password&quot;).val()); var LoginDB = Login(username, password); // 发送AJAX请求 if(LoginDB.success){ history.go(0); //刷新当面页 }else { //var errorHTML = &apos;&lt;div class=&quot;error&quot;&gt;{{LoginDB.errorMessage}}&lt;/div&gt;&apos;; //$(&quot;#output&quot;).html(template.compile( errorHTML)({ // LoginDB: LoginDB //})); layer.alert(&quot;用户名或密码错误!&quot;) return false; } return false; } }); 退出模块的逻辑 点击退出按钮时发送ajax请求，后台删除sessionID,然后跳转到登陆页面 视频播放功能 其实可以利用html5的vedio标签，但是出于兼容性的考虑，而且因为不支持jq对vedio标签及方法的操作，需要用原生js来写，为了整个页面的统一性。最后使用了一款第三方插件audiojsaudiojs跨浏览器的HTML音频播放器（可自定义样式） 官网：https://kolber.github.io/audiojs/官方文档：https://kolber.github.io/audiojs/docs/ 使用方法：第一步引用文件： &lt;script src=&quot;/audiojs/audio.min.js&quot;&gt;&lt;/script&gt; 第二步，全局初始化： &lt;script&gt; audiojs.events.ready(function() { var as = audiojs.createAll(); }); &lt;/script&gt; 第三步，在需要的地方放上下面类似的代码： &lt;audio src=&quot;/mp3/juicy.mp3&quot; preload=&quot;auto&quot; /&gt; //注意是直接闭合标签 但是存在的问题是：只适用静态的页面，如果动态添加音频怎么办 https://stackoverflow.com/questions/17052060/retrieve-existing-object-into-variable/17052898#17052898 var as; audiojs.events.ready(function () { as = audiojs.createAll(); }); $(document).ready(function () { setTimeout(function () { var mp3 = &quot;http://s3.amazonaws.com/audiojs/02-juicy-r.mp3&quot;; // audio.js example // creating new audio element, yours is probably added via ajax // [0] used to get DOM element instead of jQuery object. var audio = $(&apos;&lt;audio/&gt;&apos;, {id: &apos;test&apos;}).appendTo(&apos;body&apos;).attr(&apos;src&apos;, mp3)[0]; var testAS = audiojs.create(audio); // initialise new audio.js player as.push(testAS); // add &quot;testAS&quot; object to &quot;as&quot; array of objects console.log(as); // log &quot;as&quot; - now holds the original objects + &quot;testAS&quot; }, 5000); // timeout used for testing, above code can be in ajax success function instead }); 控制HTML样式类名配置 createPlayer: { markup: &apos; &lt;div class=&quot;headset&quot;&gt;&lt;/div&gt; &lt;div class=&quot;playname&quot; id=&quot;playname&quot;&gt;&lt;/div&gt; &lt;div class=&quot;play-pause&quot;&gt; &lt;p class=&quot;play&quot;&gt;&lt;/p&gt; &lt;p class=&quot;pause&quot;&gt;&lt;/p&gt; &lt;p class=&quot;loading&quot;&gt;&lt;/p&gt; &lt;p class=&quot;error&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;scrubber&quot;&gt; &lt;div class=&quot;progress&quot;&gt;&lt;/div&gt; &lt;div class=&quot;loaded&quot;&gt;&lt;/div&gt;&lt;div class=&quot;words&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt; &lt;em class=&quot;played&quot;&gt;00:00&lt;/em&gt;/&lt;strong class=&quot;duration&quot;&gt;00:00&lt;/strong&gt; &lt;/div&gt; &lt;div class=&quot;volume&quot;&gt;&lt;/div&gt; &lt;div class=&quot;error-message&quot;&gt;&lt;/div&gt;&apos;, playPauseClass: &apos;play-pause&apos;, scrubberClass: &apos;scrubber&apos;, progressClass: &apos;progress&apos;, loaderClass: &apos;loaded&apos;, timeClass: &apos;time&apos;, durationClass: &apos;duration&apos;, playedClass: &apos;played&apos;, volumeClass: &apos;volume&apos;, closingClass: &apos;closing&apos;, errorMessageClass: &apos;error-message&apos;, playingClass: &apos;playing&apos;, loadingClass: &apos;loading&apos;, errorClass: &apos;error&apos; }, 分页实现的逻辑 判断当前是第几页，给上一页和下一页绑定自定义属性，和当前页码相关的，上一页是-1，下一页是+1 并给按钮设置样式，样式用三元表达式，如果上一页是0的时候，设置disabled,如果下一页大于总页数的时候，设置禁用。 根据接口，发ajax请求，请求的参数里面有页数，有需要返回的条数。将返回的数据用模板渲染上去 其中点击分页按钮的时候，因为按钮是模板动态生成的，所以需要用事件委托。 先判断按钮是否禁用，如果没有，获取点击下一页按钮是当前的页码，然后发送ajax请求 url传参的方式为了实现两个页面的交互，比如前一个页面的课程的id,在下一个页面需要获取，可以这样写 /** * 创建课程 * */ $(&apos;form&apos;).ajaxForm(function(data) { location.href = &apos;/html/course/course_add_step1.html?cs_id=&apos; + data.result.cs_id; }); 省市县三级联动插件使用一个需求是，人员信息，选择了省，需要出现可以选择的市县，使用的是region.json插件 region代码范例12345678910111213141516&lt;div id="region-container"&gt; &lt;select name="" id="p" data-id=""&gt; &lt;option value=""&gt;请选择省&lt;/option&gt; &lt;/select&gt; &lt;select name="" id="c" data-id=""&gt; &lt;option value=""&gt;请选择市&lt;/option&gt; &lt;/select&gt; &lt;select name="" id="d" data-id=""&gt; &lt;option value=""&gt;请选择县&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; $('#region-container').region(&#123; url: 'region/region.json' &#125;);&lt;/script&gt; 注意事项 3个select的ID属性，必须是p、c、d 每个select中必须要有一个默认提示性的option data-id属性可以设置默认选项，值为对应城市的编号 &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot; class=&quot;col-xs-3 control-label&quot;&gt;籍贯&lt;/label&gt; &lt;div id=&quot;tc-region&quot; class=&quot;col-xs-5&quot;&gt; &lt;select id=&quot;p&quot; data-id=&quot;{{ tc_province }}&quot; name=&quot;&quot; class=&quot;form-control input-sm&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择省&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;c&quot; data-id=&quot;{{ tc_city }}&quot; name=&quot;&quot; class=&quot;form-control input-sm&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择市&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;d&quot; data-id=&quot;{{ tc_district }}&quot; name=&quot;&quot; class=&quot;form-control input-sm&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择区县&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; /** * 初始化省市县三级联动 * */ function initPCD() { $(&apos;#tc-region&apos;).region({ url: &apos;/lib/jquery-region/region.json&apos; }); } 事件二级联动的解决select选择框，每一个课程的分类下面还有子分类，需要选择了第一级分类，就会自动显示第二级分类，返回的接口中只有父分类的id，需要父分类选择变更的时候，子分类也需要变更。显示在文本框，同步的。 整个最后监听顶级分类的的select的onchange事件，获取到顶级分类的id,然后发送ajax请求获取到子分类，然后动态字符串拼接一堆子分类的options标签，对原来的进行替换。 逻辑还是比较绕的。 点击两个按钮，共享一个模态框的事件处理当时有一个需求是需要对课程信息进行编辑，有两个按钮，添加和编辑，有两种方法可以做，第一种是模板可以写两个，分别发送ajax请求，编辑的时候先请求数据，再提交数据，添加的时候提交数据。 但是后来做完之后，发现代码冗余，想优化的办法： 给编辑按钮绑定自定义属性id，如果是编辑课程的话，会有课程的id属性，然后判断是编辑还是添加，编辑就进行数据回显，否则就渲染一个空页面]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js判断是手持设备还是移动设备]]></title>
    <url>%2F2016%2F03%2F07%2Fjs%E5%88%A4%E6%96%AD%E6%98%AF%E6%89%8B%E6%8C%81%E8%AE%BE%E5%A4%87%E8%BF%98%E6%98%AF%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[转载收集： Js判断客户端是否为PC还是手持移动设备方法一 1. function IsPC(){ 2. var userAgentInfo = navigator.userAgent; 3. var Agents = new Array(&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;); 4. var flag = true; 5. for (var v = 0; v &lt; Agents.length; v++) { 6. if (userAgentInfo.indexOf(Agents[v]) &gt; 0) { flag = false; break; } 7. } 8. return flag; 9. } 1. if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) { 2. //alert(navigator.userAgent); 3. window.location.href =&quot;iPhone.html&quot;; 4. } else if (/(Android)/i.test(navigator.userAgent)) { 5. //alert(navigator.userAgent); 6. window.location.href =&quot;Android.html&quot;; 7. } else { 8. window.location.href =&quot;pc.html&quot;; 9. }; 方法二 1. var browser={ 2. versions:function(){ 3. var u = navigator.userAgent, app = navigator.appVersion; 4. return {//移动终端浏览器版本信息 5. trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 6. presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 7. webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 8. gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核 9. mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 10. ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 11. android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或者uc浏览器 12. iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 , //是否为iPhone或者QQHD浏览器 13. iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad 14. webApp: u.indexOf(&apos;Safari&apos;) == -1, //是否web应该程序，没有头部与底部 15. weixin: u.indexOf(&apos;MicroMessenger&apos;) &gt; -1, //是否微信 16. qq: u.match(/\sQQ/i) == &quot; qq&quot; //是否QQ 17. }; 18. }(), 19. language:(navigator.browserLanguage || navigator.language).toLowerCase() 20. } 21. 22. if(browser.versions.mobile || browser.versions.ios || browser.versions.android || 23. browser.versions.iPhone || browser.versions.iPad){ 24. window.location = &quot;http://m.zhaizhainv.com&quot;; 25. } 方法三： 摘自im- qq 1. var os = function() { 2. var ua = navigator.userAgent, 3. isWindowsPhone = /(?:Windows Phone)/.test(ua), 4. isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone, 5. isAndroid = /(?:Android)/.test(ua), 6. isFireFox = /(?:Firefox)/.test(ua), 7. isChrome = /(?:Chrome|CriOS)/.test(ua), 8. isTablet = /(?:iPad|PlayBook)/.test(ua) || (isAndroid &amp;&amp; !/(?:Mobile)/.test(ua)) || (isFireFox &amp;&amp; /(?:Tablet)/.test(ua)), 9. isPhone = /(?:iPhone)/.test(ua) &amp;&amp; !isTablet, 10. isPc = !isPhone &amp;&amp; !isAndroid &amp;&amp; !isSymbian; 11. return { 12. isTablet: isTablet, 13. isPhone: isPhone, 14. isAndroid : isAndroid, 15. isPc : isPc 16. }; 17. }(); 使用方法 if(os.isAndroid || os.isPhone){ alert(&quot;-----&quot;); } 方法4 百度webapp版 1. &lt;!---识别手机或电脑的js开始---&gt; 2. &lt;script language=&quot;javascript&quot;&gt; 3. (function(){ 4. var res = GetRequest(); 5. var par = res[&apos;index&apos;]; 6. if(par!=&apos;gfan&apos;){ 7. var ua=navigator.userAgent.toLowerCase(); 8. var contains=function (a, b){ 9. if(a.indexOf(b)!=-1){return true;} 10. }; 11. //将下面的http://caibaojian.com改成你的wap手机版页面地址 如我的 http://caibaojian.com 12. var toMobileVertion = function(){ 13. window.location.href = &apos;http://caibaojian.com/&apos; 14. } 15. 16. if(contains(ua,&quot;ipad&quot;)||(contains(ua,&quot;rv:1.2.3.4&quot;))||(contains(ua,&quot;0.0.0.0&quot;))||(contains(ua,&quot;8.0.552.237&quot;))){return false} 17. if((contains(ua,&quot;android&quot;) &amp;&amp; contains(ua,&quot;mobile&quot;))||(contains(ua,&quot;android&quot;) &amp;&amp; contains(ua,&quot;mozilla&quot;)) ||(contains(ua,&quot;android&quot;) &amp;&amp; contains(ua,&quot;opera&quot;)) 18. ||contains(ua,&quot;ucweb7&quot;)||contains(ua,&quot;iphone&quot;)){toMobileVertion();} 19. } 20. })(); 21. function GetRequest() { 22. var url = location.search; //获取url中&quot;?&quot;符后的字串 23. var theRequest = new Object(); 24. if (url.indexOf(&quot;?&quot;) != -1) { 25. var str = url.substr(1); 26. strs = str.split(&quot;&amp;&quot;); 27. for(var i = 0; i &lt; strs.length; i ++) { 28. theRequest[strs[i].split(&quot;=&quot;)[0]]=unescape(strs[i].split(&quot;=&quot;)[1]); 29. } 30. } 31. return theRequest; 32. } 33. &lt;/script&gt; 34. &lt;!---识别手机或电脑的js结束---&gt;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手机端click事件时的点透问题]]></title>
    <url>%2F2016%2F03%2F05%2F%E6%89%8B%E6%9C%BA%E7%AB%AFclick%E4%BA%8B%E4%BB%B6%E6%97%B6%E7%9A%84%E7%82%B9%E9%80%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[移动端点透事件，其实网上已经大把这样的案例说明和解决方法，项目里面遇到过一次之后，就已经解决了。 点透事件的原理根据遇到的问题来分析，项目里是一个页面要做一个弹出层，弹出层后面有一个mask，点击mask的时候，弹出层隐藏，但是触发了主页面的input输入框的焦点。 原因就是移动端click有300ms的滞后性，要去判断你是不是缩放，还会不会双击。所以touchend的时候，先隐藏了弹出层和mask，后面真正的点击事件到来的时候，点击的是下面一层。 解决方法： 给这个事件添加阻止默认事件方法：e.preventDefault();但是每一次都要添加，很麻烦。封装了一个tap事件，利用touch事件的执行时机比click要早，通过事件的判断来进行逻辑处理tap.js如下： // 参数1 dom元素 参数2 回调函数 function tap(dom,callBack) { /* tap是轻敲 1. 手指 放上去 离开的速度 很快 2. 手指如果放上去之后 移动了 失效 3. 手指放上去 按了超过一定时间（长按） */ // 获取起始时间 var startTime; var isMove = false; // 标识符 dom.addEventListener(&apos;touchstart&apos;, function (event) { startTime = Date.now(); // 还原isMove的值 isMove = false; }) // 进入到这个事件中 说明 移动了 dom.addEventListener(&apos;touchmove&apos;, function (event) { // console.log(&apos;move&apos;); isMove = true; }) // 计算 停留的时间 dom.addEventListener(&apos;touchend&apos;, function (event) { var delayTime = Date.now() - startTime; // 如果移动了 也失效 if (isMove == true) { // console.log(&apos;移动了，失效&apos;); return; } // 判断停留时间，是否太久了 // 这里的时间 可以根据需求调整 if (delayTime &gt; 300) { // console.log(&apos;太久了，失效&apos;); return; } // 正常执行 // console.log(&apos;轻敲&apos;); callBack(); }) } 用FastClick原理：FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟click 事件，并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。 地址：https://github.com/ftlabs/fastclick/ 用法：1.引入js 2.绑定在document.body上 if (&apos;addEventListener&apos; in document) { document.addEventListener(&apos;DOMContentLoaded&apos;, function() { FastClick.attach(document.body); }, false); } $(function() { FastClick.attach(document.body); }); var attachFastClick = require(&apos;fastclick&apos;); attachFastClick(document.body); fastclick源码分析，转：https://segmentfault.com/a/1190000005850383（转）]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call和apply和bind的用法]]></title>
    <url>%2F2016%2F03%2F01%2Fcall%E5%92%8Capply%E5%92%8Cbind%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[call/在参数比较少的情况下使用 语法：函数名.call(obj, arg1, arg2…agrN); 用法： 1.调用函数名指向的这个函数； 2.在调用该函数的时候，call方法会将函数内部的this指向第一个参数中的obj 3.会将call方法中传入的第二个及以后所有的参数作为实参传递给正在调用的这个函数 function test(a, b){ console.log(a + b); console.log(this); } // test(1, 2); var obj = {name: &quot;谢世豪&quot;}; test.call(obj, 1, 2); apply方法（在参数不确定，且比较多的情况使用）// 求字符串每项的和 或不定参数求和 var str = &quot;1,2,3,3,4,5,12,3,123,12,3,123,12,31,23,1,3,1&quot;; // 思路：先将字符串每项转成数组 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;12&quot;, &quot;3&quot;, &quot;123&quot;, &quot;12&quot;, &quot;3&quot;, &quot;123&quot;, &quot;12&quot;, &quot;31&quot;, &quot;23&quot;, &quot;1&quot;, &quot;3&quot;, &quot;1&quot;] var strArr = str.split(&quot;,&quot;).map(Number); //map方法是将strArr数组的每一项都用Number方法转化，结果是一个每一项都是number类型的数组 function sum() { var sum = 0; //因为不确定传递的参数的个数，所以用arguments来接收实参 for(var i = 0; i &lt; arguments.length; i++) { sum += arguments[i]; } return sum; } //用apply方法来调用 var result = sum.apply({}, strArr); //如果用call来调用 sum.call({}, strArr[0], strArr[1], strArr[2]...);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[缓存优化递归性能问题]]></title>
    <url>%2F2016%2F02%2F05%2F%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E9%80%92%E5%BD%92%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 斐波那契函数的缓存优化：经典题目：如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成） 原方法： function fib(){ if (n == 1 || n == 2) { return 1; } return fib(n-1) + fib(n-2); } fib(44) // 存在的性能问题就是存在大量的重复运算，算过的下一次还算一次。 // 优化方法： var cache = []; function fib(n){ var num = cache[n]; //先去缓存数组里面找第n项 if (num) { return num; } else { if (n == 1 || n==2) { num = 1; } else { num = fib(n-1) + fib(n-2) } // 将num缓存起来 cache[n] = num; return num; } } 或者： var result = []; function fn(n) { //典型的斐波那契数列 if (n == 1) { return 1; } else if (n == 2) { return 1; } else { if (result[n]) { return result[n]; } else { //argument.callee()表示fn() result[n] = arguments.callee(n - 1) + arguments.callee(n - 2); return result[n]; } } }]]></content>
      <categories>
        <category>Javascript</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[递归实现dom数查找]]></title>
    <url>%2F2016%2F02%2F03%2F%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0dom%E6%95%B0%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[需求：给定id，根据id找到dom节点 &lt;script&gt; var data = { id: &apos;xxx&apos;, name: &apos;xxx&apos;, children: [node, node, node] } var id = &apos;xxx&apos;; var node = getNodeById(data, id); console.log(node); var body = document.body; var list = []; function getChildren(ele){ //获取所有的子元素 var children = ele.children; //遍历所有的子元素 for (var i = 0; i &lt; children.length; i++) { var child = children[i]; //将子元素存入数组 list.push(child); //遍历子元素，再调用当前的方法 var temp = getChildren(child); list = list.concat(temp); } return list; } function getNodeById(ele, id) { //遍历List元素 var list = getChildren(ele); for (var i = 0; i &lt; list.length; i++) { if (list[i].id === id) { return list[i]; } } } var node = getNodeById(data, id); &lt;/script&gt; 另外一个类似的： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是div的内容 &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt;这是div的内容 &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt;这是div的内容 &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;这是P标签的内容 &lt;span id=&quot;qiuid&quot;&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;这是P标签的内容 &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;span&gt;这是span的内容&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; //用递归获取所有的后代元素 var body = document.body; function getChildren(ele) { var eleChildren = ele.children; //第一次值是3个div var list = []; //用来接收后代元素 for (var i = 0; i &lt; eleChildren.length; i++) { var child = eleChildren[i]; //第一次遍历是第一个div list.push(child); //将第一个div存入数组 var temp = getChildren(child); //调用递归，获取第一个div下面的p标签 list = list.concat(temp); } return list; } // var result = getChildren(body); // console.log(result); //获取后代子元素的id值 function getById(ele, id) { //遍历list元素 var list = getChildren(ele); for (var i = 0; i &lt; list.length; i++) { if (list[i].id === id) { return list[i]; } } } var result = getById(body, &quot;qiuid&quot;); console.log(result); //相当于 // function getChildren(第一个div) { // var eleChildren = ele.children; //第一次值是3个p // var list = []; //用来接收后代元素 // for (var i = 0; i &lt; eleChildren.length; i++) { // var child = eleChildren[i]; //第一次遍历是第一个p // list.push(child); //将第一个p存入数组 // //调用递归，获取第一个div下面的p标签 // getChildren(child); // } // } //相当于 // function getChildren(第一个div下面的第一个P) { // var eleChildren = ele.children; //第一次值是3个span // var list = []; //用来接收后代元素 // for (var i = 0; i &lt; eleChildren.length; i++) { // var child = eleChildren[i]; //第一次遍历是第一个span // list.push(child); //将第一个span存入数组 // //调用递归，获取第一个div下面的标签 // getChildren(child); //没有的，无法进入循环执行 // } // } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jquery源码缓存封装及模仿封装缓存方法，递归]]></title>
    <url>%2F2016%2F02%2F01%2Fjquery%E6%BA%90%E7%A0%81%E7%BC%93%E5%AD%98%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[jquery源码里面的缓存function createCache() { var keys = {}; function cache(key, value) { if(keys.push(key + &quot;&quot;) &gt; 20) { delete cache([kyes.shift()]); } return (cache[key + &quot;&quot;] = value); } return cache; } // 只提供存值的方法，取值的话，用var cache = creteCache(&apos;xc&apos;, {}); cache.xc cache是一个对象 jquery里面的缓存原理分析 jquery里面有dom元素缓存，有事件缓存，有对象缓存，查询过一次的，会缓存起来下次调用，缓存方法的原理： function createCache(){ var cache = {}; //cache对象来存放数据 var keys = []; //keys数组来存放所有的数据的键，方便做数量限制 return function(key, value) { // 判断用户有没有传值进来，是不是设置 if (value) { cache[key] = value; // 判断数组里面是不是已经有了一个同名的Key,防止同样的key在数组存在多次，而对象里只有一个的问题，这个时候把数组里面又得给删除 var index = keys.indexOf(key); if(index != -1) { // 这个key已经存在了，删除掉 keys.splice(index, 1); } // 否则将key存入数组 keys.push(key); if(keys.length &gt; 20) { //如果对象的长度&gt;20条 // 删除对象第一条 delete cache[keys[0]]; // 删除keys数组的第一项 keys.unshif(); } } else { return cache[key]; //取值 } } } // 使用方法： var personCache = createCache(); //每次创建一个缓存 personCache(&apos;xc&apos;, {name:&apos;&apos;,age: 18}); personCache(&apos;xc&apos;) 优化方法： function createCache(){ var cache = {}; //cache对象来存放数据 var keys = []; //keys数组来存放所有的数据的键，方便做数量限制 return function(key, value) { // 判断用户有没有传值进来，是不是设置 if (value) { cache[key] = value; if(keys.push(key) &gt; 20) { //如果对象的长度&gt;20条 // 删除对象第一条 delete cache[keys.unshift()]; } } else { return cache[key]; //取值 } } } // 使用方法： var personCache = createCache(); //每次创建一个缓存 personCache(&apos;xc&apos;, {name:&apos;&apos;,age: 18}); personCache(&apos;xc&apos;) 实现一个简单的jquery选择器 &lt;script&gt; // 实现简单的Jquery选择器 function $(selector) { var ele = document; // 考虑: 后代选择器传参 &quot;div ul&quot; // \s匹配任何空白字符,包括空格、制表符、换页符等等，等价于[ \f\n\r\t\v] +匹配前面的子表达式一次或多次 var sele = selector.replace(/\s+/, &apos; &apos;).split(&apos; &apos;); // 去除多余的空格并分割，将传递的参数分割成数组的形式 for (var i = 0, len = sele.length; i &lt; len; i++) { switch (sele[i][0]) { // 判断数组第一项的第一个字符 case &apos;#&apos;: // ele = ele.getElementById( sele[i].substring(1) ); ele = ele.getElementById( sele[i].replace(&quot;#&quot;, &quot;&quot;) ); break; case &apos;.&apos;: // ele = ele.getElementsByClassName( sele[i].substring(1) )[0]; var classname = sele[i].replace(/^\./, &quot;&quot;); // 取得类名 ele = getByClassName(ele, classname)[0]; break; case &apos;[&apos;: // 属性选择器 var valueLoc = sele[i].indexOf(&apos;=&apos;); var temp = ele.getElementsByTagName(&apos;*&apos;); var tLen = temp.length; if (valueLoc !== -1) { // 有属性值 [key=value] var key = sele[i].substring(1, valueLoc); // 属性名 var value = sele[i].substring(valueLoc + 1, sele[i].length - 1); // 属性值 for (var j = 0; j &lt; tLen; j++) { // 遍历dom树的node if (temp[j][key] === value) { ele = temp[j]; break; } } } else { // 根据属性的key值查找 [herf] var key = sele[i].substring(1, sele[i].length - 1); for (var j = 0; j &lt; tLen; j++) { if (temp[j][key]) { ele = temp[j]; break; } } } break; default: // 标签选择器 ele = ele.getElementsByTagName(sele[i])[0]; break; } } if (!ele) { ele = null; } return ele; } //通过class获取元素的兼容性方法 function getByClass(classname) { if (document.getElementsByClassName) { document.getElementsByClassName(classname); } else { var arr = []; var nodes = document.getElementsByTagName(&quot;*&quot;); for (var i = 0; i &lt; nodes.length; i++) { var txtArr = nodes[i].className.split(&quot; &quot;); for (var j = 0; j &lt; txtArr.length; j++) { if (txtArr[j] === classname) { arr.push(nodes[i]); } } } } } function getByClassName(ele, classname) { if (document.getElementsByClassName) { return ele.getElementsByClassName(classname); } else { var nodes = document.getElementsByName(&quot;*&quot;); var arr = []; for (var i = 0, len = nodes.length; i &lt; len; i++) { // 不能直接判断nodes[i].className === calssname // 可能Nodes的class=&apos;save edit&apos; if ( hasClass(nodes[i], classname) ) { arr.push(nodes[i]); } } return arr; } } function hasClass(node, classname) { var cNames = node.className.split(/\s+/); // 根据空白字符来分割类名 for (var i = 0; i &lt; cNames.length; i++) { if (cNames[i] === classname) { return true; } else { return false; } } } &lt;/script&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>递归</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[requireJS]]></title>
    <url>%2F2016%2F01%2F17%2FrequireJS%2F</url>
    <content type="text"><![CDATA[requireJsAMD（ Asynchronous Module Definition）异步加载模块定义 AMD规范化加载的由来 前端的模块化，是参照commonjs规范实现的，有一个全局性的方法require(),用于加载模块，如果有一个add.js，加载的时候，直接使用var add = require(“add”)就可以实现，使用时直接调用add方法，因为在服务端，模块是放在硬盘里面，加载的很快，几乎可以同步读取。 但是在客户端，使用这种方法加载，因为模块放在服务端的，读取的时间取决于网速的快慢，可能会等待很长时间，没有加载完，后面的就不能执行，会造成浏览器假死状态。 所以浏览器模块的加载，不能使用同步，需要异步加载，所以有了AMD规范。即异步模块定义 123456789101112131415161718192021 require([&quot;add&quot;], function(add) &#123; &#125;) ``` 使用require()来加载，第一个参数是模块，是一个数组，第二个参数是回调函数，依赖这个模块的语句，放在回调函数里面，加载完成之后，才会运行回调函数。使用AMD规范的库，用过的是require.js。### requireJs解决的问题- 当一个网页要引入多个外部文件，且文件之间的依赖关系较强的时候，必须保证文件的加载顺序，并且当浏览器加载外部文件的时候就会停止网页的渲染，加载的文件越多，网页失去响应的时间越长，代码的编写和维护也会很麻烦。- requirejs实现了js 文件的异步加载，避免网页失去响应- 管理模块直接的依赖性，便于代码的编写和维护。- 解决了命名冲突问题（不同模块中的同名变量不会有冲突）### requirejs的基本使用### 主模块- 如果主模块不依赖于其他模块 // data-main的作用是指定网页程序的主模板，即main.js。这个文件会第一个被require.js加载。main是省略了后缀名js ```]]></content>
      <categories>
        <category>Javascript</category>
        <category>requireJs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2016%2F01%2F12%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[有看看js高程，看了下大牛们的博客，做一点摘录： 原型链继承2，构造函数继承（对象冒充继承）3，组合继承（原型链继承+构造函数继承）4，原型式继承 寄生组合式继承 1.原型继承（默认的原型继承） // 构造函数 function Person() { } Person.prototype.run = function() {} // 实例对象 var xiaomign = new Person() // 继承了Person原型上面的run方法 2.原型继承（置换后的原型继承） function Person() { } // 让原型等于一个对象 Person.prototype = function() { say: function() {} } // 实例对象 var xiaomign = new Person() // 继承了Person原型上面的say方法 3.寄生式继承 var obj = {val: 100} var target = Object.create(obj) // 继承了obj的方法和属性 4.混入继承 准备两个对象，遍历 function extend(obj1, obj2) { for (var key in obj2) { obj1[key] = obj2[key]; } } var obj = {aaa: 1}; var obj2 = {val: 100}; extend(obj, obj2); 5.对象冒充，或构造函数借用 function Person(name, age) { this.name = name; this.age = age; } function Student(name, age) { this.Person = Person; this.Person(name, age); delete this.Person; } var xiaohong = new Student(&apos;xiaohong&apos;, 16); console.log(xiaohong); // 或者直接 function Student(name, age) { Person.call(this, name, age); } 6.原型寄生组合式继承 function Person(){ this.name=&quot;run&quot;; } function Student(){ this.age=&quot;20&quot;; //Run继承了Show,通过原型，形成链条 } Student.prototype = new Person(); var xiaohong = new Student(); 继承的实现方式：1.混入式继承 var obj = {}; var obj1 = {name: “”, age: 18}; for(var key in obj1) { obj[key] = obj1[key]; } 2、原型继承：原理就是实例化对象，可以共享原型链上的属性和方法。 简要说就是让父类实例来充当子类原型链 1.先定义一个要继承的对象的构造函数，并实例化 function Person(){ this.name = &apos;张学友&apos;； this.age = 19 }; var p = new Person(); 2.让需要继承的对象的构造函数的原型，利用混入式方法，获取到实例化P对象的属性和方法 function Student() { } for（var key in p）{ Student.prototype[key] = p[key]; }; 3.实例化student var stu = new Student(); stu对象就获取了p对象的属性和方法 或者直接把要继承的对象赋值给构造函数的原型 var obj = {name: &quot;袁振万&quot;, age: 18, gender: &quot;female&quot;}; function Person(){}; Person.prototype = obj; var p = new Person(); //也具有了obj的属性和方法 3、经典继承：利用原型的原理 src = {name: 12}; var obj = Object.create(src); obj.__proto__ === src; // src是Obj的原型 // 有兼容性问题，需要封装 function myCreate(obj) { if (Object.create) { return Object.create(obj); } else { // 还是原型继承的方法 function F(){}; F.prototype = obj; return new F(); } } var O = myCreate(obj); 第四、原型继承的应用： 比如两个程序员，需要共同使用一个数组的原型上的一个方法名相同的方法，一个修改了，另外一个的也会改变； 就可以采用继承的思想安全的扩展对象 function ZhangsanArray() { }; // 让Zhangsan构造函数的原型 = [];都具有[]所具有的属性和方法 Zhangsan.prototype = []; ZhangsanArray.prototype.sayHello = function(){ // 执行代码 }]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包学习笔记]]></title>
    <url>%2F2015%2F12%2F31%2F%E9%97%AD%E5%8C%85%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天又是一年的平安夜，还是不去人潮里面凑热闹了，一个人的平安夜是虐狗夜，静静的打开电脑，让蓝光屏映在脸旁，再啃一个发的大苹果，继续来学习之旅吧。 闭包知乎上一大把问题和答案，博客也是，早已经被各位大牛分析的很透彻了，但是对小菜鸟来说，不懂依然迷迷糊糊，希望能通过这篇学习笔记，有进一步的认识吧。 闭包的概念函数局部变量在外部是不可以访问的，这个时候，我们就可以在函数内部创建一个函数，这个内部函数就有权访问原函数的私有变量，再把这个内部函数返回出去，在外部调用这个内部函数。 总结起来： 1.函数嵌套函数； 2.能在函数外部访问函数内部声明的变量 闭包的基本模式function add(outerArg) { function inner(innerArg) { return innerArg + outerArg } return inner; } var addTen = add(10); console.log(addTen(1)) // 输出11 console.log(addTen(2)) // 输出12 本质是利用函数的作用域链，函数内部定义的函数，会把外部函数的作用域中的对象添加到自己到作用域链中，因为子对象可以沿着作用域链向上查找父对象的变量。 在外部函数执行完的时候，执行环境（变量）本来应该被销毁，但是因为被return出去的内部函数还在引用外部函数的变量，所以外部函数的变量不会被销毁，仍然保留在内部函数的作用域链里面，直到内部函数被销毁之后，外部函数的变量才会跟着销毁。 闭包调用方式不同，结果不同如果只调用1次外部outer函数，那么多次使用outer()返回的值访问的变量是同一个变量，如果多次调用外部函数，那么每次调用都生成一个新的变量 &lt;script&gt; function func() { var num = Math.random(); return function () { return num; } } //每次的结果相同，因为外部函数func只调用了一次，只开辟了一次空间，存储了num的值，里面的函数每次调用时引用的变量都相同 // var num = func(); // console.log(num()); // console.log(num()); // console.log(num()); //每次结果不同，因为每次调用func的时候都开辟了一个新的空间，所以彼此之间是独立的，作用域是兄弟关系，没有直接联系，互相无法访问，每一次调用时num都生成新的值 console.log(func()()); console.log(func()()); console.log(func()()); &lt;/script&gt; 闭包的用途1.可以使用闭包保护变量，防止放在外部的变量被别人随意修改，使用闭包，可以给别人提供一个访问变量的接口，在定义接口的时候，在为别人提供的修改变量的方法中设置一些校验逻辑，来判断用户设置的数据的合法性 function func(){ var name = &quot;小明&quot;; var yanzhi = 99999999999; var obj = { setYanZhi: function(value){ if(value &lt; 999999999999){ throw &quot;你是不是不想混了！&quot;; } }, getYanZhi: function(){ return yanzhi; } } return obj; } //小同 var o = func(); o.setYanZhi(9999999999999); console.log(o.getYanZhi()); 2.保护变量，暴露接口，获取元素的所有子元素方法 function outer(){ var list = []; function getChildren(ele){ //1. 获取所有的子元素 var children = ele.children; //2. 遍历所有的子元素 for(var i = 0; i &lt; children.length; i++){ var child = children[i]; list.push(child); getChildren(child); } } return { getChildren: getChildren, list : list }; } // var o = outer(); // o.getChildren(body); // o.list就可以访问获取到的结果了！ 闭包的缺陷1.会把外部函数的活动对象都添加到自己的作用域链上，会比普通的函数更耗费内存； 2.垃圾回收机制发现闭包外部函数的变量有人使用的时候，就不会回收。所以会占用内存 闭包的应用场景tab栏切换tab栏切换的时候，给ul下面的每一个li添加点击事件，点击的时候，需要获取当前的li的索引 &lt;ul&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt; &lt;li&gt;item5&lt;/li&gt; &lt;/ul&gt; var list = document.getElementsByTagName(&apos;li&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { list[i].onclick = function() { alert(i); //i=5 } } 点击任意一个li的时候，i的值总是5 因为onclick事件是被异步触发的，先执行的是for循环的同步事件，执行完i是5，onclick被触发的时候，i是5 解决方案1,遍历的时候添加自定义属性index，点击的时候获取： var list = document.getElementsByTagName(&apos;li&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { // 循环的时候就给每一个btn设置自定义属性 list[i].index = i; list[i].onclick = function() { alert(this.index); //解决了问题 } } 解决方案2：闭包，每次一for循环的时候，将i的值存储起来 var list = document.getElementsByTagName(&apos;button&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { // 创建一个闭包 function outer(){ var j = i; function func(){ alert(j); } return func; } var f = outer(); //关键是这一步，for循环的时候就执行了 list[i].onclick = f //每次循环都存储i的值 } // 简化版： for(var i = 0, len = list.length; i &lt; len; i++) { // 创建一个闭包 list[i].onclick = (function(j) { return function(){ alert(j)； } }(i)； } 保护私有变量写js代码的时候，为了防止全局变量污染，也为了别人不能随意更改自己的变量值，所以经常会把自己的代码写在一个自执行函数里面。 但是又想向外面暴露接口，修改里面的值和获取里面的值，修改的时候设置校验条件，判断用户设置的值的合法性，就可以考虑闭包。 var foo = (function(){ var secret = &apos;secret&apos;; return { get_secret: function() { return secret; }, set_secret: function(newValue) { if（newValue &lt; 0）{ throw(&apos;修改值不符合要求&apos;); } secret = newValue; } } }()) foo.get_secret() //&apos;secret&apos; foo.secret // 不能访问 foo.set_secret(&apos;new_secret&apos;); foo.get_secret() // new_secret 解决for循环里面setTimeout问题for(var i = 0; i &lt; 5; i++){ setTimeout(function(){ console.log(new Date, i); }, 1000); } console.log(new Date, i); // 异步的，先for循环完毕，i为5,然后一下子打印5个5 // 5-》5，5，5，5，5 // 解决方法：闭包 for(var i = 0; i &lt; 5; i++){ function outer(){ var j = i; function inner(){ console.log(j); } return inner; } var f = outer(); //每一次for循环都会执行Outer函数，开辟内存，保存当时的i变量 setTimeout(f, 1000); } // 简化之后 for (var i = 0; i &lt; 5; i++) { (function(j) { // i = j setTimeout(function() { console.log(new Date, j) }) })(i) } 或者：闭包的另一种做法： var output = function (i) { setTimeout(function() { console.log(new Date, i); }, 1000); }; for (var i = 0; i &lt; 5; i++) { output(i); // 这里传过去的 i 值被复制了 } console.log(new Date, i); 补充： 其实如果不是需要在外部打印，其实可以用let作用域，把var换成let，就解决了问题。因为let只作用在循环内部的作用域。 补充：看到简书上一个对闭包进一步深化的学习，解决这个问题的需求和答案： 问题： 如果期望代码的输出变成 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？新的需求可以精确的描述为：代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5 1.简单粗暴的解决方法： for (var i = 0; i &lt; 5; i++) { (function(j) { setTimeout(function() { console.log(new Date, j); }, 1000 * j)); // 这里修改 0~4 的定时器时间 })(i); } setTimeout(function() { // 这里增加定时器，超时设置为 5 秒 console.log(new Date, i); }, 1000 * i); 2.虽然解决了问题，但是没有联想起异步操作的Promise方法在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情，代码该怎么组织？ const tasks = []; for (var i = 0; i &lt; 5; i++) { // 这里 i 的声明不能改成 let，如果要改该怎么做？ ((j) =&gt; { tasks.push(new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(new Date, j); resolve(); // 这里一定要 resolve，否则代码不会按预期 work }, 1000 * j); // 定时器的超时时间逐步增加 })); })(i); } Promise.all(tasks).then(() =&gt; { setTimeout(() =&gt; { console.log(new Date, i); }, 1000); // 注意这里只需要把超时设置为 1 秒 }); 下面代码会更简洁明了一些 const tasks = []; // 这里存放异步操作的 Promise const output = (i) =&gt; new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(new Date, i); resolve(); }, 1000 * i); }); // 生成全部的异步操作 for (var i = 0; i &lt; 5; i++) { tasks.push(output(i)); } // 异步操作完成之后，输出最后的 i Promise.all(tasks).then(() =&gt; { setTimeout(() =&gt; { console.log(new Date, i); }, 1000); }); 之前看过几次阮一峰的ES6的Primise讲解，但是实践中用的还是不多，找时间可以再去研究一下。 再补充：佩服原作者的好学精神，还给出了es7的解决方案： // 模拟其他语言中的 sleep，实际上可以是任何异步操作 const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; { setTimeout(resolve, timeountMS); }); (async () =&gt; { // 声明即执行的 async 函数表达式 for (var i = 0; i &lt; 5; i++) { await sleep(1000); console.log(new Date, i); } await sleep(1000); console.log(new Date, i); })(); 这个先占坑，之后再学习一下es7，感觉快跟不上时代了。。。 闭包的优化 比如说一个外部函数，里面定义一个内部函数，我只想用这个内部函数去引用外部函数的一个属性值，但是闭包会把外部函数的所有属性和方法都添加到内部函数的作用域链上，导致占用不必要的内存。 可以把要引用的变量用另外的值保存下来，然后把引用的对象设置为null。 function Outer() { var obj = {}; obj.id = &apos;12345678&apos;; obj.name = &apos;aha&apos;; // ... 假设经过很多处理过程，最后obj上带有很多属性 return function() { return obj.id; }; } function AnotherOuter() { var obj = {}; obj.id = &apos;12345678&apos;; obj.name = &apos;aha&apos;; // ... 假设经过很多处理过程，最后obj上带有很多属性 var id = obj.id; obj = null; return function() { return id; }; }]]></content>
      <categories>
        <category>Javascript</category>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目兼容性问题总结]]></title>
    <url>%2F2015%2F12%2F18%2F%E9%A1%B9%E7%9B%AE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这是一个大坑，只会在浏览器彻底统一标准，世界大和谐之后，才可能填平。。。 IE8下的兼容性问题Placeholder的IE8兼容问题解决方法jQuery的placeholder插件https://gist.github.com/oec2003/8946120用法：将placeholder.js文件引用到页面，页面中添加下面脚本： &lt;script type=&quot;text/javascript&quot;&gt; $(function() { $(&apos;input, textarea&apos;).placeholder(); }); &lt;/script&gt; 原理就是：浏览器不支持placeholder属性时，克隆一个和界面相同的input框，将placeholder的值设置为其value值，覆盖在界面input框所在位置，并将界面上的input隐藏掉） http://www.cnblogs.com/candice-cc/p/5946100.html 关键的代码： $(&apos;input[placeholder],textarea[placeholder]&apos;).each(function(){ var that = $(this), text= that.attr(&apos;placeholder&apos;); if(that.val()===&quot;&quot;){ if(that.attr(&quot;type&quot;) == &quot;password&quot;){ $el.html(&quot;请输入密码&quot;); }else { that.val(text).addClass(&apos;placeholder&apos;); } } js里面处理transfrom前缀兼容性问题问题是：在js里面通过dom.style.transfrom = ‘translateX(10px)’设置时，为了兼容不同的浏览器，如果加前缀一行行写的话，很繁琐。 所以考虑封装一个prefixed方法，根据浏览器的支持能力去自动确定添加前缀 let elementStyle = document.createElement(&apos;div&apos;).style let vendor = (() =&gt; { // 列举浏览器支持的 let transformNames = { webkit: &apos;webkitTransform&apos;, Moz: &apos;MozTransform&apos;, O: &apos;OTransform&apos;, ms: &apos;msTransform&apos;, standard: &apos;transform&apos; } // 测试浏览器支持哪一种 for (let key in transformNames) { if (elementStyle[transformNames[key]] !== undefined) { return key } } // 如果所有的都不支持，则浏览器有故障 return false })() export function prefixStyle (style) { if (vendor === false) { return false } // 支持标准的 if (vendor === &apos;standard&apos;) { return style } return vendor + style.charAt(0).toUpperCase() + style.substr(1) } 使用的时候： // 先引入函数 import {prefixStyle} from &apos;../../common/js/dom.js&apos; const transform = prefixStyle(&apos;transfrom&apos;); this.$refs.box[transform] = `translate3d(0, ${translteY}px, 0)` 事件e的兼容性e || window.event 事件对象e.target || e.srcElement ### 禁止网页选取FF需要用CSS禁止，IE用JS禁止 解决方法： IE: obj.onselectstart = function() {return false;} FF: -moz-user-select:none;]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jquery插件写法分析]]></title>
    <url>%2F2015%2F10%2F31%2FjQuery%E6%8F%92%E4%BB%B6%E5%86%99%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[我们写好了一个独立的功能，也想将其与jquery结合起来，可以用jquery链式调用，这就要扩展jquery，写成插件形式了，如下面就是一个简单扩展Jquery对象的demo： //扩展jquery对象的方法，bold()用于加粗字体。 (function ($) { $.fn.extend({ &quot;bold&quot;: function () { ///&lt;summary&gt; /// 加粗字体 ///&lt;/summary&gt; return this.css({ fontWeight: &quot;bold&quot; }); } }); })(jQuery); 调用方式： $(function () { $(&apos;p&apos;).bold(); }) jquery的插件机制jquery的插件机制为了方便用户创建插件，jquery提供了jQuery.extend()和jQuery.fn.extend()方法。 jQuery.extend() 方法有一个重载。 jQuery.extend(object) ,一个参数的用于扩展jQuery类本身，也就是用来在jQuery类/命名空间上增加新函数，或者叫静态方法，例如jQuery内置的 ajax方法都是用jQuery.ajax()这样调用的，有点像 “类名.方法名” 静态方法的调用方式。 下面我们也来写个jQuery.extend(object)的例子： //扩展jQuery对象本身 jQuery.extend({ &quot;minValue&quot;: function (a, b) { ///&lt;summary&gt; /// 比较两个值，返回最小值 ///&lt;/summary&gt; return a &lt; b ? a : b; }, &quot;maxValue&quot;: function (a, b) { ///&lt;summary&gt; /// 比较两个值，返回最大值 ///&lt;/summary&gt; return a &gt; b ? a : b; } }); //调用 var i = 100; j = 101; var min_v = $.minValue(i, j); // min_v 等于 100 重载版本：jQuery.extend([deep], target, object1, [objectN]) 用一个或多个其他对象来扩展一个对象，返回被扩展的对象。 如果不指定target，则给jQuery命名空间本身进行扩展。这有助于插件作者为jQuery增加新方法。 如果第一个参数设置为true，则jQuery返回一个深层次的副本，递归地复制找到的任何对象。否则的话，副本会与原对象共享结构。 未定义的属性将不会被复制，然而从对象的原型继承的属性将会被复制。 参数 deep: 可选。如果设为true，则递归合并。 target: 待修改对象。 object1: 待合并到第一个对象的对象。 objectN: 可选。待合并到第一个对象的对象。 示例1： 合并 settings 和 options，修改并返回 settings。 var settings = { validate: false, limit: 5, name: &quot;foo&quot; }; var options = { validate: true, name: &quot;bar&quot; }; jQuery.extend(settings, options); 结果： settings == { validate: true, limit: 5, name: &quot;bar&quot; } 示例2： 合并 defaults 和 options, 不修改 defaults。 var empty = {}; var defaults = { validate: false, limit: 5, name: &quot;foo&quot; }; var options = { validate: true, name: &quot;bar&quot; }; var settings = jQuery.extend(empty, defaults, options); 结果： settings == { validate: true, limit: 5, name: &quot;bar&quot; } empty == { validate: true, limit: 5, name: &quot;bar&quot; } 这个重载的方法，我们一般用来在编写插件时用自定义插件参数去覆盖插件的默认参数。 jQuery.fn.extend(object)扩展 jQuery 元素集来提供新的方法（通常用来制作插件）。 首先我们来看fn 是什么东西呢。查看jQuery代码，就不难发现。 jQuery.fn = jQuery.prototype = { init: function( selector, context ) {.....}; }; 原来 jQuery.fn = jQuery.prototype，也就是jQuery对象的原型。 那jQuery.fn.extend()方法就是扩展jQuery对象的原型方法。 我们知道扩展原型上的方法，就相当于为对象添加”成员方法“，类的”成员方法“要类的对象才能调用，所以使用jQuery.fn.extend(object)扩展的方法， jQuery类的实例可以使用这个“成员函数”。 jQuery.fn.extend(object)和jQuery.extend(object)方法一定要区分开来。 自执行的匿名函数/闭包 什么是自执行的匿名函数? 它是指形如这样的函数: (function {// code})(); 疑问 为什么(function {// code})();可以被执行, 而function {// code}();却会报错? 分析 (1). 首先, 要清楚两者的区别: (function {// code})是表达式, function {// code}是函数声明. (2). 其次, js&quot;预编译&quot;的特点: js在&quot;预编译&quot;阶段, 会解释函数声明, 但却会忽略表式. (3). 当js执行到function() {//code}();时, 由于function() {//code}在&quot;预编译&quot;阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错; 当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行. 另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符…… 例如： bootstrap 框架中的插件写法： !function($){ //do something; }(jQuery); 和 (function($){ //do something; })(jQuery); 是一回事。 匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。 例如： var a=1; (function()(){ var a=100; })(); alert(a); //弹出 1 更多 闭包和匿名函数 可查看 Javascript的匿名函数与自执行 这篇文章。 一步一步封装JQuery插件接下来我们一起来写个高亮的jqury插件 1.定一个闭包区域，防止插件”污染” //闭包限定命名空间 (function ($) { })(window.jQuery); 2.jQuery.fn.extend(object)扩展jquery 方法，制作插件 //闭包限定命名空间 (function ($) { $.fn.extend({ &quot;highLight&quot;:function(options){ //do something } }); })(window.jQuery); 3.给插件默认参数，实现 插件的功能 //闭包限定命名空间 (function ($) { $.fn.extend({ &quot;highLight&quot;: function (options) { //使用jQuery.extend 覆盖插件默认参数 var opts = $.extend({}, defaluts, options); //这里的this 就是 jQuery对象 this.each(function () { //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。 var $this = $(this); //获取当前dom 的 jQuery对象， 这里的this是当前循环的dom //根据参数来设置 dom的样式 $this.css({ backgroundColor: opts.background, color: opts.foreground }); }); } }); //默认参数 var defaluts = { foreground: &apos;red&apos;, background: &apos;yellow&apos; }; })(window.jQuery); 到这一步，高亮插件基本功能已经具备了。调用代码如下： $(function () { $(&quot;p&quot;).highLight(); //调用自定义 高亮插件 }); 这里只能 直接调用，不能链式调用。我们知道jQuey是可以链式调用的，就是可以在一个jQuery对象上调用多个方法，如： $(&apos;#id&apos;).css({marginTop:&apos;100px&apos;}).addAttr(&quot;title&quot;,&quot;测试“); 但是我们上面的插件，就不能这样链式调用了。 比如：$(&quot;p&quot;).highLight().css({marginTop:&apos;100px&apos;}); //将会报找不到css方法，原因在与我的自定义插件在完成功能后，没有将 jQuery对象给返回出来。 // 接下来，return jQuery对象，让我们的插件也支持链式调用。（其实很简单，就是执行完我 们插件代码的时候将jQuery对像return 出来，和上面的代码没啥区别） 4.暴露公共方法 给别人来扩展你的插件（如果有需求的话） 比如的高亮插件有一个format方法来格式话高亮文本，则我们可将它写成公共的，暴露给插件使用者，不同的使用着根据自己的需求来重写该format方法，从而是高亮文本可以呈现不同的格式。 //公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。 $.fn.highLight.format = function (str) { return &quot;&lt;strong&gt;&quot; + str + &quot;&lt;/strong&gt;&quot;; } 5.插件私有方法 有些时候，我们的插件需要一些私有方法，不能被外界访问。例如 我们插件里面需要有个方法 来检测用户调用插件时传入的参数是否符合规范。 6.其他的一些设置，如：为你的插件加入元数据插件的支持将使其变得更强大。 完整的高亮插件代码如下： //闭包限定命名空间 (function ($) { $.fn.extend({ &quot;highLight&quot;: function (options) { //检测用户传进来的参数是否合法 if (!isValid(options)) return this; var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数 return this.each(function () { //这里的this 就是 jQuery对象。这里return 为了支持链式调用 //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。 var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom //根据参数来设置 dom的样式 $this.css({ backgroundColor: opts.background, color: opts.foreground }); //格式化高亮文本 var markup = $this.html(); markup = $.fn.highLight.format(markup); $this.html(markup); }); } }); //默认参数 var defaluts = { foreground: &apos;red&apos;, background: &apos;yellow&apos; }; //公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。 $.fn.highLight.format = function (str) { return &quot;&lt;strong&gt;&quot; + str + &quot;&lt;/strong&gt;&quot;; } //私有方法，检测参数是否合法 function isValid(options) { return !options || (options &amp;&amp; typeof options === &quot;object&quot;) ? true : false; } })(window.jQuery); 调用 //调用 //调用者覆盖 插件暴露的共公方法 $.fn.highLight.format = function (txt) { return &quot;&lt;em&gt;&quot; + txt + &quot;&lt;/em&gt;&quot; } $(function () { $(&quot;p&quot;).highLight({ foreground: &apos;orange&apos;, background: &apos;#ccc&apos; }); //调用自定义 高亮插件 }); var max_v = $.maxValue(i, j); // max_v 等于 101]]></content>
      <categories>
        <category>Javascript</category>
        <category>jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2015%2F09%2F28%2F%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[正则声明方法//1.声明方法1:构造函数 var reg1 = new RegExp(/abc/); console.log(reg1); //2.声明方法2: 字面量 var reg2 = /abc/; console.log(reg2); console.log(reg1.test(&quot;abc&quot;)); 量词//量词： * 重复零次或更多 (&gt;=0) + 重复一次或更多次 (&gt;=1) ? 重复零次或一次 （0||1） 要么有 要么没有 {} 重复多少次的意思 JavaScript中正则表达式test()、exec()、match() 方法区别1、test test 返回 Boolean，查找对应的字符串中是否存在模式。 var str = &quot;1a1b1c&quot;; var reg = new RegExp(&quot;1.&quot;, &quot;&quot;); alert(reg.test(str)); // true 2、exec exec 查找并返回当前的匹配结果，并以数组的形式返回。 var str = &quot;1a1b1c&quot;; var reg = new RegExp(&quot;1.&quot;, &quot;&quot;); var arr = reg.exec(str); 如果不存在模式，则 arr 为 null，否则 arr 总是一个长度为 1 的数组，其值就是当前匹配项。 arr 还有三个属性： index 当前匹配项的位置； lastIndex 当前匹配项结束的位置（index + 当前匹配项的长度）；input 如上示例中 input 就是 str。 exec 方法受参数 g 的影响。若指定了 g，则下次调用 exec 时，会从上个匹配的 lastIndex 开始查找。 var str = &quot;1a1b1c&quot;; var reg = new RegExp(&quot;1.&quot;, &quot;&quot;); alert(reg.exec(str)[0]); alert(reg.exec(str)[0]); 上述两个输出都是 1a。现在再看看指定参数 g： var str = &quot;1a1b1c&quot;; var reg = new RegExp(&quot;1.&quot;, &quot;g&quot;); alert(reg.exec(str)[0]); alert(reg.exec(str)[0]); 上述第一个输出 1a，第二个输出 1b。 3、match match 是 String 对象的一个方法。 var str = &quot;1a1b1c&quot;; var reg = new RegExp(&quot;1.&quot;, &quot;&quot;); alert(str.match(reg)); match 这个方法有点像 exec，但：exec 是 RegExp 对象的方法；math 是 String 对象的方法。二者还有一个不同点，就是对参数 g 的解释。如果指定了参数 g，那么 match 一次返回所有的结果。 var str = &quot;1a1b1c&quot;; var reg = new RegExp(&quot;1.&quot;, &quot;g&quot;); alert(str.match(reg)); //alert(str.match(reg)); // 此句同上句的结果是一样的 此结果为一个数组，有三个元素，分别是：1a、1b、1c。 正则题目 需求：判断字符串是否是这样组成的，第一个必须是字母，后面可以是字母、数字、下划线，总长度为5-20 var reg = /^[a-zA-Z]\w{4,19}$/; 或者 var reg = /^d\w{4,19}$/; // 第一个是数字 解析： /是转义 ^ 是开头 [a-zA-Z]是字母出现一次 \w是任意字符 {4,19}是长度 $ 是结束 console.log(reg.test()); // true 正则表达式封装trim方法 function trim(string){ //思路：把字符串前后的空白字符。全部替换为&quot;&quot;; var reg = /(^\s+)|(\s+$)/g; return string.replace(reg,&quot;&quot;); } 将字符串”{$id}{$name}”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式） var str = ”&lt;tr&gt;&lt;td&gt;{$id}&lt;/td&gt;&lt;td&gt;{$name}&lt;/td&gt;&lt;/tr&gt;”； str.replace(/{\$id}/g, &apos;10&apos;).replace({\$name}/g, &apos;tony&apos;); 写一个function，清除字符串前后的空格。（兼容所有浏览器）使用自带接口trim()，考虑兼容性： if (!String.prototype.trim) { String.prototype.trim = function() { return this.replace(/(^\s+) | (\s+$)/g, &apos;&apos;) } } 为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义 function escapeHtml(str) { return str.replace(/[&lt;&gt;&quot;&amp;]/g, function (match) { switch (match) { case &quot;&lt;&quot;: return &quot;&amp;lt;&quot;; case &quot;&gt;&quot;: return &quot;&amp;gt;&quot;; case &quot;&amp;&quot;: return &quot;&amp;amp;&quot;; case &quot;\&quot;&quot;: return &quot;&amp;quot;&quot;; } }); }]]></content>
      <categories>
        <category>Javascript</category>
        <category>正则</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象]]></title>
    <url>%2F2015%2F08%2F28%2F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[创建对象的几种方式 对象字面量方法 内置构造函数 Object var obj = new Object(); obj.name = &quot;文章&quot;; obj.age = 19; var obj1 = new Object(); obj.name = &quot;&quot;; obj.age = 20; 构造函数方法 工厂模式 function createClock(hour,minute,second){ var clock = new Object(); clock.hour=hour; clock.minute=minute; clock.second=second; clock.showHour=function(){ alert(this.hour+&quot;:&quot;+this.minute+&quot;:&quot;+this.second); }; return clock; }; var newClock = createClock(12,12,12);//实例化 newClock.showHour();//调用 优点：总算优点抽象的概念了。但是不能识别对象的类型 构造函数模式function clock(hour,minute,second){ this.hour = hour; this.minute = minute; this.second = second; this.showTime = function(){ alert(this.hour+&quot;:&quot;+this.minute+&quot;:&quot;+this.second); } } var newClock =new clock(12,12,12); alert(newClock.hour); 注意:这个new关键字是必须，如果不加，clock就不会当成构造函数调用，而只是一个普通的函数。 new关键字的作用： 1.先创建一个空对象； 2.将this指向这个空对象； 3.将参数赋值给空对象； 4.返回创建的对象，即return this 构造函数+原型模式将基本属性放在构造函数内部，将方法放在原型上 function clock(hour,minute,second){ this.hour = hour; this.minute = minute; this.second = second; } clock.prototype.showTime=function(){alert(this.hour+&quot;:&quot;+this.minute+&quot;:&quot;+this.second);} var newClock = new clock(12,12,12); newClock.showTime(); 这里我们将属性放在构造函数中，更显得对象的具体性。 构造函数//1. 构造函数是什么? // 构造函数其实就是一个函数，一般是用来初始化对象的！ //2. 构造函数的特点？ //1. 函数名首字母一般大写（规范） //2. 一般和new关键字一起使用 //3. this指的就是new出来的对象 //4. 不需要手动写return语句，会自动返回new创建出来的对象 //3. 构造函数的执行过程： //1. 使用new关键字创建对象，开辟内存空间 //2. 调用构造函数，让构造函数中的this指向new创建出来的对象 //3. 在构造函数内部使用this为new创建出来的对象添加属性和方法（初始化的过程） //4. 默认返回new创建出来的对象 function Person(){ this.name = &quot;&quot;; this.age = 18; this.gender = &quot;Male&quot;; // return []; } // var p = new Person(); var p = Person(); console.log(p); //4. 构造函数的注意事项： //4.1 构造函数不需要手动写return语句，如果写了： //如果return的是值类型的数据，则不会对默认的返回值产生影响 //如果return的是引用类型的数据，则最终返回的就是return的引用类型的数据，而非new创建出来的对象！ //4.2 构造函数可以当做普通函数来调用，但是有如下情况： //如果不写return语句，则调用之后的返回值为undefined，如果写了return语句，那么写什么就返回什么 //函数中this，这时会指向window, 通过this添加的所有的属性和方法，都会添加给window对象 // function func(){ // console.log(&quot;好想是一个构造函数哦!&quot;); // } // var f = new func(); // console.log(f); 原型//成员： 属性和方法 //1. 原型是什么？ //在构造函数创建出来的时候，系统会默认的帮这个构造函数创建并且关联一个空对象，这个对象就是原型 //2. 原型的作用是什么? //原型中的成员可以被和该原型关联的构造函数所创建出来的所有的对象共享！ //3. 原型如何访问（如何获取到这个原型对象）？ //构造函数名.prototype function Person(){ this.name = &quot;&quot;; this.age = 18; } // Person.prototype.gender = &quot;你看不见我！！！&quot;; Person.prototype.sing = function(){ console.log(&quot;该配合你演出的我演视而不见&quot;); } var p = new Person(); p.sing(); // console.log(p.gender); var p1 = new Person(); p1.sing(); // console.log(p1.gender); // console.log(Person.prototype); console.log(p.sing === p1.sing); 原型的注意事项 //1. 在使用对象获取成员的时候，会首先在对象本身进行查找，如果找不到到才会去原型中进行查找，如果在自身中找到了，就不会去原型中找了 //2. 一般只会将需要共享的内容放到原型当中，对象本身特有的东西放在对象自身内部。 //3. 在设置属性的时候，不会去原型中进行查找，只会在对象本身查找，如果找到了就修改，如果没有找到，就新增！ // function Person(name, age){ // this.name = name; // this.age = age; // } // Person.prototype.classRoom = &quot;1306(3栋)&quot; // var p = new Person(&quot;白百合&quot;, 18); // var p1 = new Person(&quot;陈羽凡&quot;, 20); // // console.log(p.classRoom); // // console.log(p1.classRoom); // p.classRoom = &quot;1308&quot;; // console.log(p1.classRoom); //4. 当给构造函数的prototype属性重新赋值的时候，之前创建的对象的原型，是不会发生改变的，所以会造成一个现象，更改原型属性之前创建的对象和之后创建的对象的原型不一致！ function Person(){ } Person.prototype.sayHi = function(){ console.log(&quot;Hey, man~&quot;); } var p = new Person(); p.sayHi(); Person.prototype = { sayHello: function(){ console.log(&quot;Hello Prototype&quot;); } }; var p1 = new Person(); p1.sayHello(); p.sayHi(); //报错！ // p1.sayHi(); //报错！ // p.sayHello(); &lt;/script&gt; 原型链 //什么是原型链 //对象都有原型，原型也是对象，所以原型也有原型，这样子形成的链式结构就称为原型链！ //属性搜索原则： //当使用对象去访问某个属性的时候，遵守如下原则： //1. 先在对象本身进行查找，如果有就直接使用 //2. 如果没有，就去对象的原型中进行查找，如果有就直接使用 //3. 如果还没有，就继续沿着原型链继续向上查找，直到找到null //在设置属性的时候，不会遵守上述原则！只在自身找！ // function Person(){ // } // var p = new Person(); // var arr = []; Object.prototype.sayHello = function(){ console.log(&quot;你看我强大不强大！&quot;); } var arr = []; var obj = {}; var now = new Date(); var reg = /\d/; arr.sayHello(); obj.sayHello(); now.sayHello(); reg.sayHello(); function Pig(){} var p = new Pig(); p.sayHello(); &lt;/script&gt;]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie基础知识及用法]]></title>
    <url>%2F2015%2F07%2F18%2Fcookie%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[应用场景 保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。 定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。 创建购物车。正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。 当然，上述应用仅仅是cookie能完成的部分应用，还有更多的功能需要全局变量。 cookie的缺点主要集中于安全性和隐私保护。主要包括以下几种： cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能； cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的； cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除； cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。 注意事项： cookie是http请求协议的一部分，写在http头部里面，每次当前页面请求的时候都会一起发送给服务器，所以也浪费性能，尽量少写。有替代方案，使用html5的localStrage属性，但是为了兼容性，低版本的还是可以使用cookie cookie的用法和格式 domain：有效域名，默认为当前2级域名 path：有效路径，默认为/ expires：到期时间，默认为一个会话 max-age：最新代替expires的配置项，设置有效时间，单位秒 secure：是否只在https协议下传输cookie，默认false// 存储的数据格式如果比较特殊可以使用encodeURIComponent方法进行编码document.cookie = ‘data=gezhongshuju’+ &apos;;domain=baidu.com&apos; + &apos;;path=/&apos; + &apos;;expires=&apos; + new Date(&apos;2017-3-15&apos;) + &apos;;max-age=&apos; + 60 * 60 * 24 + &apos;;secure=true&apos;; 使用cookie插件 –&gt; jquery.cookie.js获取//获取所有cookie var cookieObj = $.cookie(); //获取单个cookie var cookieVal = $.cookie(&quot;key&quot;); 注意：获取到的是一个json字符串，需要转成json对象 var cookieVal = JSON.parse($.cookie(&quot;key&quot;)); 但是，如果用户将cookie删除的话，就会出现JSON.parse(undefined);报错的情况：所以需要先判断，是否有$.cookie(“key”)，才能继续进行业务逻辑 方法一： var userInfo = JSON.parse( $.cookie(&quot;userInfo&quot;) || &quot;{}&quot; ); 方法二： try{ var userInfo = JSON.parse($.cookie(&quot;key&quot;)); }catch(e) { console.log(&quot;json解析错误&quot;); } 设置和修改//设置cookie 在当前域名路径下设置指定的cookie var cookieStr = $.cookie(&apos;key&apos;, &apos;value&apos;); //设置指定天数过期时间 在当前域名路径下设置指定的cookie var cookieStr = $.cookie(&apos;key&apos;, &apos;value&apos;, {expires: 100}); var cookieStr = $.cookie(&apos;key&apos;, &apos;value&apos;, {&apos;max-age&apos;: 24 * 60 * 60 }); //max-age以秒为单位 //设置当前域名路径下cookie var cookie = $.cookie(&apos;key&apos;, &apos;value&apos;, { domain: &apos;/&apos;, path: &apos;/&apos;, secure: true }); 删除cookie// 删除单个cookie --&gt; 删除当前路径下指定cookie // 返回值代表在当前路径下是否还存在这个cookie，因为同一个cookie名可能存在与不同的路径中，每次只能删除一个 var isExist = $.removeCookie(&apos;cookieKey&apos;); // 删除单个cookie --&gt; 删除指定路径下指定cookie // 该cookie一定在当前路径下可以访问的到，即该cookie路径是当前路径的上级 // 返回值代表在当前路径下是否还存在这个cookie，因为同一个cookie名可能存在与不同的路径中，每次只能删除一个 var cookieVal = $.cookie(&apos;cookieKey&apos;, { path: &apos;/&apos; }); 原生js设置和修改cookie//一次只能存储一个值 document.cookie = &quot;userId=value&quot;; document.cookie = &quot;userInfo={name:&apos;zhangsan&apos;,age:29}&quot;; 或者 document.cookie = &apos;userId=828; userName=hulk&apos;; //一次性存储多个值 //修改cookie document.cookie = &quot;userId=234&quot;; //语法为：document.cookie = &quot;key=newValue&quot;; 获取cookie//document.cookie获取的是一个网页，当前路径下面的所有cookie信息，比如jd.com里面的cookie就是jd的cookie，可以通过路径来设置cookie的使用范围 //设置两个cookie document.cookie=&quot;userId=828&quot;; document.cookie=&quot;userName=hulk&quot;; //获取cookie字符串 var strCookie = document.cookie; //str = &quot;userId=828; userName=hulk&quot; var arrCookie = strCookie.split(&quot;;&quot;) //将多个cookie切割为多个名值对 var userId; //遍历cookie数组，处理每个cookie对 for(var i = 0; i &lt; arrCookie.length; i++) { var arr = arrCookie[i].split(&quot;=&quot;); //将单个名值对切割成一个数组 if (arr[0] == &apos;userId&apos;) { userId = arr[i]; } } return userId; //可以得到一个cookie的值 expires: 给cookie设置终止日期有一个新方法： max-age //语法：document.cookie = &apos;userId=828; expires=GMT_String&apos;; //设置10天后过期 var date = new Date(); //取得当前时间 var expiresDays = 10; //设置过期时间 date.setTime(date.getTime() + expiresDays * 24 * 3600 * 1000); document.cookie = &apos;userId=828; useName=hulk; expires=&apos;+date.toGMTString(); //设置某一个日期过期 document.cookie = &quot;userId=828; expires=&quot; + new Date(&quot;2017-5-13&quot;); //先找到要设置过期时间的cookie，再将过期时间设置为当前时间的过去时间 删除cookie，将cookie时间设置为过去的时间即可var date = new Date(); date.setTime(date.getTime() - 100000); document.cookie = &apos;useId=825; expires=&apos;+ date.toGMTString(); cookie可以访问的路径 默认情况下，只有同级目录或同级目录的子目录可以访问，例如： cookie所在页面： www.xxxx.com/html/a.html； 可以被访问的页面： www.xxxx.com/html/b.html； www.xxx.com/ html/ some/c.html 不能被访问的页面： www.xxxx.com/d.html 子路径可以访问父路径的，父路径不能访问子路径的，默认设置的是根目录 //为了控制cookie可以访问的页面，需要设置path参数 document.cookie=&apos;name=xioaming; path=cookieDir&apos;; //指定cookie在整个根目录下都可以使用，将cookieDir指定为根目录 document.cookie = &apos;user=123; path=/&apos; cookie代码封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var CookieUtil = &#123; //设置cookie set: function(name, value, expireDays, domain, path, secure) &#123; var cookieText = ''; //设置cookie键值对 cookieText += encodeURIComponent(name) + '=' + encodeURIComponent(value); //设置过期时间 if(expireDays) &#123; var date = new Date(); date.setDate(date.getDate() + expireDays); cookieText += '; expires=' + date.toGMTString(); &#125; //设置cookie可以访问的路径 if(path) &#123; cookieText += '; path=' + path; &#125; //设置cookie可以访问的主域名 if(domain) &#123; cookieText += '; domain=' + domain; &#125; if (secure) &#123; cookieText += "; secure"; &#125; document.cookie = cookieText; &#125;, // name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure //获取cookie值 get : function (name) &#123; var cookieName = encodeURIComponent(name) + "=", cookieStart = document.cookie.indexOf(cookieName), cookieValue = ""; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf (";", cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, // 删除cookie unset : function (name, domain, path, secure) &#123; this.set(name, "", Date(0), domain, path, secure); &#125;&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端1px的border问题]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E7%9A%84border%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近做一个移动端的页面，踩了很多坑，也有很多小细节，终于找个时间总结一下，记录下来。 问题： 页面中很多border-bottom被设置为1px,在桌面端的时候，没有问题，但是到手机端，看起来会是2px,因为手机的有一个设备像素比，是两倍,设置的是1px，在2倍的像素比下，就是2px. 解决方法： 因为像素不可能是0.5px,最小单位是1px，所以考虑用css3的伪类 + transform方法对其做scale缩放 把原来的border去掉，利用：after重新做border,定位于原来的元素。 并且由于不同设备像素比，缩放比例需要不同。 因为在项目里面使用的比较多，为了增强复用性，需要单独创建一个文件，比如：css/mixin.css，使用的时候将这个文件用@import引入进来 css/mixin.css 设置： /*设置一个border-top为1px的伪类*/ .border-1px { position: relative; border: none; } .border-1px:after { display: block; position: absolute; left: 0; bottom: 0; // 因为设置的是border-bottom width: 100%; border-top: 1px solid #ccc; //height: 1px; content: &apos;&apos; } 注意：stylus或less或sass的写法： .border-1px ($color) { // 样式 &amp;:after // 样式 // 把颜色换成$color } /* 如果是需要设置border-top,用before伪类,设置伪类的border-bottom 但是此时的1px还是和原来直接设置border-bottom: 1px 一样的，并没有缩放效果 */ /*根据设备像素比，用media query来判断，做不同缩放，保证缩放完毕的值 * 设备像素比 = 1px*/ // 在设备像素比是1.5和2时候用scale做缩放 @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7) @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 用法： 1.先引入定义的公用样式，用 @import &apos;地址&apos; 2.设置给需要的元素，比如item元素 .item { border-1px(&apos;#ccc&apos;) // 设置1px的border-bottom }]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件知识学习总结]]></title>
    <url>%2F2015%2F06%2F18%2F%E4%BA%8B%E4%BB%B6%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[事件概念 用户或浏览器自身执行的某种动作，页面和用户交互的瞬间，比如clcik等； 事件流概念 是从页面中接收事件的顺序，或者说是在页面中传播响应的顺序，是从里面向外面流的，还是从外面向里面流的。 dom事件流DOM事件流，就是事件发生的时候，dom树从目标元素到根元素，按照特定的顺序传播，路径上所有的节点都会接收到该事件；IE不支持dom事件流。 冒泡型事件流和捕获型事件流冒泡型事件流： 从特定的事件目标开始接收到事件，从树叶到树根传播。 比如从div》body&gt;html&gt;document，是大部分浏览器默认的方式 事件捕获型 从最不特定的事件目标开始传播到你意向的事件目标，和冒泡型是相反的。 DOM2级事件流规定事件发生时，包括三个阶段： 事件捕获阶段-处于目标阶段-冒泡阶段，只有在冒泡阶段，才会对事件做出响应。事件捕获阶段，从html到body就停止了。 IE和DOM事件流的区别 IE是冒泡，div-&gt;body-&gt;doucment DOM事件流：先事件捕获，再到目标元素，最后事件冒泡阶段响应事件，document -&gt; body -&gt; div -&gt; (click) -&gt; div -&gt; body -&gt; document 事件处理程序事件处理程序默认是采用了事件冒泡机制，如果想用事件捕获，可以这样设置：btn.addEventListener(“click”, function(){}, false); // 在冒泡阶段响应 用闭包的方式封装事件处理程序注意他们的参数不同 addEventListener的参数是type,handler,false 而IE是”on”+type,比如onclick回调函数handler的this指向和event事件对象不同 attachEvent事件中listener调用时，因为IE和chrome调用的方式不同，chrome调用时是将e作为参数传入进入的，el.onclcik = function (e) ; 而IE是var func = el.onclcik; func(); // IE事件没有传递event参数，且执行时this指向window对象，所以listener执行的时候，无法直接获取event事件对象，也无法让直接调用this = el， // 所以需要想办法将listener执行时获取window.event参数，且this指向el.onclick的el对象。 // 解决方法： function createEventRegister() { if (document.addEventListener) { return function(ele, type, eventHandler) { ele.addEventListener(type, eventHandler); } } else if (document.attachEvent) { return function(ele, type, eventHandler) { ele.attachEvent(&apos;on&apos; + type, function() { // 重点 eventHandler.call(ele, window.event); // 用call改变this指向为当前的事件函数，参数为当前的e对象 }) } } else { return function(ele, type, eventHandler) { ele[&apos;on&apos; + type] = eventHandler; } } } 事件委托/事件代理 利用事件冒泡的原理，把自己所触发的事件交给父元素（广义的，祖先元素）代替执行，可以解决： 1.可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒，因为每个函数都是对象，都会占用内存，内存的对象越多，性能就越差； 2.当父元素下面的子元素是动态生成的，那么原先绑定的方法在新添加的元素上就不适用了，可以利用事件代理，绑定在父元素上。 典型的例子是创建li的时候，如果是ul.innerHtml的方法创建的，新老的Li都没有方法了，如果是通过append方法添加，那么原来的Li有，新的Li 没有原来的方法了。 事件代理的封装一、给ul下面的每一个标签注册同样的事件： //parentEle是父元素dom元素，tag是子元素，可以用li的class名，&quot;.save&quot;， //或者是&apos;li&apos;tag标签 function delegate(parentEle, tag, event, listener) { parentEle.addEventListener(event, function(event) { event = event || window.event; var target = event.target || event.srcElement; if (target &amp;&amp; target.tagName === tag.toUpperCase()) { listener.call(target, event); //this指向target对象 } }) } //使用示例： delegate(ul, &apos;li&apos;, &apos;click&apos;, function() { alert(this.innerHTML); }) 二.给其中的某一个li标签注册事件 function delegate(parentEle, childId, event, eventHandler) { parentEle[&apos;on&apos; + event] = function(ev) { ev = ev || window.event; var target = event.target || event.srcElement; if (target &amp;&amp; target.id === childId) { eventHandler(); //或者 //eventHander.call(target, event); } } } //使用示例 delegate(ul, &quot;inner&quot;, &quot;click&quot;, function(){ alert(1); }) jQuery中的事件代理$(function(){ $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function(){ console.log(this); }) }) $(&quot;ul&quot;).on(&quot;click&quot;, &quot;a&quot;, function(e) { console.log(e.currentTarget); // jquery里面e事件对象包装了一层 }) 如何阻止事件冒泡和默认事件阻止事件冒泡 阻止事件冒泡,使成为捕获型事件触发机制.比如只希望点击事件发生在子元素身上，不希望发生在父元素身上 function stopBubble() { var e=arguments.callee.caller.arguments[0]||event; //如果提供了事件对象，则这是一个非IE浏览器 if ( e &amp;&amp; e.stopPropagation ) //因此它支持W3C的stopPropagation()方法 e.stopPropagation(); else { //否则，我们需要使用IE的方式来取消事件冒泡 window.event.cancelBubble = true; } } // 一般在IE环境下可以省略掉（var e=arguments.callee.caller.arguments[0]||event;） 直接运行即可，但是在FF下不行了，它会报e.stopPropagation没有定义，所以要事先定义，才能兼容。 阻止默认行为 当按键后,不希望按键继续传递给如HTML文本框对象时,可以取消返回值.即停止默认事件默认行为. //阻止浏览器的默认行为 function stopDefault( e ) { if ( e &amp;&amp; e.preventDefault ) { e.preventDefault(); //阻止默认浏览器动作(W3C) } else { window.event.returnValue = false; // IE中阻止函数器默认动作的方式 return false; } } 事件循环（Event Loop）和任务队列（Task Queue） JS 是单线程的，但是却能执行异步任务，这主要是因为 JS 中存在事件循环（Event Loop）和任务队列（Task Queue）。 事件循环 JS 会创建一个类似于 while (true) 的循环，每执行一次循环体的过程称之为 Tick。每次 Tick 的过程就是查看是否有待处理事件，如果有则取出相关事件及回调函数放入执行栈中由主线程执行。待处理的事件会存储在一个任务队列中，也就是每次 Tick 会查看任务队列中是否有需要执行的任务。 任务队列 异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。 onclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中。 setTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中。 ajax 则会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中。 主线程： JS 只有一个线程，称之为主线程。而事件循环是主线程中执行栈里的代码执行完毕之后，才开始执行的。 所以，主线程中要执行的代码时间过长，会阻塞事件循环的执行，也就会阻塞异步操作的执行。 只有当主线程中执行栈为空的时候（即同步代码执行完后），才会进行事件循环来观察要执行的事件回调，当事件循环检测到任务队列中有事件就取出相关回调放入执行栈中由主线程执行。 用示例来说明 例1： var req = new XMLHttpRequest(); req.open(&apos;GET&apos;, url); req.onload = function (){}; // 这两个异步方法就会在 ajax 完成后推入任务队列，再由主线程执行 req.onerror = function (){}; req.send(); 例2： setTimeout(function(){ // 如果有大量的操作，可能会阻塞 UI 等，则可以使用 setTimeout 让这些操作在主线程把更重要的代码执行完毕之后，再来执行这里的操作。从而提高浏览器的性能。 },0); // 设置为 0，也会有个最小间隔值，也会在主线程中的代码运行完成后，由事件循环从任务队列将回调添加到执行栈中才执行 例3： // 事件循环测试。执行结果是 2-3-4-1，1在最后输出，说明事件循环是所有同步代码执行完后才开始执行的。 &apos;use strict&apos;; setTimeout(function() { console.log(1); }, 0); console.log(2); let end = Date.now() + 1000*5; while (Date.now() &lt; end) { } console.log(3); end = Date.now() + 1000*5; while (Date.now() &lt; end) { } console.log(4); Update：《你不知道的 JavaScript》一书中，重新讲解了 ES6 新增的任务队列，和上面的任务队列略有不同，上面的任务队列书中称为事件队列。 上面提到的任务（事件）队列是在事件循环中的，事件循环每一次 tick 便执行上面所述的任务（事件）队列中的一个任务。而任务（事件）队列是只能往尾部添加任务。 而 ES6 中新增的任务队列是在事件循环之上的，事件循环每次 tick 后会查看 ES6 的任务队列中是否有任务要执行，也就是 ES6 的任务队列比事件循环中的任务（事件）队列优先级更高。 如 Promise 就使用了 ES6 的任务队列特性。 参考：http://www.cnblogs.com/Medeor/p/4945687.htmlhttp://www.ruanyifeng.com/blog/2014/10/event-loop.htmlhttp://www.cnblogs.com/zhaodongyu/p/3922961.html深入浅出 node.js 自定义事件http://www.cnblogs.com/xcmylrl/p/5405797.html 比较绕,留下来慢慢研究….]]></content>
      <categories>
        <category>Javascript</category>
        <category>事件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ajax基础]]></title>
    <url>%2F2015%2F06%2F01%2Fajax%E8%AF%B7%E6%B1%82get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[什么是表单提交 通过form表单把数据提交到后台怎么实现表单提交 get步骤: 前端: 1. 提交的地址 在form标签上写action属性 值代表要把input中的值传给哪个程序 2. 数据的保存 在input的标签上写name属性的值 3. 提交方式 在form标签上写method属性 现在有两种提交 get(默认的提交方式) post 后端接受 接受前端数据 用一个数组接受 先用$_GET数组(php中早就定义好的 内置数组) 用什么样的方式提交就用什么数组接受 post前端: 1.1 提交的地址 在form标签上写action属性 值代表要把input中的值传给哪个程序 1.2 数据的保存 在input的标签上写name属性 1.3 提交方式 在form标签上写method属性 必须显式声明提交方式post 后端接受: 1.4 接受前端数据 用一个数组接受 只能用$_POST 用什么样的方式提交就用什么数组接受 表单提交的方式get一般用于信息的获取，在地址栏里面里面用key=value&amp;key=value的方式传值（路径后面+？），因为参数都写在地址栏里面，暴露出来了，所以不安全， 而且地址栏里面传值是由数量限制的，http协议里没有限制，但是浏览器一般限制在2-8k。get请求在项目里用的比post请求要多. 但是get请求是有缓存的，这个发送ajax请求时候要注意，比如说我们需要发送验证码的请求给后台，每次发送的地址和参数都是一样的，浏览器就会直接从cache里面读取上一次的相应结果，如果你不对参数做处理，每次点验证码的图片都没有变化。 我比较常用的是在请求地址后面url? +freshTime=new Date().getTime(),用一个时间戳，每次都是不一样的get请求，或者是+Math.random() 另外get请求参数里面有中文的，浏览器会自动做编码， encodeURIComponent，看到的是%这种。 post提交主要是用于通过表单收集到数据，传到后台去修改数据库里面的数据时候使用。传递的数据放在请求体里面（ xmlHttp.send(name)），比较安全，而且没有数量大小的限制。 post请求不会被缓存 发送的时候，请求头里面要设置xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)，告诉服务器我传过来的是表单文件的普通类型，没有type=file的文件类型，用key=value来分隔的。如果是type=file,就需要设置成multipart/form-data 除了get post还有其他请求方式put delete 表单提交的特点1.表单提交会发生页面的跳转 2.如果后台运算数据较慢 浏览器要一直等待 什么是同步 什么是异步同步: 两个部分是互相依赖的 上一个步骤没有完成下一个步骤无法进行 异步: 故事: 小明问小强要钱 小明钱一定要要 现在小明家中有事(立马要回家) 找人(催债) 定义:两个部分没有依赖关系 省时 不会阻塞下面的部分运行 什么是ajax，缺点？ 是利用 XMLHttpRequest支持异步请求的技术，在不刷新整个页面的情况下，向服务器请求数据，服务器把数据返回来之后，通过对dom做操作，更新页面的局部视图。 发请求数据的时候，页面还是正常执行代码，不会因为后台没有返回数据，页面就停在当前的这一步。 缺点：只是局部刷新，点击back按钮是没有作用的。 为什么需要学习ajax ajax有哪些应用 1.ajax请求不需要跳转页面 2.ajax请求不需要表单 3.ajax请求不需要用户等待 即使等待也有良好的用户体验 4.局部刷新页面 ajax有哪些应用 1.瀑布流页面的加载 2.分页 3.动态请求数据 4.百度搜索 怎么实现ajaxhttp协议 http协议请求信息 分为那三部分 请求行 请求方式 请求地址 请求头 Content-Type:application/x-www-form-urlencoded; 请求正文 格式:key=value&amp;key=vaule 实现一个js的ajax请求 //1.实例化对象 var xhr = new XMLHttpRequest(); //2.xhr.readyState == 0,表示已经实例化，但是Open方法还没有调用 //3.设置请求行 xhr.open(&apos;get&apos;, url); //4.如果是post需要设置请求头 xhr.serRequestHeader(&apos;contentType&apos;, &apos;application/x-www-form-urlencoded&apos;);// //5.设置请求正文 格式：key=value&amp;key=value xhr.send(&apos;username=wanl&amp;password=1234&apos;); //如果是get方法，可以设置send(null) //xhr.readyState == 1代表设置了请求头，也发送了请求正文，但还没有收到内容 //xhr.seng(null); //6.监听并响应 xhr.onreadystatechange = function() { //xhr.readyState == 4代表收到一个响应，但是不知道是否成功， if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.reponseText); //或者200 &lt;= xhr.ready &lt;= 300 || xhr.status == 304 //表示已有缓存 } }]]></content>
      <categories>
        <category>Javascript</category>
        <category>ajax</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js基础知识学习]]></title>
    <url>%2F2015%2F05%2F28%2Fjs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[js基础知识typeof 关键字 返回的数据类型（5种基本数据类型） &apos;undefined&apos; &apos;null&apos; &apos;string&apos; &apos;number&apos; // typeof NaN === &apos;number&apos; &apos;boolean&apos; &apos;object&apos; &apos;function&apos; &apos;symbol&apos; // typeof Symbol(&apos;foo&apos;) === &apos;symbol&apos; Objects类型 typeof {a: 1} === &apos;object&apos;; typeof [1, 2, 4] === &apos;object&apos;; typeof new Date() === &apos;object&apos;; ==和===的区别 “==”是判断值是否相等，会先进行类型转换,不想等是(!=) ‘===’是判断类型和值是否完全相等 他们返回的都是布尔值 判断方法： ===： 1.如果两个值的类型不相同，就不相同； 2.如果两个值都是字符串，而且字符串里面同一个位置上的字符完全相同， 那么他们就完全等同，如果字符串的长度或内容不同，他们就不是等同的。 3.如果两个值都是布尔类型的true，或者是布尔类型的false，那么等同 4.如果两个值都是null或undefined,他们完全相同。 ==：两个值的类型不同，仍然可能相等 1.两个值一个null，一个是undefined,相等； 2.如果一个值是数字，另一个值是字符串，把字符串转化为数字， 再用转换后的值进行比较。 3.如果一个值是1，转true,两一个值是false，转化为0,再进行比较。 4. 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。如果valueOf()返回的值还是对象，就调用toString()方法再进行比较。 // toString()得到的是&apos;[object Object]&apos;的字符串 NaN == NaN // false null == undefined // ture undefined == 0 // false null == 0 // false {} == !{} // false [] == ![] // true // https://www.zhihu.com/question/29615998 解析： 1.![] == false,空数组是对象，对象为true,取反为false. 2.一个数组对象和一个布尔值进行比较，先把布尔值转化为数字，ToNumber(false),结果是[] == 0 3.因为按照一个对象和一个字符串或布尔值进行比较的规则，除了日期内只是用toString()方法，其他的会先使用valueOf()方法，转化为原始值，[].valueOf()，返回[]，需要调用toString(),返回&quot;&quot;空字符串 4.空字符串和0是相等的，所以结果是true 判断两个对象相等 JSON.stringify(obj_a) === JSON.stringify(obj_b); 2.underscore.js有isEqual方法： https://github.com/jashkenas/underscore/blob/master/underscore.js#L1112-1208 用法文档：http://underscorejs.org/#isEqual 3.进行递归比较判断 function isEqual(a, b) { // 判断是否是数值的情况 if (typeof a == &apos;number&apos; &amp;&amp; typeof b == &apos;number&apos;) { return a == b } // 判断是对象的情况 if (isObject(a) &amp;&amp; isObject(b)) { var aProps = object.getOwnPropertyNames(a); var bProps = object.getOwnPropertyNames(b); if (aProps.length != bProps.length) { return false; } // 遍历a的属性 for (var i = 0; i &lt; aProps.length; i++) { var propName = aProps[i]; if(Object.prototype.toString(a[propName]) == &apos;[Object Object]&apos;||Object.prototype.toString(b[propName]) == &apos;[Object Object]&apos;){ isObjectValueEqual(a[propName],b[propName]) } if (a[propName] !== b[propName]) { return false; } } return true; } } function isObject(arr) { return Object.prototype.toString.call(arr) === &apos;[object Object]&apos;; } 判断对象是否为空思路一是for in 进行遍历 function isEmpty(obj) { for (var i in obj) { return true; } else { return false; } } // 思路二：序列化 if (JSON.stringify(obj) == &apos;{}&apos;) { return false; } // 思路三：es6方法： if（Object.keys(obj).length == 0） { return true; } else { return false; } 比较两个json对象是否完全相等 思路是判断这两个对象是不是类型一样的，并且属性是不是也是对象类型的，然后如果是数组，判断长度，判断数组的值，如果是对象，判断长度，判断属性值，递归判断 // 首先判断是不是对象类型的，是否是数组类型的，获取长度 function isObj(obj) { return object &amp;&amp; typeof (obj) == &apos;object&apos; &amp;&amp; Object.prototype.toString.call(obj).toLowerCase() == &quot;[object object]&quot;; } function isArray(ob) { return object &amp;&amp; typeof (obj) == &apos;object&apos; &amp;&amp; obj.constructor == Array; } function getLength(object) { var count = 0; for (var i in object) count++; return count; } function Compare(objA, objB) { if (!isObj(objA) || !isObj(objB)) return false; //判断类型是否正确 if (getLength(objA) != getLength(objB)) return false; //判断长度是否一致 return CompareObj(objA, objB, true); //默认为true } function CompareObj(objA, objB, flag) { for (var key in objA) { if (!flag) //跳出整个循环 break; if (!objB.hasOwnProperty(key)) { flag = false; break; } if (!isArray(objA[key])) { //子级不是数组时,比较属性值 if (objB[key] != objA[key]) { flag = false; break; } } else { if (!isArray(objB[key])) { flag = false; break; } var oA = objA[key], oB = objB[key]; if (oA.length != oB.length) { flag = false; break; } for (var k in oA) { if (!flag) //这里跳出循环是为了不让递归继续 break; flag = CompareObj(oA[k], oB[k], flag); } } } return flag; } 判断json对象是否为空1.jquery方法： jQuery.isEmptyObject({})； 2.for in遍历 交换两个变量的值1.借助第三方： var temp = a; a = b; b = temp 2.不借助第三方： 数字型可以直接运算 var a = 1, b = 5; a = a + b; // 将a、b的值都放在a里面，a = 6 b = a - b; // a的值 - b的值就是原来的a的值了 a = a - b; // a还是相加之后的a，b是已经交换后的b， a - b就是相加的值 - a的值，就是b的值 // 对象存储的方法： a = {a:b, b:a} b = a.b; a = a.a // 数组存储的方法： a = [a, b]; b = a[0]; a = a[1] // 变态的一行代码： a = [b, b=a][0] 解析：运算符优先级，首先b = a,然后a = b Math对象是js的内置对象 Math.max（a, b, c） // 返回最大值Math.min() // 返回最小值 舍入： Math.ceil() // 向上舍入 Math.floor() // 向下舍入 Math.round() // 四舍五入 其他 Math.abs(num) // 绝对值 Math.exp(num) // num次幂 Math.pow(num, power) number的power次幂 随机数Math.random() ：返回0-1之间的随机数，不包括1 Math.random()应用 1.用js实现随机选取10-100之间的10个数字，存入一个数组，并排序。 /** 思路：1.取10个数字，不重复; 2.数组[0,100] **/ var arr=[]; for (i = 0; i &lt; 10; i++) { var index = Math.random(); var j = 10 + Math.floor(91 * index); // 取值范围 if(arr.indexOf(j) == -1){ arr.push(j); } else { i--; // 数组有这一项了，不取原数组的这个值， 但是次数要退回一次，保证取够10个数 } } arr.sort(campare); function campare(a,b) { // 降序 return a-b; } console.log(arr); 或者：用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。 var iArray = []; funtion getRandom(istart, iend) { var iChoice = istart - iend + 1; return Math.floor(Math.random() * iChoice + istart; } for (var i = 0; i &lt; 10; i++) { iArray.push(getRandom(10, 100)); } iArray.sort(); 2.有一个数组，a = [8, 10, 30, 55, 78, 90, 1],b从A中一次随机取一个元素，取完为止 /** * Math.random是[0, 1)； [0, 7) Math.ceil(Math.random*a.length) 第一次随机数的范围是0-6； 第二次随机数的范围时0-5； 第三次随机数的范围是0-4； 第四次随机数的范围是0-3； 第五次随机数的范围是0-2； * */ var b = []; var a = [8, 10, 30, 55, 78, 90, 1]; for(var i = 0; i &lt; 7; i++) { var key = Math.floor(Math.random()*(a.length)); b.push(a[key]); a.splice(key,1); // a里面删除这一项 } console.log(b); 3.数组顺序打乱，随机返回一个数组 export function shuffle (arr) { let _arr = arr.slice() // 从0-i之间去取一个数，取一个索引， 将这个索引和arr[i]作交换 for (let i = 0; i &lt; _arr.length; i++) { let j = getRandomInt(0, i) // 临时交换 let t = _arr[i] _arr[i] = _arr[j] _arr[j] = t } return arr } // 返回min到max之间的一个随机数，包括max function getRandomInt (min, max) { return Math.floor(Math.random() * (max - min + 1) + min) } 日期对象1、创建实例： var data = new Date(); var date = Date.now() date.getFullYear() // 获取年份 getMonth() // 从0开始计算，获得的比实际少1个月，需要+1 getDate() // 获取月份中的天数 getDay() // 0 表示星期天 getHours()/getMinutes()/getSeconds() getTime() // 返回时间的毫秒数 写一个函数传过来一个日期对象，返回yyyy-MM-dd HH:mm:ss形式的字符串 //2015-3-01 15:02:03 /** * 定义了输出当前字符串时间的一个函数 * @param date */ function getDate(date) { var year = date.getFullYear(); var month = date.getMonth() + 1; // 月份是从0开始 var day = date.getDate();//获取的是当月的几号 var hour = date.getHours(); var min = date.getMinutes(); var sec = date.getSeconds(); // if(month&lt;10){ // month= &quot;0&quot;+month; // }else { // month = month; // } month = month &lt; 10 ? &quot;0&quot; + month : month; day = day &lt; 10 ? &quot;0&quot; + day : day; hour = hour &lt; 10 ? &quot;0&quot; + hour : hour; min = min &lt; 10 ? &quot;0&quot; + min : min; sec = sec &lt; 10 ? &quot;0&quot; + sec : sec; var str = year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + min + &quot;:&quot; + sec; console.log(str); } var date = new Date(); getDate(date); // 把创建的date作为参数传进来 BOM对象 document.getElementById(&quot;btn&quot;).onclick = function (){ console.log(window.location.hash); // 获取地址栏中#后面的字符串 console.log(window.location.host); // 主机名和端口号 console.log(window.location.hostname); // 主机名 console.log(window.location.pathname);// 路径 console.log(window.location.port);// 端口号 console.log(window.location.protocol);// 协议 console.log(window.location.search); //？后面的字符串 }; document.getElementById(&quot;btnHref&quot;).onclick = function (){ // window.location.href = &quot;http://www.baidu.com&quot;; location.reload(true); // 刷新 // true 表示强制刷新强制加载 ，就是得到服务器去重新请求数据 // false 是从本地读取缓存 }; dom获取当前元素的子节点// 1. 获得对象 var list = document.getElementById(&quot;list&quot;); var lis = list.childNodes; // 获取当前元素的子节点 不但会获得子标签节点，还会获得文本节点及注释节点 var lis1 = list.children; // 只会获得当前元素下面的子标签节点 节点类型 // nodeType nodeName nodeValue /* * 标签 1 对应的标签名 null * 属性 2 属性名 属性值 * 文本 3 #text 文本内容 * 注释 8 #comment 注释的内容 * */ var box = document.getElementById(&quot;box&quot;); // var node = box.getAttributeNode(&quot;class&quot;); var node = box.getAttributeNode(&quot;id&quot;); console.log(node.nodeType); console.log(node.nodeName); console.log(node.nodeValue); 获取兄弟节点 nextSibling 获得下一个相邻的兄弟姊妹级节点，有可能是文本，注释或是标签,IE8以前的浏览器会忽略空白文本节点，只会获得下一个标签节点，或是注释节点 nextElementSibling 高级浏览器支持的方式，只会获得下一个标签节点 文本和注释都会忽略，而IE8及之前的浏览器不支持此属性 封装一个兼容的获取下一个兄弟节点的方法 /** * 封装了一个兼容版本的获取下一个标签对象的函数 * @param ele * @returns {*} */ function getNextElement(ele){ if(ele&amp;&amp;ele.nextElementSibling){ //有对象，而且支持nextElementSibling的方式获取下一个标签对象 return ele.nextElementSibling; }else { ele = ele.nextSibling; while(ele&amp;&amp;ele.nodeType!=1){ ele = ele.nextSibling; } return ele; //返回获取到的下一个标签对象 } } 获取上一个兄弟节点 previousSibling 高级浏览器不但会获得标签节点，还会获得文本节点和注释节点 ，而IE8浏览器会忽略空白 文本节点，如果有注释会获取注释节点 previousElementSibling 高级浏览器支持的方式，只会获得上一个标签节点，文本啊注释都会忽略 封装兼容方法 function getPreviousElement(ele){ if(ele&amp;&amp;ele.previousElementSibling){ return ele.previousElementSibling; }else { if(ele){ ele = ele.previousSibling;//获得上一个节点 while(ele&amp;&amp;ele.nodeType!=1){ ele= ele.previousSibling; } return ele; } } } 获取子节点var node = list.firstChild; // 高级浏览不但会获得标签节点还会获得文本节点及注释节点 var node = list.firstElementChild; //是高级浏览器支持的方式，只会获得标签节点，但是IE8及之前的浏览器不支持 封装兼容性方法 function getFirstChild(ele){ if(ele&amp;&amp;ele.firstElementChild){ return ele.firstElementChild; }else { if(ele){ ele = ele.firstChild; //在当前节点的基础上，获取第一个子节点(标签，文本，注释) while(ele&amp;&amp;ele.nodeType!=1){ ele = ele.nextSibling;// 在当前节点的基础上，继续往下找 } return ele; } } } 最后一个子节点 function getLastChild(ele){ if(ele&amp;&amp;ele.lastElementChild){ //高级浏览器支持的方式 return ele.lastElementChild; }else { //IE8及之前的浏览器支持的方式 ele = ele.lastChild; while(ele&amp;&amp;ele.nodeType!=1){ ele = ele.previousSibling;//在当前标签基础上，往前找兄弟姊妹级节点 } return ele; } } offset offsetWidth和offsetHeight：检测盒子的宽和高。 offsetWidth = width + border + padding ;获取的值为number类型，不带单位 offsetTop和offsetLeft：(absolute/relative/fixed)1.检测盒子距离父系盒子中带有定位的最近的盒子的距离。2.如果都没有默认为距离body的距离 offsetParent: 父系盒子中最近的带有定位的盒子。如果都没有默认是body 用div.style.left赋值。 2.用div.offsetLeft获取值 利用offset封装动画动画的原理：原来的位置 + 步长，利用setInterval定时器，间隔一段时间执行 匀速动画封装 //匀速动画封装 function animate(ele,target) { //要用定时器，先清定时器。 clearInterval(ele.timer);//一个盒子，一个定时器。想回不会产生影响 //把定时器绑定到盒子上。(一个盒子，一个定时器。) ele.timer = setInterval(function () { //步长的处理：步长不能永远都是10； var step = target &gt; ele.offsetLeft? 10 : -10; ele.style.left = ele.offsetLeft + step + &quot;px&quot;; //停下来：目标位置和当前位置只差不足一个步长的时候 //抖动问题； &lt;后面加= if(Math.abs(target-ele.offsetLeft) &lt;= Math.abs(step)){ ele.style.left = target + &quot;px&quot;; clearInterval(ele.timer); } },30); } // 使用方法： btn.onclick = function () { fn(div, 200) } 缓动动画封装 btn.onclick = function () { animate(div,400.75); } //封装一个方法。 解决定时器问题。 function animate(ele,target) { //: 要用定时器，先清定时器 clearInterval(ele.timer); //设置定时器移动盒子。 ele.timer = setInterval(function () { //动画原理 = 盒子本身位置 + (目标位置-当前位置)/10; //获取步长。 var step = (target-ele.offsetLeft)/10; //要解决小数问题，步长就不能为小数。要求盒子最小步长为1； //二次处理步长。如果步长&gt;0，向上取整。 如果步长&lt;0，向下取整。(目标位置是在当前位置之前还是之后) step = step&gt;0? Math.ceil(step):Math.floor(step); //赋值 ele.style.left = ele.offsetLeft + step + &quot;px&quot;; console.log(1); //什么时候清除定时器??? //如果目标位置和当前位置之差不足一个步长的时候 if(Math.abs(target-ele.offsetLeft) &lt;= Math.abs(step)){ 直接让盒子移动到目标位置 ele.style.left = target + &quot;px&quot;; clearInterval(ele.timer); } },30); } 但是以上方法有两个不足： 1.在获取属性值的时候不够精确。(是检测后期值，有的甚至无法获取) 解决办法：引入新的技术。(可以获取内嵌/外链/行内三种属性值。最高权限的属性值) //1.火狐谷歌ie9+以上：支持window.getComputedStyle(); var objStyle = window.getComputedStyle(div,null); //2.IE678支持的是：div.currentStyle var objStyle = div.currentStyle; 所以也需要封装兼容性写法 //兼容写法：//两个参数，一个是哪个盒子的样式，什么属性。 function getStyle(ele,attr){ //判断：看浏览器支持哪个方法。 if(window.getComputedStyle !== undefined){ //或者if(window.getComputedStyle &amp;&amp; typeof window.getComputedStyle === &quot;function&quot;){ return window.getComputedStyle(ele,null)[attr]; }else{ //ie678才能到这里。 return ele.currentStyle[attr]; } //简单方法： return window.getComputedStyle!==undefined?window.getComputedStyle(ele,null)[attr]:ele.currentStyle[attr]; } 2.只能每次修改一个属性，不能一把一把的操作。 解决办法：利用对象(json);(利用for…in…变量这个对象) 最后的缓动动画封装方法： //封装缓动动画 function animate(ele,json,fn){ //要用定时器，先清定时器 clearInterval(ele.timer); ele.timer = setInterval(function () { //整体的代码用json来做，用for...in...循环来做。 //1.把原来的attr,变成for...in...中的 k; //2.把原来的target,变成for...in...中的 值：json[k]; //默认所有人都到了目标位置。(开闭原则) var flag = true; for(var k in json){ //k;//json中的每一个属性。 //json[k];//json中的每一个属性对应的值。 //不必停止定时器 //0.获取盒子当前最高权限的属性值,要转换成number类型。 var leader = parseFloat(getStyle(ele,k)) || 0; //1.获取步长 var step = (json[k]-leader)/10; //2.二次处理步长 step = step&gt;0?Math.ceil(step):Math.floor(step); //3.赋值 leader += step; ele.style[k] = leader + &quot;px&quot;; //要求：必须所有属性都到达指定位置，才能清除定时器。 //没到的举手，只要没到就不走。(如果所有人都不说话，那么就全都到了) //有一个没有到达目标位置的也不能清除定时器 // if(Math.abs(json[k]-leader) &gt; Math.abs(step)){ if(json[k] !== leader){ flag = false; } } console.log(1); //for循环之外： //整轮for循环执行完毕之后，只要判断：flag的值是true，还是false。 //如果是true。说明所有属性都到达指定值。 //如果是false。说明至少还有一个属性未到达指定值。 if(flag){ clearInterval(ele.timer); //本函数走完了，在调用回调函数：规则就是，你完成我在执行 //bug:如果传递了函数，就调用，没有传递就不调用 // if(fn &amp;&amp; typeof(fn) === &quot;function&quot;){//严谨 if(fn){ fn(); } } },30); } //精确获取单个元素的某个最高权限属性值。 function getStyle(ele,attr){ if(window.getComputedStyle !== undefined){ return window.getComputedStyle(ele,null)[attr]; }else{ return ele.currentStyle[attr]; } } 使用方法：一个动画有多种效果，并且是前一个执行完，再执行后一个 btn.onclick = function () { //转一个圈。 --- 后面的animate()会把前面的方法种的定时器清除。 var json1 = {left:400}; var json2 = {top:440}; var json3 = {left:0}; var json4 = {top:40}; //解决办法：第一个走完了，在走第二个.... //定时器被清除的时候，就是一个函数走完的时候。 animate(div,json1, function () { animate(div,json2, function () { animate(div,json3, function () { animate(div,json4); }); }); }); } 动画原理： 盒子本身的位置 + （目标位置-当前位置） / 10 div.style.left = div.offsetLeft + (400 - div.offsetLeft)/10 + &quot;px&quot;; 但是上面的封装还是存在一定问题，当遇到层级和透明度的设置的时候，不能一样的设置： btn.onclick = function () { //转一个圈。 --- 后面的animate()会把前面的方法种的定时器清除。 var json1 = {&quot;z-index&quot;:5,opacity:0.4}; //z-index(直接赋值),opacity(没有单位，小数); border和background-color和color... //jQuery都没有完成所有属性，全部兼容。backgorund-color：都不支持 //我们只做两：z-index和opacity？ 因为旋转木马需要； //1.z-index特别简单。 2.opacity(没有单位，小数，兼容) //解决办法：第一个走完了，在走第二个.... //定时器被清除的时候，就是一个函数走完的时候。 animate(div,json1); } //封装缓动动画 function animate(ele,json,fn){ //要用定时器，先清定时器 clearInterval(ele.timer); ele.timer = setInterval(function () { //默认所有人都到了目标位置。(开闭原则) var flag = true; for(var k in json){ //在for循环中进行属性判断：如果是哪个属性，就进行哪个属性的逻辑 if(k === &quot;z-index&quot;){ //层级：需求：点击一下，直接到达(层级不需要缓动到目标值) ele.style.zIndex = json[k];//层级不管定时器 }else if(k === &quot;opacity&quot;){//透明度 //0.获取值的时候放大10倍，赋值在缩小10倍(方便步长运算)。 1.小数运算容易出现精度丢失问题。 if(parseInt(getStyle(ele,k)*100) === 0){ var leader = 0; }else{ var leader = parseInt(getStyle(ele,k)*100) || 100; } //1.获取步长(传递的目标值为多少) var step = (parseInt(json[k]*100)-leader)/10; //2.二次处理步长 step = step&gt;0?Math.ceil(step):Math.floor(step); //3.赋值 leader += step; //赋值opacity的时候注意缩小10倍,没有单位 ele.style.opacity = leader/100; //兼容ie678 ele.style.filter = &quot;alpha(opacity=&quot;+leader+&quot;)&quot;; //有一个没有到达目标位置的也不能清除定时器 if(parseInt(json[k]*100) !== leader){ flag = false; } }else{//普通属性。 //0.获取盒子当前最高权限的属性值,要转换成number类型。 var leader = parseFloat(getStyle(ele,k)) || 0; //1.获取步长 var step = (json[k]-leader)/10; //2.二次处理步长 step = step&gt;0?Math.ceil(step):Math.floor(step); //3.赋值 leader += step; ele.style[k] = leader + &quot;px&quot;; //有一个没有到达目标位置的也不能清除定时器 if(json[k] !== leader){ flag = false; } } } console.log(1); //整轮for循环执行完毕之后，只要判断：flag的值是true，还是false。 if(flag){ clearInterval(ele.timer); //本函数走完了，在调用回调函数：规则就是，你完成我在执行 if(fn){ fn(); } } },30); } //精确获取单个元素的某个最高权限属性值。 function getStyle(ele,attr){ if(window.getComputedStyle !== undefined){ return window.getComputedStyle(ele,null)[attr]; }else{ return ele.currentStyle[attr]; } } scroll window.onscroll = function () {} // 页面滚动中处理事件 document.body.scrollTop; // 网页被遮住的顶部值 有兼容性 (1).谷歌只支持 document.body.scrollTop; (2).IE5678只支持 document.documentElement.scrollTop; (3).正常浏览器支持：是否拥有dtd约束。没有：body。有：documentElement。 w3cshool: window.pageY/XOffset; 获取页面顶部被遮挡住的部分的距离: 缺点在于ie678不支持。 兼容性封装 //封装获取页面被圈去的头部和左侧部分的距离。 function scroll(){ return { &quot;top&quot;: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop, &quot;left&quot;: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft }; } event event.pageX //光标相对于该网页的水平位置（ie无） event.pageY //光标相对于该网页的垂直位置（ie无） event.clientX //光标相对于该网页的水平位置 （当前可见区域） event.clientY //光标相对于该网页的垂直位置 鼠标位于整个页面的距离(event.pageY/X) = 页面被卷去的头部或者左侧部分( scroll().left/top ) + 鼠标距离网页可视区域的距离(event.clientX/Y) var pagey = event.pageY || scroll().top + event.clientY; var pagex = event.pageX || scroll().left + event.clientX; function scroll(){ return { top: window.pageYOffset || document.documentElement.scrollTop, left:window.pageXOffset || document.documentElement.scrollLeft } }]]></content>
      <categories>
        <category>Javascript</category>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用css样式设置技巧]]></title>
    <url>%2F2015%2F05%2F23%2F%E5%B8%B8%E7%94%A8css%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[图标字体的用法 先制作，下载图标 引入css样式 @font-face {font-family: 'iconfont'; src: url('font/iconfont.eot'); /* IE9*/ src: url('font/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('font/iconfont.woff') format('woff'), /* chrome、firefox */ url('font/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url('font/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */ } .icon { font-family: "iconfont"; font-size: 30px; color:red; } -html文件编写 &lt;span class=&quot;icon&quot;&gt;&amp;#xe650;&lt;/span&gt; 边框设置负margin的用法达到的效果是鼠标滑过的时候当前div带边框显示，没有滑过的时候也有上下左右边框 本质就是需要设置一个负边框，否则就会有双边框效果 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *{ margin:0; padding:0; } div { width: 200px; height: 500px; border: 10px solid blue; float: left; position:relative; } .box { margin-left: -10px; } div:hover { position:relative; /*只有定位的元素才有层级，高于浮动和标准流*/ border-color: red; z-index:1; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div &gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 小三角的做法思路：设置boder宽度，然后其中三个边的border的颜色是透明的 div { width: 0; height: 0; border: 20px; /*border-color: red blue pink purple;*/ /*border-color: red transparent transparent transparent;*/ border-color: transparent transparent pink transparent; border-style: solid ; } 不规则图形的做法效果图： div { width: 0; height: 0; border-style: solid; border-color: #E01121 #E01121 #fff; border-width:10px 20px; }]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css布局总结]]></title>
    <url>%2F2015%2F05%2F20%2Fcss%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、两列布局写移动端项目的时候，经常遇到左边或右边是图片，需要固定宽度，中间自适应，是图片的内容介绍，需要垂直居中，且和两边高度对齐，这个时候用flex布局比较好，总结了两种比较常用的方法： 第一种：flex左边宽度固定，右边自适应/*父元素*/ .father { display: flex; } /*左边子元素*/ .left { flex: 0 0 30px; width: 30px; } .right { flex: 1; } 第二种：positon定位和padding-left用100%宽的一个div用paading-left把左边图片的位置留出来，图片绝对定位到padding-left区域 例如一个列表项，每一个item下面左边是图片，右边是说明 二、三列布局左侧和右侧固定，中间自适应 1.设置第一个DIV左浮动，第二个DIV右浮动，第三个DIV设置左右MARGIN为两个DIV的固定宽度 #box1 { float: left; width: 300px; background-color: #0099cc; } #box2 { float: right; width: 300px; background-color: #cc6600; } #box3 { height: 500px; background-color: #c30230; margin-left: 300px; margin-right: 300px; } &lt;div id=&quot;box1&quot;&gt;这是div1&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;这是div2&lt;/div&gt; &lt;div id=&quot;box3&quot;&gt;这是div3&lt;/div&gt; 2.父元素宽度100%，相对定位，左右子元素绝对定位，中间子元素设置margin-left和margin-right #wrapper { position: relative; width: 100%; } #box1 { position: absolute; top: 0; left: 0; width: 300px; height: 300px; background-color: #0099cc; } #box2 { height: 400px; margin-left: 300px; margin-right: 300px; background-color: #cc6600; } #box3 { position: absolute; top: 0; right: 0; width: 300px; height: 300px; background-color: #c30230; } 三、多列布局要横向排列的子元素设置float:left或者是display:inline-block,并且设置父元素的font-size为0 经典圣杯布局和淘宝双飞翼布局实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，也就是我们常说的固比固布局页面的宽度的变化，三栏布局是中间盒子优先渲染，两边的盒子框子固定不变 圣杯布局&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;h4&gt;中间弹性区&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;h4&gt;左边栏&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;h4&gt;右边栏&lt;/h4&gt;&lt;/div&gt; &lt;/div&gt; /*middle放在第一个，先渲染，宽度100%*/ .container{ padding: 0 200px; 左右盒子的宽度 height:200px; overflow:hidden; } .middle{ width: 100%; height: 200px; float:left; } .left{ position: relative; left: -200px width: 200px; height: 200px; float:left; margin-left: -100%; // 设置左边盒子负边距为中间盒子的宽度，即100%，可以在中间盒子的左边 } .right{ position: relative; //重点 right: -210px // 重点 width: 200px; height: 200px; float:left; margin-left: -200px; // 关键，这样才能在最右边 } 淘宝的双飞翼布局 淘宝的双飞翼布局是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。 &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inside&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; #middle{ float:left; width:100%;/*左栏上去到第一行*/ height:100px; } #left { float:left; width:180px; height:100px; margin-left:-100%; // 本来在第二行，此时上去到第一行 } #right{ float:left; width:200px; height:100px; margin-left:-200px; // 本来在第二行，此时到第一行 } /*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/ #inside{ margin:0 200px 0 180px; height:100px; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现垂直居中的方法]]></title>
    <url>%2F2015%2F05%2F12%2Fcss%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[不定宽高的子元素垂直水平居中的方法项目里面写静态页面的时候，多次自适应宽高的子元素需要设置垂直水平居中的方法，总结了一下，主要是利用css3的translate和flex两种方法 示例： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;con&quot;&gt;&lt;/div&gt; /div&gt; 第一种：css3的translate方法// 父元素 .box { position: relative; width: 500px; height: 300px; background-color: red; } // 子元素 .con { position: absolute; width: 20%; height: 50%; /*不定宽高*/ left: 50%; /*先移动父元素的50%*/ top: 50%; transform: translate(-50%, -50%); /*移动自身的50%*/ background-color: #000; } 第二种：flex方法.box { display: flex; justify-content: center; /*块居中对齐*/ align-items: center; /*块垂直居中*/ width: 300px; height: 300px; background-color: red; } .con { width: 30%; height: 40%; background-color: #000; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串方法]]></title>
    <url>%2F2015%2F04%2F28%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[length属性str.length 方法split将字符串转化成数组方法 var str = &quot;1, 2, 3, 4, 5, 6, 7, 12, 13, 15, 34, 56&quot;; var str1 = str.split(&quot;,&quot;); var str2 = str1.map(Number); // 或者： function list() { return Array.prototype.slice.call(arguments);} var list1 = list(1, 2, 3); // [1, 2, 3] charAt()strObj.charAt(index); //index是字符在字符串的下标，返回的是下标对应的字符 replace()strObj.replace(reg|substr, repaceStr); var str = &apos;Hello World&apos;; str.replace(&apos;World&apos;, &apos;beijig&apos;); concat（）字符串拼接方法 slice//2.字符串截取。 //(1). 字符串.slice(索引值，索引值); 根据索引值截取字符。 console.log(str3.slice(2,4)); //包括左边不包括右边 console.log(str3.slice(2)); //截取到最后 console.log(str3.slice(-2)); //最后几个 console.log(str3.slice(4,2)); //&quot;&quot; //(2). 字符串.substr(索引值，个数); 根据索引值和个数截取字符串 // console.log(str3.substr(2,4)); //从索引值为2的截取4个。 // console.log(str3.substr(2)); //截取到最后 // console.log(str3.substr(-2)); //最后几个 //(3). 字符串.substring(索引值，索引值); 和slice差不多。 console.log(str3.substring(2,4)); //包括左边不包括右边 console.log(str3.substring(2)); //截取到最后 console.log(str3.substring(-2)); //从头截取到最后 console.log(str3.substring(4,2)); //cx 特殊方法// trim() //只能去除字符串前后的空白: 不兼容ie678 // var str = &quot; aaa bbb ccc &quot;; // console.log(str); // console.log(str.trim()); // replace() //替换 // var str = &quot;aaaBBBAAACCCaaa&quot;; // // console.log(str); // console.log(str.replace(&quot;aaa&quot;,&quot;xxx&quot;)); // console.log(str.replace(/aaa/ig,&quot;xxx&quot;)); // split() //字符串变数组 join();数组转换成字符串。 // var str = &quot;关羽|张飞|刘备&quot;; // // console.log(str.split());//整个字符串做一个元素 // console.log(str.split(&quot;&quot;));//字符串中每一个元素都被单一分隔 // console.log(str.split(&quot;|&quot;));//分隔符不会出现在数组中。 // console.log(str.split(&quot;,&quot;));//找不到会：整个字符串做一个元素 // console.log(str.split(&quot;张飞&quot;));//找不到会：整个字符串做一个元素 //localeCompare(); 包含。 // console.log(&quot;abcdefg&quot;.localeCompare(&quot;abc&quot;));//包含。1 // console.log(&quot;abcdefg&quot;.localeCompare(&quot;abcdefg&quot;));//相等。0 // console.log(&quot;abcdefg&quot;.localeCompare(&quot;abcdefgadfasdf&quot;));//多余。-1 // console.log(&quot;abcdefg&quot;.localeCompare(&quot;zzxcv&quot;));//不存在。-1 // console.log(&quot;abcdefg&quot;.localeCompare(&quot;ace&quot;));//不完整。-1 // console.log(&quot;abcdefg&quot;.localeCompare(&quot;&quot;));//任何字符串都可以看成“”为开头。-1 //String.fromCharCode(Unicode编码); 编码转换成字符串 // console.log(String.fromCharCode(48,49,50,65,66,67,97,98,99,25105)); indexOf查找一个字符串中出现最多的字符的次数&lt;script&gt; // 对象的属性具有唯一性（有则覆盖），可以用来储存数据 // 举例1：//判断一个字符串中出现最多的字符，统计这个次数 var str = &apos;ababkhkkhljlksiuisrjflsdfaagjh&apos;; var obj = {}; for (var i = 0; i &lt; str.length; i++) { // charAt(0)第一个字符 var k = str.charAt(i); if (k in obj) { // 如果这个字符在obj里面有了 obj[k] ++ // 如果有，次数+1 } else { obj[k] = 1 // 如果找不到这个字符，就将该字符添加到对象助攻，并记录次数为1 } } console.log(obj) var arr = []; for (var k in obj) { arr.push(obj[k]); //将每个字符出现的次数放入到数组 } console.log(arr) console.log(Math.max.apply(Math, arr)); // 遍历对象，找到出现次数最多的字符的次数 var max = 0; for (var k in obj) { if(obj[k] &gt; max) { max = obj[k]; } } // 解决出现最多的字符有多个的情况 for (var k in obj) { if (obj[k] == max) { console.log(&apos;最多的字符&apos; + k); console.log(&apos;最多的个数&apos; + obj[k]) } } &lt;/script 字符串编码解码及大小写//1.encodeURIComponent(字符串); 转码 //2.decodeURIComponent(字符串); 解码 var url = &quot;http://www.itcast.cn?username=&apos;aaa&apos;&amp;password=&apos;123&apos;&quot;; console.log(url); var str = encodeURIComponent(url); console.log(str); var aaa = decodeURIComponent(str); console.log(aaa); //3.大小写转换 var str2 = &quot;aaaBBBccc你好123&quot;; console.log(str2.toLowerCase());//只负责字母，不管数字和符号 console.log(str2.toUpperCase());//只负责字母，不管数字和符号 给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如： addSpace(“Hello World”) // -&gt; ‘h e l l o w o r l d’ String.prototype.spacify = function(){ return this.split(&apos;&apos;).join(&apos; &apos;); };]]></content>
      <categories>
        <category>Javascript</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片优化之懒加载]]></title>
    <url>%2F2015%2F04%2F15%2F%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E4%B9%8B%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[页面里面图片资源比较丰富，做优化的时候，首先考虑的就是图片按需加载，延迟加载。 因为如果一次性都加载完，等待时间会比较长。而且用户可能本来就不会一直拉到页面底部浏览完才离开，所以即为了加载速度，又为了节约流量。可以等到需要的时候再加载图片。 jquery懒加载插件-Lazy Load地址：https://github.com/tuupola/jquery_lazyload 使用方法1.引入jquery和lazyload插件，或者直接npm安装 // npm 安装 $ npm install jquery-lazyload // 直接引入 &lt;script src=&quot;jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.lazyload.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 2.给html页面的img设置lazy样式，并用自定义属性来存储图片实际指向的地址 &lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; height=&quot;480&quot;&gt; 3.js调用 $(&quot;img.lazy&quot;).lazyload(); 4.注意:必须设置图片的宽高，否则插件无法正常工作 特殊需求参数设置设置临界点默认情况下图片会出现在屏幕时加载. 如果你想提前加载图片, 可以设置threshold 选项, 如：设置 threshold 为 200 令图片在距离屏幕 200 像素时提前加载. $(&quot;img&quot;).lazyload({ threshold : 200 }); 使用特效默认情况下，图像完全加载并调用show()。你可以使用任何你想要的效果。下面的代码使用fadeIn （淡入效果） $(&quot;img&quot;).lazyload({ effect : &quot;fadeIn&quot; }); 当图片不连续时滚动页面的时候, Lazy Load 会循环为加载的图片. 在循环中检测图片是否在可视区域内. 默认情况下在找到第一张不在可见区域的图片时停止循环. 图片被认为是流式分布的, 图片在页面中的次序和 HTML 代码中次序相同. 但是在一些布局中, 这样的假设是不成立的. 不过你可以通过 failurelimit 选项来控制加载行为. $(&quot;img&quot;).lazyload({ failure_limit : 20 // 将 failurelimit 设为 20 ，当插件找到 20 个不在可见区域的图片时停止搜索. }); 加载隐藏图片当界面有很多隐藏图片的时候并希望加载他们的时候则使用kip_invisible 属性，将其设置为false $(&quot;img&quot;).lazyload({ skip_invisible : false }); 其他的需求可以看官网的api 懒加载的原理页面的img元素，如果不给src属性，浏览器是不会发送请求去下载图片的，只有通过src设置了图片路径，浏览器才会发送请求。 懒加载就是页面打开的时候，先把页面里的所有img元素或者是其他元素的背景图片路径替换成一个大小为1*1px的图片的路径，用来占位。 把真正的路径存在元素的自定义属性“data-original”里面 页面加载完成，根据scrollTop判断图片是否出现在浏览器可视区域里，如果在，再把自定义属性里面的路径取出来，赋值给图片的src，让图片显示出来。 在滚动事件中重复判断图片是否进入视野，如果进入，就把data-original属性里面的值取出来放在src属性里面。 实现方法（一）获取窗口、窗口滚动和元素距离窗口顶部的偏移高度，计算元素是否出现在窗口范围内； 1）屏幕可视窗口的大小 js原生方法：window.innerHeight标准浏览器IE9+ || document.documentElement.clientHeight标准浏览器及ie||document.body.clientHeight jquery方法： $(window).height() 2）浏览器窗口顶部和文档顶部之间的距离，也就是滚动条的滚动的距离 原生js方法：window.pageYoffset (IE9+标准) || document.documentElement.scrollTop 兼容ie低版本的 || document.body.scrollTop 兼容混杂模式 jquery方法： $(document).scrollTop() 3）获取元素距离窗口顶部偏移高度 jquery方法：$(0).offset().top //距离文档顶部的距离 原生js：getoffsetTop() 判断图片是否在可视区域内 function isShow($el){ var winH = $(window).height(),//获取窗口高度 scrollH = $(window).scrollTop(),//获取窗口滚动高度 top = $el.offset().top;//获取元素距离窗口顶部偏移高度 if(top &lt; scrollH + winH){ return true;//在可视范围 }else{ return false;//不在可视范围 } } (二)监听窗口滚动事件，判断元素是否在可视范围内 $(window).on(&apos;scroll&apos;, function(){ //监听滚动事件 checkShow(); }) checkShow(); // 先加载一次，首屏 function checkShow(){ //检查元素是否在可视范围内 $(&apos;img&apos;).each(function(){ //遍历每一个元素 var $cur = $(this); if(!!isloaded($cur)){ return; } //判断是否已加载 if (isShow($cur)) { setTimeout(function(){ showImg($cur); },300) //设置时间是为了更好的看出效果 }; }); } （三）元素显示的时候，把之前的地址设置为data-origin的地址 function showImg($el){ $el.attr(&apos;src&apos;, $el.attr(&apos;data-src&apos;)); $cur.data(&apos;isloaded&apos;,true); }]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和Github搭建的博客]]></title>
    <url>%2F2015%2F04%2F01%2Fartical%2F</url>
    <content type="text"><![CDATA[博客迁移原因之前一直在印象笔记上做记录，单机版的，时间长了占用大量的本地内存。markdown写起来还是比较少的，偶然看到一个用hexo搭建的博客，简洁明了，花了几个小时的功夫，终于把这个博客搭建起来了，虽然功能还不完善，但是看起来还是很舒服的，后面有时间了再慢慢完善。这几天先把部分笔记迁移过来，权当再复习一遍知识。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重、反转、排序、冒泡排序、过滤方法]]></title>
    <url>%2F2015%2F03%2F28%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E3%80%81%E6%8E%92%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组去重方法1.indexOf方法： Array.prototype.unique1 = function () { var newArr = []; for (var i = 0; i &lt; this.length; i++) { if (newArr.indexOf(this[i]) == -1) { newArr.push(this[i]); } } return newArr; } 2.哈希表,利用对象key值的唯一性 Array.prototype.unique2 = function(){ var obj = {}, newArr = []; //n为hash表，r为临时数组 for(var i = 0; i &lt; this.length; i++) { var key = this[i]; if (!obj[key]) { obj[key] = true; //存入hash表 newArr.push(key); //把当前数组的当前项push到临时数组里面 } } return newArr; } 3.方法三 Array.prototype.unique3 = function(){ var n = [this[0]]; //结果数组 //从第二项开始遍历 for(var i = 1; i &lt; this.length; i++){ //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (this.indexOf(this[i]) == i){ n.push(this[i]); } } return n; } 数组反转方法方法一： var nums1 = [10,20,30,40,50,60,70]; //0 5 1 4 2 3 var newNums1 = []; // 关键是从末尾开始遍历，i-- for(var i=nums1.length-1;i&gt;=0;i--){ // 每次遍历向新数组的最后一项添加 newNums1[newNums1.length] = nums1[i]; } 方法二 思路：var arr = [0,3,6,8,12,5,3]; 反转：将0与3交换，即下标arr的第一项和arr的最后一项交换 i = 0; arr[0] = arr[arr.length-1]; arr[arr.length-1-0] i = 1; arr[1] = arr[arr.length-1-1]; //代码： Array.prototype.myReverse = function() { var len = this.length; for (var i = 0; i &lt; len/2; i++) { var temp = this[i]; //将当前遍历的项用临时变量存储起来 this[i] = this[len-1-i]; //将最后一项的结果赋值给第一项 this[len-1-i] = temp; //将最后一项的值修改为第一项的值，实现交换 } return this; } var arr = [0,3,6,8,12,5,3]; console.log(arr.myReverse()); //第三种： ( reverse()的底层原理 ) function rev3(array){ //数组中的元素前后交换位置 for(var i=0;i&lt;array.length/2;i++){ //交换位置。 var temp = array[i]; array[i] = array[array.length-1-i]; array[array.length-1-i] = temp; } //return; return array; } 数组排序方法第一、数组的升序降序问题 var arr = [45,98,67,57,85,6,58,83,48,18]; //从小到大排序 arr.sort(function(a, b) { return a - b; }); console.log(arr); //从大到小排序 arr.sort(function(a, b) { return b - a; }) //会改变原数组 第二、自定义数组排序的方法： /* * @param {*} arr * @param {*string} flag desc || asc */ function sortNumber(arr, flag) { if (Array.isArray(arr)) { // 自定义排序方法，里面可以写自己的逻辑 return arr.sort(function(a, b) { if (typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;) { if (flag === &apos;asc&apos;) { return a - b; } else { return b - a; } return b.age - a.age;//按照某个属性的某个规律排列 } else { alert(&apos;请输入数字数组&apos;); } }) } else { alert(&apos;请传入数字数组&apos;) } } // 用法： // 降序： var res = sortNumber(arr, &apos;desc&apos;) 第三、将对象数组按照某一属性值的首字母顺序排序 原数组 var infoObj = [{ name: &quot;张三&quot;, sex: &apos;female&apos;, age: 30 }, { name: &quot;李四&quot;, sex: &apos;male&apos;, age: 20 }, { name: &quot;王五&quot;, sex: &apos;female&apos;, age: 40 } ]; compare函数 function compare(prop) { // 数组的上一项和下一项 return function (obj1, obj2) { var val1 = obj1[prop]; // 第一项的value var val2 = obj2[prop]; // 判断非数字排序的情况 if (isNaN(val1)) { return val1.localCompare(val2); // 用本地特定顺序来比较 } else { return val1 - val2; } } } var sortObj = infoObj.sort(compare(&apos;age&apos;)) // 按照年龄属性排序 //sort()底层原理； // var arr = [3,2,1,14,6,5]; // // console.log(bubble(arr, function (a,b) { // return b-a; // })); // // function bubble(array,fn){ // //外循环控制轮数，轮数都是元素个数-1； // for(var i=0;i&lt;array.length-1;i++){ // //内循环控制次数，次数都是元素个数-1； // for(var j=0;j&lt;array.length-1;j++){ // //如果前面的比后面的大交换位置。 // if(fn(array[j],array[j+1]) &gt; 0 ){ // var temp = array[j]; // array[j] = array[j+1]; // array[j+1] = temp; // } // } // } // //最终把数组返回。 // return array; // } //第二遍 var arr = [3,2,1,14,6,5]; console.log(bubble(arr, function (a,b) { return b-a; })); function bubble(array,fn){ //外循环控制趟数，趟数是元素个数-1； for(var i=0;i&lt;array.length-1;i++){ //内循环控制次数，次数是元素个数-1； for(var j=0;j&lt;array.length-1;j++){ //如果后面的比前面的大就交换位置。 if(fn(array[j],array[j+1]) &lt; 0){ var temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; } } } //返回 return array; } 数组的过滤方法需求：去除字符串或数组里相邻的重复的项，并以数组的形式输出 思路一：利用indexOf查询相邻的两项是否相等 var uniqueInOrder=function(arr){ var result = []; for (var i = 0, length = arr.length; i &lt; length; i++){ if (arr.indexOf(arr[i]) !== arr.indexOf(arr[i + 1])) { result.push(arr[i]); } } return result; } 思路二： var uniqueInOrder = function (args) { return [].filter.call(args, (function (v, i) { return arr[i - 1] !== v; }); } 需求：A数组包含所有的字符串，B数组有未知个字符串。如果A数组内的字符串包含B数组里的每一个字符串，则为真，否则为假。 var a = [1,2,3,4,5,6,7,8,9]; var b = [1,3]; function arr_contrast(a,b){ return a.filter(function(item){ return b.indexOf(item) !== -1 }).length === b.length } 冒泡排序需求，将数组按照从大到小的顺序排序 var nums = [0,1,2,3,4,5,6,7,8,9]; // nums.length=10 思路：共需要比较9次，第一次拿0和其他项目比较，将0放在最后 规律： 1 2 3 4 5 6 7 8 9 0 // 第1趟比较，比较了9次，交换了9次 2 3 4 5 6 7 8 9 1 0 // 第2趟比较，比较了9次，交换了9次 ...... 9 8 6 7 5 4 3 2 1 0 // 第9趟比较，比较了9次，交换了9次 分析： 1.设数组的长度为n 2.比较相邻的前后两个数据，如果前面的数据大于后面的数据，就将两个数据的位置交换； 3.这样数组的第0个数据到n-1个数据进行一次遍历之后，就到了n-1的位置 4.n=n-1，如果n不为0.就会继续重复前面的步骤 var nums = [0,1,2,3,4,5,6,7,8,9]; // nums.length=10 var outer = 0; // 外层趟数 var inner = 0; // 内层比较次数 for(var i = 0; i &lt; nums.length-1; i++) { // 外层循环控制比较的趟数 outer++； var count = 0; for(var j = 0; j &lt; nums.length-1-i; j++) { // 比较的次数 交换 的次数 if(nums[j]&lt;nums[j+1]){ var temp = nums[j]; nums[j]=nums[j+1]; nums[j+1]=temp; count++; } } if (count == 0) { break; // 终止 } } console.log(nums);]]></content>
      <categories>
        <category>Javascript</category>
        <category>数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组基本方法]]></title>
    <url>%2F2015%2F02%2F22%2F%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数组方法concat拼接方法arr.concat(arr1) // 返回一个副本 join：将数组转化为字符串var arr = [1,2,3,4,5,6]; var res = arr.join(&quot;,&quot;); // &quot;1,2,3,4,5,6&quot; //无缝连接： arr.join(&quot;&quot;) 返回的是一个新的数组 // &quot;123456&quot; // toString()方法 arr.toString() 数组for循环用变量将数组的长度存储起来，会节省时间for(var i = 0; var len = arr.length; i++) { //执行函数 } push 添加方法添加数据到数组的末尾 arr.push(&quot;123&quot;); // 返回的是修改后的数组的长度，不是新数组 pop从数组尾部移除一项从数组的末尾移除一项 // 返回的是移除的项 shift移除数组第一项移出数组的第一项 // 返回移除的项 unshift向数组最前面添加一项 // 返回的添加后新数组的长度 slice 对数组进行切割，返回的是一个新数组，不会改变原数组 只有一个参数，返回的是从指定位置到末尾的数 有两个参数，返回从开始到结束，不包括结束项的数组 arr = [1, 2, 3, 4, 5]; var arr1 = arr.slice(1); //[2, 3, 4, 5] 返回第一项开始所有的数字 var arr2 = arr.slice(1, 4) [1, 4)包左不包右 // arr2 = [2, 3, 4]; splice 从数组中删除/添加项目 删除 arr.splice(要删除的项目开始的位置（下标）， 要删除的项数， 向数组添加新项目（可选项）) indexOf（）查找 indexOf(要查找的项目， 查找的起点位置的索引（可选）) 返回查找项在数组中的位置，没找到返回-1 arr.indexOf(‘3’) 返回的值为-1或查找项的索引 求一组数的最大值，最小值的方法1.Math.max.apply(Math, arr) 求数组的最大值 2.原生js方法 //求一组数中的最大值 // 假设数组中的第一个数就是最大值 var max = nums[0]; for(var i = 1; i &lt; nums.length; i++) { if(max&lt;nums[i]){ max = nums[i]; }else { max = max; } } console.log(&quot;此数组中的最大值为：&quot;+max); //求一组数中的最小值 //假设数组中的第一项就是最小值 var min = nums[0]; for(var i = 1; i &lt; nums.length; i++) { if(min&gt;nums[i]){ min = nums[i]; }else { min = min; } } console.log(&quot;此数组中的最小值是：&quot;+min); 判断是否是数组的方法1.console.log(a instanceof Array) 2. function isArray(object){ return object &amp;&amp; typeof object===&apos;object&apos; &amp;&amp; Array == object.constructor; } 3. function isArray(o) { return Object.prototype.toString.call(o) === ‘[object Array]‘; } 伪数组转化为真数组第一、伪数组的含义 具有数组的属性，并且属性名都是数字，可以像访问数组一样去访问 对象中的内容，并且可以被遍历，但是没有数组的方法 第二、把伪数组转化为数组 var fakeArr = { 0: &quot;小明&quot;, 1: &quot;小红&quot;, 2: &quot;小风&quot;, length: 3 } fakeArr.push(&quot;小树&quot;); //会报错，不能使用数组方法 //方法一：可以先遍历fakeArr数组，用一个空数组来接收 var arr = []; for(var i = 0; i &lt; fakeArr.length; i++) {arr.push(fakeArr[i])}; //方法二： 伪数组使用真数组的push方法,利用原型继承的方法 var arr = []; arr.push.apply(arr, fakeArr); // 伪数组使用真数组的concat方法 数组.concat(1, 2, 3, 4); var arr = [].concat.apply([], fakeArr); 第三. 函数中的arguments是伪数组，转化为数组： // 1、利用slice方法 function a() { var args = Array.prototype.slice.call(arguments); } a(1,2,3); // 2.ES6的Array.from方法 from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和 可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） function foo() { Array.from(arguments); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] } 数组的拷贝浅拷贝是直接将一个数组赋值给另外一个数组，没有考虑到数组是引用类型的数据，原数组改变，复制的数组也会改变； 深拷贝，考虑到数组是引用类型的数据，数组内部也可能是数组或对象或函数这样的引用类型的数据，所以不能直接复制，需要递归去一层层的遍历，进行拷贝 其中数组的深拷贝还可以直接用slice方法。或者for循环遍历数组； 在不使用循环的条件下，如何创建一个长度为100的数组，并且数组的每一个元素是该元素的下标？使用for方法： var arr = new Array(100); for(var i=0;i&lt;arr.length;i++){ arr[i] = i; } console.log(arr); 或者是： var arr = new Array(); for(var i=0;i&lt;100;i++){ arr.push(i); } console.log(arr); var arr = Object.keys(Array.apply(null, {length:100})).map(function(item){ return +item; }); console.log(arr); var arr = Array.from({length:100}, (v,k) =&gt; k); console.log(arr); var arr = new Array(100).keys(); console.log(Array.from(arr)); var arr = [...Array(100).keys()]; console.log(arr); 检测数组的数据类型1.obj instanceof Array； 2.toString.call([]); // &apos;[object Array]&apos; 3.Array.isArray(obj) // ecma5,不兼容ie6/7/8 // 封装兼容性 mdn if (!Array.isArray) { Array.isArray = function(arg) { return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;; }; } // 调用的时候： Array.isArray(obj) URL：网页链接，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。 function serilizeUrl(url) { var result = {}; url = url.split(&apos;&amp;&apos;)[1]; //a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e var arr = url.split(&apos;&amp;&apos;); //[&quot;a=1&quot;, &quot;b=2&quot;, &quot;c=&quot;, &quot;d=xxx&quot;, &quot;e&quot;] for (var i = 0; i &lt; arr.length; i++) { result[arr[i].split(&apos;=&apos;)[0]] = arr[i].split(&apos;=&apos;)[1]; } return result; }]]></content>
      <categories>
        <category>Javascript</category>
        <category>数组</category>
      </categories>
  </entry>
</search>