<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cookie基础知识及用法]]></title>
    <url>%2F2017%2F07%2F18%2Fcookie%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[应用场景 保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。 定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。 创建购物车。正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。 当然，上述应用仅仅是cookie能完成的部分应用，还有更多的功能需要全局变量。 cookie的缺点主要集中于安全性和隐私保护。主要包括以下几种： cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能； cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的； cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除； cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。 注意事项： cookie是http请求协议的一部分，写在http头部里面，每次当前页面请求的时候都会一起发送给服务器，所以也浪费性能，尽量少写。有替代方案，使用html5的localStrage属性，但是为了兼容性，低版本的还是可以使用cookie cookie的用法和格式 domain：有效域名，默认为当前2级域名 path：有效路径，默认为/ expires：到期时间，默认为一个会话 max-age：最新代替expires的配置项，设置有效时间，单位秒 secure：是否只在https协议下传输cookie，默认false// 存储的数据格式如果比较特殊可以使用encodeURIComponent方法进行编码document.cookie = ‘data=gezhongshuju’+ &apos;;domain=baidu.com&apos; + &apos;;path=/&apos; + &apos;;expires=&apos; + new Date(&apos;2017-3-15&apos;) + &apos;;max-age=&apos; + 60 * 60 * 24 + &apos;;secure=true&apos;; 使用cookie插件 –&gt; jquery.cookie.js获取//获取所有cookie var cookieObj = $.cookie(); //获取单个cookie var cookieVal = $.cookie(&quot;key&quot;); 注意：获取到的是一个json字符串，需要转成json对象 var cookieVal = JSON.parse($.cookie(&quot;key&quot;)); 但是，如果用户将cookie删除的话，就会出现JSON.parse(undefined);报错的情况：所以需要先判断，是否有$.cookie(“key”)，才能继续进行业务逻辑 方法一： var userInfo = JSON.parse( $.cookie(&quot;userInfo&quot;) || &quot;{}&quot; ); 方法二： try{ var userInfo = JSON.parse($.cookie(&quot;key&quot;)); }catch(e) { console.log(&quot;json解析错误&quot;); } 设置和修改//设置cookie 在当前域名路径下设置指定的cookie var cookieStr = $.cookie(&apos;key&apos;, &apos;value&apos;); //设置指定天数过期时间 在当前域名路径下设置指定的cookie var cookieStr = $.cookie(&apos;key&apos;, &apos;value&apos;, {expires: 100}); var cookieStr = $.cookie(&apos;key&apos;, &apos;value&apos;, {&apos;max-age&apos;: 24 * 60 * 60 }); //max-age以秒为单位 //设置当前域名路径下cookie var cookie = $.cookie(&apos;key&apos;, &apos;value&apos;, { domain: &apos;/&apos;, path: &apos;/&apos;, secure: true }); 删除cookie// 删除单个cookie --&gt; 删除当前路径下指定cookie // 返回值代表在当前路径下是否还存在这个cookie，因为同一个cookie名可能存在与不同的路径中，每次只能删除一个 var isExist = $.removeCookie(&apos;cookieKey&apos;); // 删除单个cookie --&gt; 删除指定路径下指定cookie // 该cookie一定在当前路径下可以访问的到，即该cookie路径是当前路径的上级 // 返回值代表在当前路径下是否还存在这个cookie，因为同一个cookie名可能存在与不同的路径中，每次只能删除一个 var cookieVal = $.cookie(&apos;cookieKey&apos;, { path: &apos;/&apos; }); 原生js设置和修改cookie//一次只能存储一个值 document.cookie = &quot;userId=value&quot;; document.cookie = &quot;userInfo={name:&apos;zhangsan&apos;,age:29}&quot;; 或者 document.cookie = &apos;userId=828; userName=hulk&apos;; //一次性存储多个值 //修改cookie document.cookie = &quot;userId=234&quot;; //语法为：document.cookie = &quot;key=newValue&quot;; 获取cookie//document.cookie获取的是一个网页，当前路径下面的所有cookie信息，比如jd.com里面的cookie就是jd的cookie，可以通过路径来设置cookie的使用范围 //设置两个cookie document.cookie=&quot;userId=828&quot;; document.cookie=&quot;userName=hulk&quot;; //获取cookie字符串 var strCookie = document.cookie; //str = &quot;userId=828; userName=hulk&quot; var arrCookie = strCookie.split(&quot;;&quot;) //将多个cookie切割为多个名值对 var userId; //遍历cookie数组，处理每个cookie对 for(var i = 0; i &lt; arrCookie.length; i++) { var arr = arrCookie[i].split(&quot;=&quot;); //将单个名值对切割成一个数组 if (arr[0] == &apos;userId&apos;) { userId = arr[i]; } } return userId; //可以得到一个cookie的值 expires: 给cookie设置终止日期有一个新方法： max-age //语法：document.cookie = &apos;userId=828; expires=GMT_String&apos;; //设置10天后过期 var date = new Date(); //取得当前时间 var expiresDays = 10; //设置过期时间 date.setTime(date.getTime() + expiresDays * 24 * 3600 * 1000); document.cookie = &apos;userId=828; useName=hulk; expires=&apos;+date.toGMTString(); //设置某一个日期过期 document.cookie = &quot;userId=828; expires=&quot; + new Date(&quot;2017-5-13&quot;); //先找到要设置过期时间的cookie，再将过期时间设置为当前时间的过去时间 删除cookie，将cookie时间设置为过去的时间即可var date = new Date(); date.setTime(date.getTime() - 100000); document.cookie = &apos;useId=825; expires=&apos;+ date.toGMTString(); cookie可以访问的路径 默认情况下，只有同级目录或同级目录的子目录可以访问，例如： cookie所在页面： www.xxxx.com/html/a.html； 可以被访问的页面： www.xxxx.com/html/b.html； www.xxx.com/ html/ some/c.html 不能被访问的页面： www.xxxx.com/d.html 子路径可以访问父路径的，父路径不能访问子路径的，默认设置的是根目录 //为了控制cookie可以访问的页面，需要设置path参数 document.cookie=&apos;name=xioaming; path=cookieDir&apos;; //指定cookie在整个根目录下都可以使用，将cookieDir指定为根目录 document.cookie = &apos;user=123; path=/&apos; cookie代码封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var CookieUtil = &#123; //设置cookie set: function(name, value, expireDays, domain, path, secure) &#123; var cookieText = ''; //设置cookie键值对 cookieText += encodeURIComponent(name) + '=' + encodeURIComponent(value); //设置过期时间 if(expireDays) &#123; var date = new Date(); date.setDate(date.getDate() + expireDays); cookieText += '; expires=' + date.toGMTString(); &#125; //设置cookie可以访问的路径 if(path) &#123; cookieText += '; path=' + path; &#125; //设置cookie可以访问的主域名 if(domain) &#123; cookieText += '; domain=' + domain; &#125; if (secure) &#123; cookieText += "; secure"; &#125; document.cookie = cookieText; &#125;, // name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure //获取cookie值 get : function (name) &#123; var cookieName = encodeURIComponent(name) + "=", cookieStart = document.cookie.indexOf(cookieName), cookieValue = ""; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf (";", cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, // 删除cookie unset : function (name, domain, path, secure) &#123; this.set(name, "", Date(0), domain, path, secure); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue基础知识学习总结]]></title>
    <url>%2F2017%2F07%2F16%2FVuewendang%2F</url>
    <content type="text"><![CDATA[学习文档目录官网:http://cn.vuejs.org/ http://cn.vuejs.org/v2/guide/ https://www.awesomes.cn/subject/vue MVVM机制M:model 数据模型:提供数据(ajax) V:view 视图 视图、负责展现在我们浏览器端东西 VM:view-model 相当于是控制器 和angular对比，数据双向绑定原理的不同angular是脏检查机制脏数据就是之前的数据已经更新了，有了新数据，但是视图不知道，没有更新数据，就需要检查数据有没有更新，有就去通知视图更新。 如果用原生的异步方法，比如setTimeout,setInterval，ajax，事件click会阻断数据的脏检查，需要手动触发脏检查，把要执行的代码放在$apply()的回调函数里面。 而以ng-click开头的有脏检查。 原理就是： Angular 在 作用域$scope上设置了一个监听队列，用来监听数据变化并更新 view 。 当每次给view绑定一个事件，比如ng-click的时候，AngularJs内部 就会往 $watch 队列里插入一条新 $watch，用来检测它监视的 model 里是否有变化的东西。$watch对象里面有三个参数，其中getNewValue()方法可以得到$scope上的最新值，listener方法可以比较新旧值，做操作。 当view接收到可以被 angular context 处理的事件，比如说dom事件，ng-click,ajax事件（angular里面是$http），$timeout,$interval定时器事件,主要是异步事件，$digest 循环就会触发，遍历所有的 $watch队列，有变化，就会更新$scope里面的val值对应的 dom。 Vue.js通过属性劫持再结合发布者-订阅者模式来绑定比如说有一份数据a.b，a对象里面有属性b，在Vue实例化的过程中（new Vue()）,会用Object.defineProperty()方法给a.b添加getter和setter方法； 同时，vue.js的compile会解析模板，生成一个指令对象，比如v-text=”a.b”，每一个指令对象都会关联一个watcher（a.b），指令对应的a.b的有值时候，就会触发到它上面的getter，会被通知到watcher，a.b的值再有变化的时候，就会触发setter，watcher会再次获取a.b的值，并对比新旧的值，发现值改变了，就会通知指令v-text。 指令v-text是vue内部封装好的dom操作方法，会调用原生的innerText更改值。 vue和angular对比的优缺点vue比angular1好用的多，更轻量，大小只有26k，移动端开发很占优势，就是环境搭建比较复杂，但是组件化开发，维护成本低；学习称本地，学习曲线平稳。 vue借鉴了angular的指令和react的组件化，把页面抽成组件树，每个组件都有完整的声明周期 angular1后面从2开始就重写了，$scope变成zone.js，控制器也变成了component组件，学习成本太高了。现在都发展到4了，1早晚会被淘汰的。 angular1和vue的数据双向绑定机制是不一样的。如上。 vue指令v-text&amp;v-html v-text：显示文本 v-html：解析并且显示html字符串 v-on: 给我们的dom元素上绑定事件的 v-bind: 给我们标签绑定属性，它的目的是让我们的某些标签属性上面的值来自我们model v-model: 用来实现数据双向绑定（模型更改之后，会更新视图，视图更改之后，会影响模型） v-if/v-else: 判断是否需要渲染我们标签 v-for: 循环渲染html标签 注意点: 1、指令要和html元素作用在一起 2、v-bind和我们v-on都有缩写的方式 v-bind: 可以缩写成 `:` v-on: 可以缩写成`@` 3、v-model只会作用于哪些有value值的标签(input checkbox...) 4、v-else/v-else-if必须紧跟在上一个v-if后面 vue路由步骤: 1、写好html中的代码 1&lt;router-link to=&quot;/xxxx&quot;&gt;&lt;/router-link&gt; 1&lt;router-view&gt;&lt;/router-view&gt; 2、写好js中的代码 1、定义好组件 2、将组件和具体跳转路径配置在路由中 3、将路由和vue实例关联起来 vue-resource步骤:参考:https://github.com/pagekit/vue-resource/blob/develop/docs/http.md 1、导入vue-resource 2、调用方法 this.$http.get/post/jsonp(url).then(成功的回调，失败的回调) 注意:post请求，在我们第三个参数中，一定得设置{emulateJSON:true}]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue音乐webApp项目总结]]></title>
    <url>%2F2017%2F07%2F16%2Fvue%E9%9F%B3%E4%B9%90webApp%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-高仿饿了么项目总结]]></title>
    <url>%2F2017%2F03%2F25%2FVue-%E9%AB%98%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[把慕课网上的Vue高仿饿了么项目学习完了，记录一下课程里面的所得。 环境搭建，用vue-cli1.npm i -g vue-cli; 2.可以用vue 命令 例如vue init / vue list 3.有多种选择的模板：用vue init webpack sell(自己取的名字) / vue init webpack-simple去安装 4.安装完毕之后，切换到文件夹 cd sell npm install npm run dev 注意：同时会安装vue-router 项目上线依赖&quot;dependencies&quot;: { &quot;vue&quot;: &quot;^2.3.3&quot;, &quot;vue-router&quot;: &quot;^2.3.1&quot;, &quot;vue-resource&quot;: &quot;^1.3.4&quot;, &quot;better-scroll&quot;: &quot;^0.2.1&quot; }, 项目开发依赖1.css部分用stylus语法编译，stylus语法需要把{}和；都去掉 2.安装loader时遇到的坑 stylus-loader@2.5.1 requires a peer of stylus@&gt;=0.52.4 but none was installed. 3.解决办法 在package.json里面增加： &quot;stylus-loader&quot;: &quot;^3.0.1&quot;, &quot;stylus&quot;: &quot;0.52.4&quot;, 再执行npn install 和 npn run dev cli生成的项目文件介绍1.static里面的.gitkeep表示即使文件夹为空，也可以提交到git仓库，因为空文件夹会忽略 2..babelrc是把es6转成es5，方便浏览器识别，其中有依赖的插件，comment是注释不会显示； 3.editorconfig是编码风格文件，比如字体缩进，换行，去除首尾空格等 4.eslintignore是忽略对里面的文件做语法检查； 5.eslintrc是es6的语法标准的配置 css 设置的关键点编码习惯如果有一个元素，绑定class是为了在js里面做选择，而不是为了设置样式，用类似food-list-hook 1像素边框的制作设置伪元素，用media+scale .border(@borderColor){ position: relative; &amp;::after{ content: &quot;&quot;; position: absolute; bottom: 0; left: 0; width: 100%; border-top: 1px solid @borderColor; } } @media (min-device-pixel-ratio: 1.5) { .border{ &amp;::after{ transform: scaleY(0.7); } } } @media (min-device-pixel-ratio: 2) { .border{ &amp;::after{ transform: scaleY(0.5); } } } 自适应宽，flex布局左边宽度固定，右边宽度自适应 .food{ display: flex; width: 100%; .nav{ flex: 0 0 80px; width: 80px; } .foodList{ flex: 1; } } Sticky footer解决的问题：如果页面内容不够长的时候，页脚块固定在视窗底部；如果内容足够长，需要滚动的时候，页脚块随着内容向下推送，而不是固定视窗底部，挡住了页面的文字 解决办法： 1.设置三个层，一个内容的包裹层，里面再有一个层，是内容；再有一个层是底部层 &lt;div v-show=&quot;detailShow&quot; class=&quot;detail&quot;&gt; &lt;div class=&quot;detail-wrapper clearfix&quot;&gt; //clearfix样式另外自己写 &lt;div class=&quot;detail-main&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;detail-close&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; 2.设置css .detail position: fixed z-index: 100 top: 0 left: 0 width: 100% height: 100% overflow: auto background-color: rgba(7, 17, 27, 0.8) // filter: blur(10px) .detail-wrapper min-width: 100% height: 100% .detail-main margin-top: 64px padding-bottom: 64px(这个是关键，设置一个下padding，给底部留出空间) .detail-close // 和wrapper层一个层级，wrapper层占有100%的高度，所以footer层永远在视口之外，需要下面用-margin-top调整至视口之内 position: relative width: 32px height: 32px margin: -64px auto 0 auto // 设置一个-margin,将自己放置在上面预留的-margin处 clear: both font-size: 32px 自适相等宽高需要设置一个宽高相等的图片，但是每张图的宽高比例是不同的，需要做到自适应，就可以设置父元素的高度为0，上边距为100%，子元素设置宽为100%，高为100% .image-header position: relative width: 100% height: 0 padding-top: 100% // 让图片的宽高一致，保持同等比例 img position: absolute top: 0 left: 0 width: 100% height: 100% 媒体查询，适用于ipone5@media only screen and (max-width: 320px) // 仅仅当屏幕最大尺寸为320px时适用 padding-left: 6px Vue知识要点vue动画设置看文档，此处是需要设置页面从右向左移入给需要动画的元素的外层设置包裹，在html里面设置： html: &lt;transition name=&quot;move&quot;&gt; &lt;div class=&quot;food&quot; v-show=&quot;showFlag&quot; ref=&quot;food&quot;&gt; &lt;/food&gt; &lt;/transition&gt; css: .food transform: translate3d(0, 0, 0) &amp;.move-enter-active, &amp;.move-leave-active transition: all 0.2s linear // 过渡效果 &amp;.move-enter, &amp;.move-leave-active transform: translate3d(100%, 0, 0) // 动画开始的位置，从右到左飞入 transition动画不能用在一个v-for循环生成的一组元素上面，可以写在每一个的里面&lt;div class=&quot;ball-container&quot;&gt; &lt;div v-for=&quot;ball in balls&quot;&gt; &lt;transition name=&quot;drop&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;ball.show&quot;&gt; &lt;div class=&quot;inner inner-hook&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt; vue路由设置重定向路由首页进入希望停在商品页面，可以在路由里面设置重定向 const router = new VueRouter({ routes: [ {path: &apos;/&apos;, redirect: &apos;/goods&apos;}, // 重定向 {path: &apos;/&apos;, component: goods}, {path: &apos;/seller&apos;, component: seller}, {path: &apos;/ratings&apos;, component: ratings}, {path: &apos;/goods&apos;, component: goods} ] }) 或者在后面用router.push({path: &apos;/goods&apos;}) //测试可以成功 路由激活样式修改《router-link to=‘’》有默认的class,可以在路由里面配置修改 linkActiveClass: &apos;active&apos;，在router实例里面 组件设置滚动效果食物左侧的菜单导航，以及食物容器自身，在内容超出浏览器可视区域的时候，会出现滚动条，但是移动端设计效果是希望可以滚动，触摸上去的时候，滑动，移动端常用的插件是Iscroll，这里使用的是better-scroll插件。Iscroll插件（http://iscrolljs.com/）因为已经很久不维护了，所以采用的是这个仿写的。 安装时候的问题：npm 安装better-scroll时报错 npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\browser-sync\node_modules\chokidar\node_modules\fsevents) npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.0.14: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;}) 是因为$sevents不兼容win系统，忽略警告，执行下面的既可以安装成功 npm -g install npm 用法：关键在于给需要设置的滚动的容器外层添加一个div，滚动的时候会计算要滚动的容器的高度，外层div的高度是固定的，超出的部分隐藏，里层的高度超出就可以滚动。 &lt;div class=&quot;food&quot; v-show=&quot;showFlag&quot; ref=&quot;food&quot;&gt; &lt;div class=&quot;food-content&quot;&gt; &lt;/div&gt; &lt;/div&gt; 用法：初始化，进行实例化 new BScroll(dom对象， { //options }); 如果需要直接对dom做操作，需要在html标签里面绑定ref=&quot;div&quot; 用this.$refs.div获取 为了让子元素可以被点击，设置click: true, VUE里面数据更新是异步的，在数据还没有加载完成之前，BScroll是无法获取目标容器的高度的，就会出现无法滚动的情况，即数据改变，dom没有变化 所以需要放在this.$nextTick里面去实例化 methods: { // 定义food详情页面显示或隐藏的方法 show () { this.showFlag = true this.selectType = ALL // 每一次进入商品详情页面都初始化，显示全部内容 this.onlyContent = false // 进入商品页面初始化显示有内容的评价 this.$nextTick(() =&gt; { // 实例化better-scroll方法，使food详情页面可以滚动 if (!this.scroll) { this.scroll = new BScroll(this.$refs.food, { click: true }) } else { this.scroll.refresh() } }) } } nextTick应该被用在某些计算属性或者watch再或者某个按钮click事件绑定的methods当中。这时，nextTick才能保证你的数据更新完成之后再执行你绑定的函数。 实例用法： this.$nextTick(() =&gt; { this.initScroll(); }) better-scroll的点击事件注意事项1.为了能点击，在实例化的时候，需要设置参数： click: true 2.在pc上，点击事件会执行两次。因为pc端不会阻止默认事件，由于better-scroll派发的事件有event_constructed: true属性，可以去判断原生事件有没有这个属性。 在html里面点击事件传递一个参数$event,在后面接收获取 &lt;div @click=&quot;addFirst($event)&quot; class=&quot;buy&quot; v-show=&quot;!food.count || food.count===0&quot;&gt;加入购物车&lt;/div&gt; // 点击加入购物车按钮，添加商品 addFirst (event) { if (!event._constructed) { return } Vue.set(this.food, &apos;count&apos;, 1) this.$emit(&apos;add&apos;, event.target) // 父子组件传值，在子组件触发 } vue给对象新增属性vue.set(this.food.count, &quot;1&quot;) vue非父子组件传值这个项目里面，cartcontrol组件需要在每个增加或减少的按钮被点击的时候，将被点击的元素，传递给另外一个组件shopcart，这两个组件之间不是包含和被包含的关系解决的思路1：因为他们有同一个父组件，goods.vue，可以先将按钮所在的子组件的值传递给父组件，再由父组件传递给另外一个子组件shopcart 1.cartcontrol里面用下面的代码来触发 this.$emit(&apos;addFood&apos;, event.target) // 父子组件传值，在子组件触发 2.父组件good.vue里面在子组件标签上面用自定义事件来接收 &lt;cartcontrol @addFood=&quot;receiveAddFood&quot; :food=&quot;food&quot;&gt;&lt;/cartcontrol&gt; 3.父组件methods方法里面，调用函数 // 接收cartcontrol里面传递过来的事件对象 receiveAddFood (target) { console.log(target) } 解决思路2：利用bus vue阻止事件冒泡vue里面阻止事件冒泡，只是为了点击处理一个点击事件，但是因为父元素上面也定义了点击事件，用stop.prevent来阻止 &lt;div class=&quot;content-right&quot; @click.stop.prevent=&quot;pay&quot;&gt; // 只会触发content-right上面的事件，不会触发它的父元素上面的点击事件 vue父组件调用子组件里面定义的方法1.先在子组件methods里面定义方法，比如show(); 2.在父组件的子组件元素上面写ref=&quot;foodEl&quot;; 3.在父组件methods里面先获取子组件 this.$refs.foodEl.show() v-show用计算属性返回boolean// 绑定函数，计算点击吐槽或推荐时，评论列表里面显示的内容 needShow (type, text) { if (this.onlyContent &amp;&amp; !text) { // 只显示有内容的评价，而没有文本，返回false，v-show不显示 return false } if (this.selectTypeNum === ALL) { // 选择的是类型是全部时 return true } else { // 选择的是推荐或吐槽的时候，判断当前的这条评论的类型是否和选择的类型一致，一致就显示，不一致就不显示 return type === this.selectTypeNum } } 时间格式的过滤器vue里面日期时间字符串格式化为yyyy-mm-dd hh:mm之类的方法，用过滤的方法 全局过滤器1.用moment插件，因为为了复用性，写一个全局的过滤器 // 导入moment模块 var moment = require(&apos;moment&apos;); // 全局过滤器 Vue.filter(&apos;dmtDate&apos;, (input, formatString) =&gt; { const lastFormatString = formatString || &quot;YYYY-MM-DD HH:mm:ss&quot; // 在format中指定要把我们前面的时间按照什么样的格式输出 // 参数1：格式化的原始时间 // 参数2： 把院士时间，最终要格式化的字符串 // 参数：http://momentjs.cn/docs/ return moment(input).format(lastFormatString) }) &lt;p&gt;{{newsdetail.add_time | dmtDate('YYYY-MM-DD')}}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{{newsdetail.click}}次浏览&amp;nbsp;&amp;nbsp;&amp;nbsp; 分类：民生经济 &lt;/p&gt; 局部过滤器局部过滤器，在输出模块里面，和methods方法平级，定义一个过滤器 1.// 时间过滤器方法 filters: { formatDate (time) { let date = new Date(time) // 先转换成date类型的对象 return formatDate(date, &apos;yyyy-MM-dd hh:mm&apos;) } } 2.在common的js里面定义一个date.js方法， export function formatDate(date, fmt) { if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length)); } let o = { &apos;M+&apos;: date.getMonth() + 1, &apos;d+&apos;: date.getDate(), &apos;h+&apos;: date.getHours(), &apos;m+&apos;: date.getMinutes(), &apos;s+&apos;: date.getSeconds() }; for (let k in o) { if (new RegExp(`(${k})`).test(fmt)) { let str = o[k] + &apos;&apos;; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)); } } return fmt; } 3.用import 导入这个方法 import {formatDate} from &apos;../../common/js/date.js&apos; // 引入日期方法 正则相关正则提取url里面的参数，把参数分割成以&amp;为分隔符的key=value形式 var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g 解析：/表示分隔符，g表示全局匹配，匹配到第一个之后会继续向后查找 （）表示子组 [^]表示字符类取反，比如[^abc]匹配的就不是a和b和c的单个字符，[^?&amp;=]匹配不是^和?和=的单个字符 字符类[]后面的+和*表示量词 +等价于{1, }表示1次或多次 *等价于{0，}表示重复0次或多次 var str = &quot;foo=bar&amp;lang=js&quot;; var reg = /[^?&amp;=]{1,}=[^?&amp;=]{0,}/g console.log(str.match(reg)); // 输出[&quot;foo=bar&quot;, &quot;lang=js&quot;] var str = &quot;foo=bar&amp;lang=js&quot;; var reg = /[^?&amp;=]+=[^?&amp;=]*/; console.log(str.match(reg)); // 输出[&quot;foo=bar&quot;] var str = &quot;foo=bar&amp;lang=js&quot;; var reg = /([^?&amp;=]{1,})=([^?&amp;=]{0,})/; console.log(str.match(reg)); //输出 [&quot;foo=bar&quot;, &quot;foo&quot;, &quot;bar&quot;] &quot;http:/www.baidu.com/?a=1&amp;b=2&quot;.match(/([^?&amp;=]+)=([^?&amp;=]*)/g); // [&quot;a=1&quot;,&quot;b=2&quot;] 总结：将url里面的参数解析成key=val的对象的方法 /** * 解析url参数 * @example ?id=12345&amp;a=b * @return Object {id:12345,a:b} */ export function urlParse () { let url = window.location.search let obj = {} let reg = /[^?&amp;=]+=[^?&amp;=]*/g let arr = url.match(reg) // [&apos;id=12345&apos;, &apos;a=b&apos;] if (arr) { arr.forEach((item) =&gt; { let tempArr = item.split(&apos;=&apos;) // [&quot;id&quot;, &quot;12345&quot;] let key = decodeURIComponent(tempArr[0]) let val = decodeURIComponent(tempArr[1]) obj[key] = val }) } return obj } keep-alive缓存组件keep-alive缓存vue组件，当请求的数据没有变化的时候，不希望再发送请求，可以用keep-alive将组件缓存起来，缓存的同时也会记录上一次的滚动的位置 使用场景： 比如一个列表和一个详情，那么用户就会经常在打开详情=》返回列表=》打开详情之间切换，切换频率高，这样每次从详情返回列表的时候，都能从缓存里面快速渲染，而不是重新渲染 原理是把组件的状态缓存在内存里 如果并不想所有的组件都被缓存，有些切换回来的时候是已经加载过的，解决方法：在app.vue里面设置 &lt;!-- 这里是需要keepalive的 --&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;!-- 这里不会被keepalive --&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 然后在设置路由信息的时候这样 { path: &apos;&apos;, name: &apos;&apos;, component: , meta: {keepAlive: true} // 这个是需要keepalive的},{ path: &apos;&apos;, name: &apos;&apos;, component: , meta: {keepAlive: false} // 这是不会被keepalive的} 或者这里利用active的方法：http://www.cnblogs.com/zion0707/p/6213159.html]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全之xss学习]]></title>
    <url>%2F2017%2F01%2F05%2Fweb%E5%AE%89%E5%85%A8%E4%B9%8Bxss%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[xss攻击概念就是利用各种手段把恶意代码添加到网页中, 并让受害者执行这段脚本 xss攻击的类型反射型 我们可以用node,express来模拟，客户端在url的search里面传入一段xss攻击的脚本， 比如说img标签，让&quot;xss=&lt;img src=&quot;null&quot; onerror=&quot;alert(1)&quot;&gt;&quot; 这个时候会服务器会接收并解析，xss:req.query.xss,render渲染到模板返回。这个时候如果在服务器设置res.set(‘x-xss-protection’, 0)不让浏览器拦截xss响应，那么就会在页面弹出1。 如果是恶意的，在search栏里面嵌入了iframe，那么会在页面嵌入一个页面，通常见到插入恶意广告，或者直接嵌入一段让用户登陆个人信息的页面，客户输入登陆时，就会泄露了个人的隐私信息。 存储型不是放在search栏里面，而是会存储到服务器端，如数据库，内存，文件系统里面，并不会马上响应回来，下次请求的时候也不用再每次都提交xss代码，通过服务端读取seq里面的文件返回 防御措施编码对用户输入的数据进行HTML Entity编码，一些实体字符，编码成十进制的 过滤移除用户上传的DOM属性，如onerror等移除用户上传的style节点，可以控制页面的显示不显示，js节点，iframe节点 校正避免直接对HTML Entity解码使用DOM Parese转换，校正不匹配的DOM标签 后台接收到之后，对接收到的数据做解码，用正则替换&amp;&lt;等符号为实体字符，进行转义。 前台对后台返回的数据用domParse.js里面的HTMLParse(he.unescape(str, {strict: true}))方法进行先解码，反转义，再解析。domParse会有start,end,char,comment几个函数分别对传入的字符串做html或注释解码，拼接，拼接成一个html元素 这就是前端解码的过程 第三方库的地址：encode.js：可以使用https://github.com/mathiasbynens/he 中的he.js domParse：可以用楼上说的 https://github.com/blowsie/Pure-JavaScript-HTML5-Parser 接下来就是过滤，在前面的函数里面，就将这几个script等的标签过滤掉。校正. 上面的模拟过程在github上有fork的案例 写的比较全面的一个博客：http://www.cnblogs.com/wqhwe/p/5416976.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[图片优化之预加载]]></title>
    <url>%2F2016%2F09%2F22%2F%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E4%B9%8B%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[背景慕课网学习记录： 页面里面图片资源比较丰富的时候，加载比较慢，但是又需要全部展示出来给用户看，一张张加载很容易造成假死，效果很不好。 比如首页有很多图片，展示性的，所以可以用一个loading进度条，显示加载的进度，等加载完毕之后，再全部显示，就需要预加载 或者局部加载，一个评论框，下面可以选择表情，也需要把表情全部展示出来，如果不适用预加载，会看到那些表情是一个个加载的，有快有慢，体验不好。 或者是上一页下一页的图片，点击当前一页图片的时候，提前加载下一页的图片。 概念提前加载图片，当用户需要查看时可直接从本地缓存中渲染，可以保证图片无缝的展示，用户体验更好。 分类有序加载 无序加载 封装插件image-preLoad提供了三个实例： 1.先loading进度条显示进度，图片再无序预加载，进度条加载完毕，展示所有图片。 2.qq表情无序加载，点击选择表情按钮时，loading进度条显示完毕，显示所有图片 3.柯南漫画的有序加载，翻页时提前展示下一页 原理就是： 进度条无序加载的原理是先用一个loading进度条显示的图片覆盖住要显示的页面，然后遍历图片的所有地址，在每次循环的时候new 一个 image图片，然后监听图片的load事件，图片加载完毕，就把地址赋值给图片。直到所有的图片都加载完毕，再让进度条消失，让图片显示出来。 原生代码： &lt;script&gt; var imgs = [ &apos;http://i2.hoopchina.com.cn/user/308/15960308/13383588090.jpg&apos;, &apos;http://img.article.pchome.net/00/44/23/20/pic_lib/wm/2.jpg&apos;, &apos;http://lcd.yesky.com/imagelist/2009/044/404q4y8g4m0p.jpg&apos;, &apos;http://lcd.yesky.com/imagelist/2009/044/cgro54wt2t2x.jpg&apos; ]; var index = 0, // 当前是第几张图片 len = imgs.length, // 图片的总长度 $progress = $(&apos;.progress&apos;), var count = 0 // 当前加载的数量 // 遍历所有图片的src $.each(imgs, function (i, src) { // 创建图片 var imgObj = new Image(); // 当前图片加载完毕的时候 $(imgObj).on(&apos;load error&apos;, function () { // 每加载一次,显示加载 $progress.html(Math.round((count + 1) / len) + &apos;%&apos;); // 如果所有的都加载完毕，就将loading页面隐藏起来 if (count &gt;= len - 1) { $(&apos;loading&apos;).hide(); // 当前页是第一张 document.title = &apos;1/&apos;; } count++; }); imgObj.src = src }) &lt;/script&gt; 封装插件：这里就不详细贴代码了，按照jquery插件封装的方法： 1.一个自执行函数，不会污染全局变量； 2.面向对象的方法，创造一个preload构造函数，传入参数； 3.设置默认参数，用$extend{target, obj1, obj2}进行合并； 4.将有序时执行的方法和无序时的方法挂载在构造函数的原型上； 5.用$.extend({ preLoad: funciton() {new PreLoad()}的方法将其作为工具函数，合并到jquery函数中， // 调用的时候直接：$.perload(传参)即可 如果是$.fn.extend话，是实例方法，要用一个元素去调用。 })]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包对事件处理程序的封装]]></title>
    <url>%2F2016%2F08%2F20%2F%E9%97%AD%E5%8C%85%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[看js高程的时候，闭包讲的并不多，研究了网上很多资料，但是实际用的时候还是不多的，一个是因为会携带其他的作用域，容易造成内存泄漏，一个是没有多少意识去用闭包，前面在性能优化总结的章节里面讲了一个闭包来保存兼容性判断结果的优化思想，这里详细的用代码阐述一下。 js高程里面的eventHandler方法，实际上并不完善，使用的时候，为了做兼容性处理，如果直接使用封装的函数，会导致每一次都要去判断。 普通事件处理程序封装函数： 来找一找问题： 1：没有兼容dom0级事件，且这个函数会每次被调用时都判断浏览器兼容情况，应该用一个闭包函数来优化，一次调用，后面就不用再检测了。 2.addEventLister第三个参数用时间捕获方法不好，多数情况下还是应该用事件冒泡方法； 3.attachEvent事件中listener调用时，因为IE和chrome调用的方式不同，chrome调用时是将e作为参数传入进入的，el.onclcik = function (e) ;而IE是var func = el.onclcik; func()； 没有传递event参数，且执行时this指向window对象，所以listener执行的时候，无法直接获取event事件对象，也无法让直接调用this = el， 所以需要想办法将listener执行时获取window.event参数，且this指向el.onclick的el对象。 闭包封装事件处理程序封装eventRegister.js：/** * 判断浏览器支持的注册事件的方式， 获取一个注册事件的函数 * 闭包封装事件处理程序 * 1.解决IE和普通浏览器的兼容性问题； 2.解决了每次调用方法都判断浏览器是否支持某方法的问题，利用闭包； 3.解决了IE方法调用时无法直接适用event事件对象和this指向window的问题 */ function createEventRegister(){ //如果浏览器支持的是addEventListener if(document.addEventListener){ //就返回一个函数，这个函数内部使用addEventListener来注册事件 return function(ele, type, eventHandler){ ele.addEventListener(type, eventHandler); } }else if(document.attachEvent){ return function(ele, type, eventHandler){ ele.attachEvent(&quot;on&quot; + type, function(){ //这里手动通过上下文调用模式调用这个eventHandler //将里面的this指向当前对象，并且将事件对象作为参数传给了eventHandler eventHandler.call(ele, window.event); }); //var func = div.onclick //func(); } }else{ return function(ele, type, eventHandler){ ele[&quot;on&quot; + type] = eventHandler; } } } 使用方法：&lt;div id=&quot;box&quot;&gt;&lt;/div&gt; // 引入 &lt;script src=&quot;eventRegister.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var div = document.getElementById(&quot;box&quot;); // 保存每次的结果 var eventRegister = createEventRegister(); // 在被监听的元素上使用 eventRegister(div, &quot;click&quot;, function(e){ // console.log(e); // this }) &lt;/script&gt; 解决绑定的封装，js高程写法删除事件：1.dom0级事件：div.onclick = null; 2.IE: var EventUtil = { addHandler: function(element,type,handler) { if (element.addEventListener) { element.addEventListener(type,handler,false); } else if (element.attachEvent) { element.attachEvent(&apos;on&apos;+type,handler); } else { element[&apos;on&apos;+type] = handler; } }, removeHandler: function(element,type,handler) { if (element.removeEventListener) { element.removeEventListener(type,handler,false); } else(element.detachEvent) { element.detachEvent(&apos;on&apos; +type,handler); } else { element[&apos;on&apos;+type] = null; } } }]]></content>
      <categories>
        <category>Javascript</category>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目里面用过的性能优化]]></title>
    <url>%2F2016%2F08%2F18%2F%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E7%94%A8%E8%BF%87%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[谈到性能优化，好像是一个很大的命题，其实只要代码写的久一些，总会去思考怎么写才可以让网页速度加载的更快，节约更少的带宽，这并不是在项目实现效果后才会去考虑的问题，要在一开始分析需求，组织结构的时候就有意识去用，去思考。 看过雅虎36条军规，但是很多还是没有实践过的，或者说有些是一开始写js的规则，觉得不值一提的，这里总结一下，开发时候用到过的。 一、尽量减少HTTP请求次数浏览器解析的时候，从上往下执行，页面中的图像，css、js等文件，都需要去外部下载。用gulp或webpack,将文件合并、压缩； 二、图片优化1.写css布局的时候，要给图片一个宽高，给标签一个class名，尽可能不用标签查找2.精灵图页面有很多小图片的时候，做成精灵图，通过控制background-image和background-position来显；缺点是维护起来麻烦，改一张要改整个图片，合并图片麻烦，要合理安排空间。 3.iconfont页面里面的icon比较小，又比较多的时候，用字体图标，制作网站：iconmon 4.base64格式图片图片个数比较少，不超过2kb，请求的频率又比较高，比如网站头部的logo图片，可以用base64,不会发送http请求。webpack-cli默认设置是不超过1kb的用base64.实际使用看业务情况，既考虑大小，也考虑请求的频率。base64制作方法： 1、html5的FileReader()方法里面的readAsDataURL转化， var imgFile = new FileReader(); imgFile.readAsDataURL(img.files[0]); 网址：http://blog.csdn.net/qq_30632003/article/details/61201093 2、canvas的 toDataURL(imgurl)方法也可以转 3、在线工具 5.svg画图标之前项目里面用svg画过两个圆形交叠的图标，去控制进度条显示，这个和canvas很类似，可以在以后项目里多做实践，也不用发送请求 6.移动端2x、3x图按需加载这个在移动端项目里面总结过用法，其实加载还有一个比较新的属性，srcset，只是兼容性不好。 三、懒加载、预加载技术针对页面大图片比较多的情况下，要保证高清效果，还要保证加载速度，不能造成假死，用lazyload插件或者是预加载技术，懒加载是先不给图片src设置真正的地址，等到页面滚动到图片的位置的时候，再给src赋值。 四、缓存思想遇到有用递归来获取的，先把前面的结果缓存起来，下一次递归的时候，先去取值。项目里几乎没用到递归，只是总结一下这个思想。 几种cache： 1. 浏览器缓存 浏览器缓存会将部分资源缓存在本地，当用户向服务器发送请求的时候，这部分资源会直接从本地读取，避免了网络传输数据内容过多，导致访问效率变差的问题！ 2. CDN Content delivery Network 提升网站打开速度！ 3. 硬件缓存 也是为了提升访问效的！ 4. 数据库缓存 硬盘型数据库： MySQL MSSQL ORACLE 内存型数据库： MongoDB Redis 内存型数据经常被用来做缓存，提升数据存取速度！ 补充：2017.5在vue项目里面，有一个很好的方法，keep-alive，可以在当前组件切换到其他组件的时候不销毁页面和数据，而是保存在缓存里面，下一次再调用。另外lazyload也可以使用在vue里面。 五、闭包的去保存事件处理程序的兼容性测试结果js文件写的时候，比如事件处理程序兼容性封装的时候，可以考虑利用闭包的方法，不用每次都去判断浏览器是否支持某种方法，用一个浏览器，检测一次，用变量保存。这个觉得可以专门写一篇分析一下。 六、减少页面的重绘在一个后台项目里面，用模板把请求回来的数据填入模块，渲染到页面上，再下一次，只是部分数据发生变化，有几种方案可以解决，把原来的数据替换，原数组更换，渲染，或者只是把这部分用html字符串拼接方法来改变局部。最后选了后者，虽然看起来麻烦一些，但是渲染的速度更快，减少了dom操作。 七、动态创建元素，添加到页面时候的优化在页面某一部分重新请求了数据，需要重新渲染,在页面添加节点和内容的时候，既可以用document.createElement(‘p’)的方法； 也可以使用innerHTML实行字符串拼接，对于比较多的dom元素创建，比如for循环一个arr数组，然后根据里面的每一项来创建Li标签，采用innerHTML方法效率会更高； 同时，因为字符串品拼接具有不可变性，，频繁拼接会造成内存的浪费，可以考虑优化的方法： 先把每一次循环的字符串push进一个[],然后循环结束，采用arr.join(“”),转成字符串输出 一个展示在线人员图像的示例： &lt;script&gt; var datas = [ // json对象，这是一种数据传输的格式 每个大括号就是一个对象 {&quot;name&quot;: &quot;tdxy01&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;}, {&quot;name&quot;: &quot;沉眠楚人&quot;, &quot;icon&quot;: &quot;images/avatar_11.jpg&quot;}, {&quot;name&quot;: &quot;爱上karina&quot;, &quot;icon&quot;: &quot;images/75_avatar_small.jpg&quot;}, {&quot;name&quot;: &quot;today&quot;, &quot;icon&quot;: &quot;images/avatar_02.jpg&quot;}, {&quot;name&quot;: &quot;hlg&quot;, &quot;icon&quot;: &quot;images/avatar_03.jpg&quot;} ] var arr = []; for (var i = 0; i &lt; datas.length; i++) { var str = &apos;&lt;li&gt;&apos; + &apos;&lt;p&gt;&apos; +datas[i].name+ &apos;&lt;/p&gt;&apos; + &apos;&lt;span&gt;&apos;+datas[i].icon+&apos;&lt;/span&gt;&apos; + &apos;&lt;li&gt;&apos;; arr.push(str); // 将li标签添加到数组里面 } var html = arr.join(&apos;&apos;); // 将数组中的元素连接成字符串 ul.innerHTML = html; &lt;/script&gt; 。。。。未完待续，想到就补充]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面样式设置的一些总结]]></title>
    <url>%2F2016%2F08%2F16%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[移动端的页面写了几个了，除了前面的1px，rem这些坑，还有一些要考虑的问题，在这里再开一个坑，记录下来，下次少踩一点。 扩展点击区域手机端的，header部分的back按钮，需要将其点击的区域扩大，方便点击，这个用过的方法主要有两种： 利用伪元素// 扩展点击区域 extend-click() position: relative &amp;:before content: &apos;&apos; position: absolute top: -10px left: -10 right: -10px bottom: -10px 在common/css/mixin.styl里面设置，需要的时候导入 back按钮使用精灵图的时候，利用css3的background-clip和background-origin属性// back按钮，a标签设置的，利用精灵图 header a.back { left: 0px; top: 1px; background-position: -20px 0; padding: 12px 10px; // 扩展的点击区域 box-sizing: content-box; // 默认的盒子模型 background-origin: content-box; // 设置背景图片的起始位置 background-clip: content-box; // 切割，只保留content内容 } 文本超出不显示，显示省略号为文字的父元素设置，且父元素不能设置width:100% div.test { white-space: nowrap; text-overflow:ellipsis; overflow: hidden; } chorme浏览器默认的字体大小是12px，如果要设置为10px的话，会失效，需要设置-webkit-text-size-adjust: none 点击高亮问题处理ios设备上，点击按钮的是时候，屏幕会闪动一下，这是因为移动端，有事件监听的元素被点击的时候会被高亮显示，而-webkit-tap-highlight-color属性会在当用户点击iOS的Safari浏览器中的链接或JavaScript的可点击的元素时，覆盖显示的高亮颜色 -webkit-tap-highlight-color:rgba(0,0,0,0) //webkit是苹果浏览器引擎，tap点击，highlight背景高亮，color颜色，颜色用数值调节。]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端dpr不同时，2x图，3x图的处理方法]]></title>
    <url>%2F2016%2F06%2F16%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFdpr%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C2x%E5%9B%BE%EF%BC%8C3x%E5%9B%BE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前面总结了移动端页面怎么利用rem实现不同屏幕的适配，解决了尺寸一样，随页面缩放时发生变形的问题。 但是因为不同手机的屏幕分辨率不同，尤其是受高清屏的影响，有了设备的物理像素和设备的独立像素（css中的px像素）的区别，同样的页面，独立像素是640 1280，但是物理像素是320 640，写页面的时候，就需要按照 比例为2， 即 640 * 1280来准备图片。 dpr(device pixel ratio).设备像素比window.devicePixelRatio = 物理像素 / 独立像素 浏览器默认的视口获取document.documentElement.clientWidth 首先需要对视口做设置，不允许用户随意缩放： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; // 让viewport宽度 = 设备的宽度 dpr 不同，造成图片再dpr比较大的情况下，被放大，图片失真，所以需要在切图的时候准备对应的2X图和3x图，普通屏幕下，加载高清图又浪费dpr &lt;= 2时，使用2x图 apr &gt;= 2时，使用3x图 比如ipone6是375的屏，切750的2x图，3x图切1125px尺寸下的图 在项目里面，两种写法都用过，没有区别： 1.在common的mixin公共样式里面，写 // 2x和3x图切换的样式，根据media-query来判断 bg-image($url) background-image: url($url + &quot;@2x.png&quot;) @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3) background-image: url($url + &quot;@3x.png&quot;) // $url是前缀，用的时候，先@import引入公共样式，然后 img { bg-image(&apos;beijing&apos;) } 2.也是在公共样式mixin里面写，这个时候根元素里面也需要设置了data-dpr img-dpr(){ background-image: url(image.jpg);//默认 [data-dpr=&quot;2&quot;] &amp; { background-image: url(image@2x.jpg);//两倍高清 } [data-dpr=&quot;3&quot;] &amp; { background-image: url(image@3x.jpg);//三倍高清 } } 先引入mixin样式 .content{ img-dpr(); } 雪碧图使用rem造成像素偏差的问题解决办法：1.先放大100倍，提高图片精度，找到图片位置，再缩小100倍 .icon-fix { background: none; position: relative; overflow: hidden; } .icon-fix:after { content: &apos;&apos;; display: block; width: 10000%; height: 10000%; position: absolute; left: 0; top: 0; background-image: url(sprite.png); background-repeat: no-repeat; background-size: 140rem; -webkit-transform-origin: 0 0; -webkit-transform: scale(.01); transform-origin: 0 0; transform: scale(.01); } .icon3:after { background-position: 0 -280rem; }]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端高清、多屏幕适配方案总结-rem]]></title>
    <url>%2F2016%2F06%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%AB%98%E6%B8%85%E3%80%81%E5%A4%9A%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93-rem%2F</url>
    <content type="text"><![CDATA[这篇文章，算是对学习rem及用在手机端项目里面的一个汇总。 rem是什么？在开发移动端h5页面的时候，一套设计图，需要适配不同尺寸的手机，手机的分辨率也不同。所以不能把单位写死为xxpx。 这里对rem、px、em做一个区分： px是绝对字体大小，但是页面缩放的时候因为字体不变，网页还是那么大，会变形。 em计算方式是乘以当前对象从父级遗传的字体大小，参考对象是一个变化的值 父级： height: 1em; // 16px,如果html的font-size是100% 子元素： font-size: 0.625em // 16 * 0.625 = 10px height: 1em // 实际上是10px rem是rem是基于根节点html的字体大小进行计算，浏览器一般默认字体是16px,1em = 16px;但是是css3的新属性，不支持ie678，兼容性处理，再写px或者100% 1.5rem = 根节点默认字体大小 * 1.5 = 24px; // 转化的时候，可以用 28px = 28/16 = 1.75rem 可以把根节点设置为10px或62.5%（100%是16px），方便以10计算而不是16，为了兼容IE7和ie8,默认字体可以设置为： html { font-size: 62.5%; } 利用rem实现多屏幕适配的思路相同的rem,只需要更改页面根元素html的font-size,把和元素尺寸有关的css，如width,height,line-height,margin,padding等都以rem作为单位,这样页面在不同设备下就能保持一致的网页布局，也解决了1px的问题。 怎么判断屏幕的尺寸（宽度），去动态的调整html的font-size？方法一、css media query@media screen and (max-width: 320px) { html{ font-size: 14px; } } @media screen and (min-width: 321px) and (max-width: 413px) { html{ font-size: 16px; } } @media screen and (min-width: 414px) and (max-width: 639px) { html{ font-size: 17px; } } @media screen and (min-width: 640px) { html{ font-size: 18px; } } 方法二、通过js来判断页面宽度，动态调整html的font-size 方法三、引入淘宝的lib-flexible地址：https://github.com/amfe/lib-flexible使用文档说明：http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html1.把flexible.js和flexible_css.js引入，放在head标签的utf-8meta标签下面此时不用再写 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; 2.此时,F12,会发现ip6下面，html的font-size会自动被设置为font-size: 75px（设计稿的尺寸是750），也会给html元素上增加一个data-dpr属性，js会根据不同的设备添加不同的data-dpr值，比如ip6是2. 3写css样式的时候，其他样式尺寸设置为rem，根据标注稿尺寸 / 标注稿基准字体大小来转换 1）实现定义了一个变量来保存基准字体大小 @font-size-base: 75; 2）某一个元素的尺寸设置方式： .item { width: 350rem/@font-size-base; // 350 / 70 = 5rem height: 80rem/@font-size-base; } 标注稿基准字体大小 = 标注稿宽度 / 10，如标注稿宽为750，标注稿基准字体大小为75；标注稿宽为640，标注稿基准字体大小为64；（所以淘宝这个方案是可以在任意设计稿尺寸下使用的） 4.如果还需要设置某一个元素的字体大小，可以根据html的data-dpr属性来处理，写法如下： [data-dpr=&quot;2&quot;] p { font-size: 16px; } [data-dpr=&quot;3&quot;] p { font-size: 24px; } dpr(device pixel ratio).设备像素比；i5,6 = 2;i6plus=3; 使用rem时候的问题，最多的问题就是 小数像素造成background-image 的问题，经常会因为小数像素导致背景图被裁掉一部分。所以可以的话，尽量使用iconfont,或者尽量给背景图设置一定的空白间隙]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github使用之将项目推送到远程仓库]]></title>
    <url>%2F2016%2F03%2F15%2Fgithub%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[总结一下在本地创建好项目之后，把项目推送到github上的步骤： 1 在github创建一个远程仓库2 进入你需要需要创建的文件夹下面，比如，我一般都放置在D/git目录下，点击git bush,运行： $ git clone 仓库地址 可以看到git文件夹下面已经有了一个和远程仓库同名的仓库 3 将你已经完成的项目拷贝过去 4 git切换到当前目录 5.git log 查看日志 6.git status 查看当前状态可以看到未追踪的和已修改的文件 7.如果有.project这样的隐藏目录，不需要提交到github,创建一个ignore文件 $ touch .gitignore 8.把需要忽略的文件写进gitignore里面，如果是忽略文件夹，在后面加/，如$ echo .dir/ &gt;&gt; .gitignore,忽略所有的隐藏文件，.* &gt;&gt; $ echo .project &gt;&gt; .gitignore 9.git status 查看状态 10.把.gitignore自身也忽略不提交 $ echo .gitignore &gt;&gt; .gitignore 如果想操作.gitnore里面的文件，用vi .gitignore进入操作，完成后退出 12.添加到本地仓库 git add -A 13.提交到本地仓库 git commit -m &apos;描述信息&apos; 14 git log 查看日志 15.push到远程仓库,第一次Push加-u $ git push -u origin master 16.下一次需要修改增加项目的时候，先去远程仓库上拉取 $ git pull origin master]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端底部tab或按钮显示问题-css sticky footer]]></title>
    <url>%2F2016%2F03%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BA%95%E9%83%A8tab%E6%88%96%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98-css%20sticky%20footer%2F</url>
    <content type="text"><![CDATA[问题： 项目里面需要设置一个弹出框，下面有一个浮层，浮层上面，分别是内容区块和底部关闭按钮，要求关闭按钮总是固定在窗口底部。 但是实际遇到的问题是，页面内容不够长的时候，页脚块固定在视窗底部；页面内容足够长，需要滚动的时候，页脚块随着内容向下推送，而不是固定视窗底部，挡住了页面的文字。 解决方法：设置三个层，一个内容的包裹层，里面再有一个层，是内容；再有一个层是底部层 // wrapper层 &lt;div class=&quot;detail&quot;&gt; // 和关闭按钮并列的层 &lt;div class=&quot;detail-wrapper clearfix&quot;&gt; // 里面的主题内容层 &lt;div class=&quot;detail-main&quot;&gt;&lt;/div&gt; &lt;/div&gt; // 关闭按钮层 &lt;div class=&quot;detail-close&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; // 样式 .detail /*设置全屏效果，占满视窗*/ position: fixed z-index: 100 top: 0 left: 0 width: 100% height: 100% overflow: auto background-color: rgba(7, 17, 27, 0.8) // filter: blur(10px) // 内容的wrapper层也宽高也占满100%，占满屏幕 .detail-wrapper min-width: 100% height: 100% .detail-main margin-top: 64px padding-bottom: 64px (这个是关键，设置一个下padding，给底部留出空间) .detail-close // 和wrapper层一个层级，wrapper层占有100%的高度，所以footer层永远在视口之外，需要下面用-margin-top调整至视口之内 position: relative width: 32px height: 32px margin: -64px auto 0 auto // 设置一个-margin,将自己放置在上面预留的-margin处 clear: both font-size: 32px]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[培训系统项目总结]]></title>
    <url>%2F2016%2F03%2F11%2F%E5%9F%B9%E8%AE%AD%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[加入这个公司这么久了,好像现在才真正的松了一口气.才入职,看项目源码,官网还是用table布局的时候，真的让我倒吸一口气，很想立刻离职的，因为那个时候意识到传统公司，业务重心不在你的工作内容上面的时候，做开发，尤其是前台开发是一件多么无奈的事。 当你面临甚至没有产品经理，没有ui妹子，有的只是大领导的一个指示，有的只是hr培训人员不断变化的要求，更甚至一份需求确认书小小的变动都需要大领导审批一周的时候，只能感到深深的心累。但是还是庆幸坚持下来了，完成了这三十多个页面的静态页面的编写，终于要迎来业务逻辑的处理了。 吐槽这么多，进入正题，用以记录一下这个历程。 requireJS组织js的加载因为页面比较多，所以考虑之后，和老大商量，用requieJS来加载js逻辑部分的代码，为了结构更清晰，在html文件夹下放各个页面的html文件，在js文件夹下面放对应的页面的js文件，这样也便于页面的维护。 在js和html文件夹下面都建立了common，里面放置公共的html部分，比如header和footer,因为这一次后台环境是杨哥用php来写的，所以用了php的include方法来把公共页面加载到需要的页面里面。 common.js里面，把一些工具函数做了抽取，比如首页和分页都用的轮播图，没有用之前的轮播图插件，因为此处轮播图插件就只有上一页，下一页，自动轮播这几个基本功能，代码相对并不多，所以这里重新写了一遍，也算是加深记忆。 兼容性方面处理这次的项目对兼容性要求不高，不要求必须适配IE8以下，所以后台就用了bootstrap来写，但是多浏览器还是需要兼容的。 禁止ctrl+滚轮，放置页面放大缩小为兼容火狐滚轮事件用”DOMMouseScroll” if (document.addEventListener) { document.addEventListener(&apos;DOMMouseScroll&apos;, scrollFunc, false); } //W3C window.onmousewheel = document.onmousewheel = scrollFunc;//IE/Opera/Chrome/Safari /** * 禁用ctrl+滚轮，防止页面放大缩小 * @param e */ var scrollFunc = function (e) { e = document.all ? window.event : arguments[0] ? arguments[0] : e; if (e.wheelDelta &amp;&amp; event.ctrlKey) {//IE/Opera/Chrome e.returnValue = false; } else if (e.detail) {//Firefox e.returnValue = false; } } 首页做成了单页应用为了不用每次整个页面去请求数据，采用了单页面开发的方法，借助第三方库PathJS https://github.com/mtrpcic/pathjshttp://git.oschina.net/yswang/PathJS看了源码，是listen页面的hashchange的变化，然后去加载对应的js模块 在main.js里面处理，点击当前页面的时候，获取当前的location.hash common.js页面多出用到s.ajax方法，将其封装到common.js里面 //ajax统一请求 excommon.requestService = function (url, types, param, callback, requstType) { var result = {}; $.ajax({ async: false, timeout : 10000, //超时时间设置，单位毫秒 url: preurl.BATHPATH + url, type: types || &apos;get&apos;, data: param, success: function (data) { result = data; isJumpToLogin(data); if (callback) { callback(data); } }, error: function (XMLHttpRequest, textStatus, errorThrown) { if (callback) { //callback({error: errorThrown}) } } }); return result; }; sideBar的菜单导航，一级菜单和二级菜单登陆模块处理用jquery.validate插件做正则校验； 用jquery.form处理表单提交事件 github地址 提交 ajaxSubmit 根据form表单的数据发送ajax请求，适用于不能直接提交，需要先阻止表单的默认行为，处理表单请求数据的情况，这种情况下表单提交的数据可能从form表单厘米那不能直接完全获取。+处理之后，需要点击submit，手动提交1234567891011$('form').on('submit', function () &#123; $(this).ajaxSubmit(&#123; url: url, type: 'post', data: &#123;newProperty: '额外添加的属性'&#125;, success: function (data) &#123; console.log(data); &#125; &#125;); return false;&#125;); 项目里面的代码示例：12345678910111213141516171819202122//不能点击时直接提交，需要先或者后操作事件，手动提交 function profileSubmit(data) &#123; $(".settings form").on("submit", function(e) &#123; e.preventDefault(); //阻止表单的默认提交行为 //发起ajax请求 $(this).ajaxSubmit(&#123; data: &#123; //关键是添加的请求数据 tc_id: data.result.tc_id, tc_hometown: $("#p").find(":selected").text() + "|" + $("#c").find(":selected").text() + "|" + $("#b").find(":selected").text(), tc_province: $('#p').val(), tc_city: $('#c').val(), tc_district: $('#d').val() &#125;, success: function() &#123; location.reload(); //页面刷新 &#125; &#125;); //为了兼容老版本ie return false; &#125;) &#125; ajaxForm 监听表单submit事件，并阻止默认的提交,如果提交按钮不是type=”button”或者是用a标签来写按钮，要先把a标签换成button 然后根据form表单的数据发送ajax请求 12345678$(this).ajaxForm(&#123; url: url, type: 'post', data: &#123;newProperty: '额外添加的属性'&#125;, success: function (data) &#123; console.log(data); &#125;&#125;); 项目里面的代码示例： 12345678910111213//监听表单提交事件，转为ajax请求，请求成功，那么跳转到首页 $("#login-form").ajaxForm(&#123; success: function(data) &#123; //data.result是一个对象，将其转成字符串来作为cookie的key对应的value的值 var cookieVal = JSON.stringify(data.result); // 设置一个在当前域名下，根目录下面皆可以共享的cookie $.cookie("userInfo", cookieVal, &#123;path: '/', &#125;); location.href = '/'; &#125;, error: function() &#123; alert('登录失败！'); &#125; &#125;); jquery-ajax全局事件 如果使用了jquery的ajax相关方法发送请求，那么jquery就会在document触发上触发几个jquery定义的事件。 事件种类 ajaxStart 在请求刚刚发送出去时，该事件被触发。 如果同时发送多个请求，只有第一个请求会触发该事件。 ajaxSend 在请求刚刚发送出去时，该事件被触发。 如果同时发送多个请求，每一个请求都会触发该事件。 ajaxSuccess 每有一个请求成功，或数据按照指定的方式解析成功，就会触发该事件。 ajaxError 每有一个请求失败，或数据解析失败，就会触发该事件。 ajaxStop 请求完成后触发该事件，不在乎请求是否成功。 如果同时发送多个请求，只有最后一个请求会触发该事件。 ajaxComplete 请求完成后触发该事件，不在乎请求是否成功。 如果同时发送多个请求，每一个请求都会触发该事件。应用场景 我们的页面可能同时发送多个ajax请求， 通常我们会在第一个请求发送后展示一张loading图片， 最后一个请求结束后隐藏loading图片， 那么对应的两个事件就是ajaxStart和ajaxStop。 在util.js里面设置123456789101112131415161718192021222324252627282930313233343536/** * Created by gibson on 2017/5/11. */define(['jquery', 'jquery_cookie', 'nprogress'], function($, ud, nprogress) &#123; return &#123; //封装一个检测登陆状态的方法，如果还没有登陆过，链接到该页面时是不成功的，默认跳转到登陆页面 //但是这个规则对登陆页面不起作用，所以封装的时候不能直接执行，需要给一个接口，调用才执行 checkLoginStatus: function() &#123; if(!$.cookie("PHPSESSID")) &#123; location.href = '/html/home/login.html'; &#125; &#125;, // 设置网站的进度条，应用了一个插件 nprogress: function() &#123; //显示加载完成的画面 nprogress.done(); &#125;, loading: function() &#123; $(document).on("ajaxStart", function() &#123; $(".overlay").show(); &#125;).on("ajaxStop", function() &#123; $(".overlay").hide(); &#125;); &#125;, getSearchVal: function(searchKey) &#123; var searchObj = &#123;&#125;; var unitArr = []; var searchArr = location.search.slice(1).split("&amp;"); for(var i = 0, len = searchArr.length; i &lt; len; i++) &#123; unitArr = searchArr[i].split("="); searchObj[unitArr[0]] = unitArr[1]; &#125; return searchKey ? searchObj[searchKey] : ""; &#125; &#125;&#125;) 使用的时候，发起ajax请求前，先加载loading事件//发起ajax时，加载Loading事件 util.loading(); 登陆模块处理逻辑监听登陆注册表单提交事件，发送ajax请求，如果成功，那么后台会返回一个sessionId,浏览器会自动设置cookie,将其存储，并在每次发送ajax请求的时候，将sessionId传到后台，作为身份的标识。 用cookie将返回的信息存储起来，进入其他页面的时候取出来进行判断，即可进行权限验证 //data.result是一个对象，将其转成字符串来作为cookie的key对应的value的值 var cookieVal = JSON.stringify(data.result); // 设置一个在当前域名下，根目录下面皆可以共享的cookie $.cookie(&quot;userInfo&quot;, cookieVal, {path: &apos;/&apos;, }); 退出模块的逻辑]]></content>
  </entry>
  <entry>
    <title><![CDATA[手机端click事件时的点透问题]]></title>
    <url>%2F2016%2F03%2F05%2F%E6%89%8B%E6%9C%BA%E7%AB%AFclick%E4%BA%8B%E4%BB%B6%E6%97%B6%E7%9A%84%E7%82%B9%E9%80%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[移动端点透事件，其实网上已经大把这样的案例说明和解决方法，项目里面遇到过一次之后，就已经解决了。 点透事件的原理根据遇到的问题来分析，项目里是一个页面要做一个弹出层，弹出层后面有一个mask，点击mask的时候，弹出层隐藏，但是触发了主页面的input输入框的焦点。 原因就是移动端click有300ms的滞后性，要去判断你是不是缩放，还会不会双击。所以touchend的时候，先隐藏了弹出层和mask，后面真正的点击事件到来的时候，点击的是下面一层。 解决方法： 给这个事件添加阻止默认事件方法：e.preventDefault();但是每一次都要添加，很麻烦。封装了一个tap事件，利用touch事件的执行时机比click要早，通过事件的判断来进行逻辑处理tap.js如下： // 参数1 dom元素 参数2 回调函数 function tap(dom,callBack) { /* tap是轻敲 1. 手指 放上去 离开的速度 很快 2. 手指如果放上去之后 移动了 失效 3. 手指放上去 按了超过一定时间（长按） */ // 获取起始时间 var startTime; var isMove = false; // 标识符 dom.addEventListener(&apos;touchstart&apos;, function (event) { startTime = Date.now(); // 还原isMove的值 isMove = false; }) // 进入到这个事件中 说明 移动了 dom.addEventListener(&apos;touchmove&apos;, function (event) { // console.log(&apos;move&apos;); isMove = true; }) // 计算 停留的时间 dom.addEventListener(&apos;touchend&apos;, function (event) { var delayTime = Date.now() - startTime; // 如果移动了 也失效 if (isMove == true) { // console.log(&apos;移动了，失效&apos;); return; } // 判断停留时间，是否太久了 // 这里的时间 可以根据需求调整 if (delayTime &gt; 300) { // console.log(&apos;太久了，失效&apos;); return; } // 正常执行 // console.log(&apos;轻敲&apos;); callBack(); }) } 用FastClick原理：FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟click 事件，并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。 地址：https://github.com/ftlabs/fastclick/ 用法：1.引入js 2.绑定在document.body上 if (&apos;addEventListener&apos; in document) { document.addEventListener(&apos;DOMContentLoaded&apos;, function() { FastClick.attach(document.body); }, false); } $(function() { FastClick.attach(document.body); }); var attachFastClick = require(&apos;fastclick&apos;); attachFastClick(document.body); fastclick源码分析，转：https://segmentfault.com/a/1190000005850383（转）]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requireJS]]></title>
    <url>%2F2016%2F01%2F17%2FrequireJS%2F</url>
    <content type="text"><![CDATA[requireJsAMD（ Asynchronous Module Definition）异步加载模块定义 AMD规范化加载的由来 前端的模块化，是参照commonjs规范实现的，有一个全局性的方法require(),用于加载模块，如果有一个add.js，加载的时候，直接使用var add = require(“add”)就可以实现，使用时直接调用add方法，因为在服务端，模块是放在硬盘里面，加载的很快，几乎可以同步读取。 但是在客户端，使用这种方法加载，因为模块放在服务端的，读取的时间取决于网速的快慢，可能会等待很长时间，没有加载完，后面的就不能执行，会造成浏览器假死状态。 所以浏览器模块的加载，不能使用同步，需要异步加载，所以有了AMD规范。即异步模块定义 123456789101112131415161718192021 require([&quot;add&quot;], function(add) &#123; &#125;) ``` 使用require()来加载，第一个参数是模块，是一个数组，第二个参数是回调函数，依赖这个模块的语句，放在回调函数里面，加载完成之后，才会运行回调函数。使用AMD规范的库，用过的是require.js。### requireJs解决的问题- 当一个网页要引入多个外部文件，且文件之间的依赖关系较强的时候，必须保证文件的加载顺序，并且当浏览器加载外部文件的时候就会停止网页的渲染，加载的文件越多，网页失去响应的时间越长，代码的编写和维护也会很麻烦。- requirejs实现了js 文件的异步加载，避免网页失去响应- 管理模块直接的依赖性，便于代码的编写和维护。- 解决了命名冲突问题（不同模块中的同名变量不会有冲突）### requirejs的基本使用### 主模块- 如果主模块不依赖于其他模块 // data-main的作用是指定网页程序的主模板，即main.js。这个文件会第一个被require.js加载。main是省略了后缀名js ```]]></content>
      <categories>
        <category>Javascript</category>
        <category>requireJs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闭包学习笔记]]></title>
    <url>%2F2015%2F12%2F31%2F%E9%97%AD%E5%8C%85%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天又是一年的平安夜，还是不去人潮里面凑热闹了，一个人的平安夜是虐狗夜，静静的打开电脑，让蓝光屏映在脸旁，再啃一个发的大苹果，继续来学习之旅吧。 闭包知乎上一大把问题和答案，博客也是，早已经被各位大牛分析的很透彻了，但是对小菜鸟来说，不懂依然迷迷糊糊，希望能通过这篇学习笔记，有进一步的认识吧。 闭包的概念函数局部变量在外部是不可以访问的，这个时候，我们就可以在函数内部创建一个函数，这个内部函数就有权访问原函数的私有变量，再把这个内部函数返回出去，在外部调用这个内部函数。 总结起来： 1.函数嵌套函数； 2.能在函数外部访问函数内部声明的变量 闭包的基本模式function add(outerArg) { function inner(innerArg) { return innerArg + outerArg } return inner; } var addTen = add(10); console.log(addTen(1)) // 输出11 console.log(addTen(2)) // 输出12 本质是利用函数的作用域链，函数内部定义的函数，会把外部函数的作用域中的对象添加到自己到作用域链中，因为子对象可以沿着作用域链向上查找父对象的变量。 在外部函数执行完的时候，执行环境（变量）本来应该被销毁，但是因为被return出去的内部函数还在引用外部函数的变量，所以外部函数的变量不会被销毁，仍然保留在内部函数的作用域链里面，直到内部函数被销毁之后，外部函数的变量才会跟着销毁。 闭包调用方式不同，结果不同如果只调用1次外部outer函数，那么多次使用outer()返回的值访问的变量是同一个变量，如果多次调用外部函数，那么每次调用都生成一个新的变量 &lt;script&gt; function func() { var num = Math.random(); return function () { return num; } } //每次的结果相同，因为外部函数func只调用了一次，只开辟了一次空间，存储了num的值，里面的函数每次调用时引用的变量都相同 // var num = func(); // console.log(num()); // console.log(num()); // console.log(num()); //每次结果不同，因为每次调用func的时候都开辟了一个新的空间，所以彼此之间是独立的，作用域是兄弟关系，没有直接联系，互相无法访问，每一次调用时num都生成新的值 console.log(func()()); console.log(func()()); console.log(func()()); &lt;/script&gt; 闭包的用途1.可以使用闭包保护变量，防止放在外部的变量被别人随意修改，使用闭包，可以给别人提供一个访问变量的接口，在定义接口的时候，在为别人提供的修改变量的方法中设置一些校验逻辑，来判断用户设置的数据的合法性 function func(){ var name = &quot;小明&quot;; var yanzhi = 99999999999; var obj = { setYanZhi: function(value){ if(value &lt; 999999999999){ throw &quot;你是不是不想混了！&quot;; } }, getYanZhi: function(){ return yanzhi; } } return obj; } //小同 var o = func(); o.setYanZhi(9999999999999); console.log(o.getYanZhi()); 2.保护变量，暴露接口，获取元素的所有子元素方法 function outer(){ var list = []; function getChildren(ele){ //1. 获取所有的子元素 var children = ele.children; //2. 遍历所有的子元素 for(var i = 0; i &lt; children.length; i++){ var child = children[i]; list.push(child); getChildren(child); } } return { getChildren: getChildren, list : list }; } // var o = outer(); // o.getChildren(body); // o.list就可以访问获取到的结果了！ 闭包的缺陷1.会把外部函数的活动对象都添加到自己的作用域链上，会比普通的函数更耗费内存； 2.垃圾回收机制发现闭包外部函数的变量有人使用的时候，就不会回收。所以会占用内存 闭包的应用场景tab栏切换tab栏切换的时候，给ul下面的每一个li添加点击事件，点击的时候，需要获取当前的li的索引 &lt;ul&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt; &lt;li&gt;item5&lt;/li&gt; &lt;/ul&gt; var list = document.getElementsByTagName(&apos;li&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { list[i].onclick = function() { alert(i); //i=5 } } 点击任意一个li的时候，i的值总是5 因为onclick事件是被异步触发的，先执行的是for循环的同步事件，执行完i是5，onclick被触发的时候，i是5 解决方案1,遍历的时候添加自定义属性index，点击的时候获取： var list = document.getElementsByTagName(&apos;li&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { // 循环的时候就给每一个btn设置自定义属性 list[i].index = i; list[i].onclick = function() { alert(this.index); //解决了问题 } } 解决方案2：闭包，每次一for循环的时候，将i的值存储起来 var list = document.getElementsByTagName(&apos;button&apos;); for(var i = 0, len = list.length; i &lt; len; i++) { // 创建一个闭包 function outer(){ var j = i; function func(){ alert(j); } return func; } var f = outer(); //关键是这一步，for循环的时候就执行了 list[i].onclick = f //每次循环都存储i的值 } // 简化版： for(var i = 0, len = list.length; i &lt; len; i++) { // 创建一个闭包 list[i].onclick = function(j) { return function(){ alert(j) } }(i) } 保护私有变量写js代码的时候，为了防止全局变量污染，也为了别人不能随意更改自己的变量值，所以经常会把自己的代码写在一个自执行函数里面。 但是又想向外面暴露接口，修改里面的值和获取里面的值，修改的时候设置校验条件，判断用户设置的值的合法性，就可以考虑闭包。 var foo = (function(){ var secret = &apos;secret&apos;; return { get_secret: function() { return secret; }, set_secret: function(newValue) { if（newValue &lt; 0）{ throw(&apos;修改值不符合要求&apos;); } secret = newValue; } } }()) foo.get_secret() //&apos;secret&apos; foo.secret // 不能访问 foo.set_secret(&apos;new_secret&apos;); foo.get_secret() // new_secret 解决for循环里面setTimeout问题for(var i = 0; i &lt; 5; i++){ setTimeout(function(){ console.log(new Date, i); }, 1000); } console.log(new Date, i); // 异步的，先for循环完毕，i为5,然后一下子打印5个5 // 5-》5，5，5，5，5 // 解决方法：闭包 for(var i = 0; i &lt; 5; i++){ function outer(){ var j = i; function inner(){ console.log(j); } return inner; } var f = outer(); //每一次for循环都会执行Outer函数，开辟内存，保存当时的i变量 setTimeout(f, 1000); } // 简化之后 for (var i = 0; i &lt; 5; i++) { (function(j) { // i = j setTimeout(function() { console.log(new Date, j) }) })(i) } 或者：闭包的另一种做法： var output = function (i) { setTimeout(function() { console.log(new Date, i); }, 1000); }; for (var i = 0; i &lt; 5; i++) { output(i); // 这里传过去的 i 值被复制了 } console.log(new Date, i); 补充： 其实如果不是需要在外部打印，其实可以用let作用域，把var换成let，就解决了问题。因为let只作用在循环内部的作用域。 补充：看到简书上一个对闭包进一步深化的学习，解决这个问题的需求和答案： 问题： 如果期望代码的输出变成 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？新的需求可以精确的描述为：代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5 1.简单粗暴的解决方法： for (var i = 0; i &lt; 5; i++) { (function(j) { setTimeout(function() { console.log(new Date, j); }, 1000 * j)); // 这里修改 0~4 的定时器时间 })(i); } setTimeout(function() { // 这里增加定时器，超时设置为 5 秒 console.log(new Date, i); }, 1000 * i); 2.虽然解决了问题，但是没有联想起异步操作的Promise方法在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情，代码该怎么组织？ const tasks = []; for (var i = 0; i &lt; 5; i++) { // 这里 i 的声明不能改成 let，如果要改该怎么做？ ((j) =&gt; { tasks.push(new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(new Date, j); resolve(); // 这里一定要 resolve，否则代码不会按预期 work }, 1000 * j); // 定时器的超时时间逐步增加 })); })(i); } Promise.all(tasks).then(() =&gt; { setTimeout(() =&gt; { console.log(new Date, i); }, 1000); // 注意这里只需要把超时设置为 1 秒 }); 下面代码会更简洁明了一些 const tasks = []; // 这里存放异步操作的 Promise const output = (i) =&gt; new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(new Date, i); resolve(); }, 1000 * i); }); // 生成全部的异步操作 for (var i = 0; i &lt; 5; i++) { tasks.push(output(i)); } // 异步操作完成之后，输出最后的 i Promise.all(tasks).then(() =&gt; { setTimeout(() =&gt; { console.log(new Date, i); }, 1000); }); 之前看过几次阮一峰的ES6的Primise讲解，但是实践中用的还是不多，找时间可以再去研究一下。 再补充：佩服原作者的好学精神，还给出了es7的解决方案： // 模拟其他语言中的 sleep，实际上可以是任何异步操作 const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; { setTimeout(resolve, timeountMS); }); (async () =&gt; { // 声明即执行的 async 函数表达式 for (var i = 0; i &lt; 5; i++) { await sleep(1000); console.log(new Date, i); } await sleep(1000); console.log(new Date, i); })(); 这个先占坑，之后再学习一下es7，感觉快跟不上时代了。。。 闭包的优化 比如说一个外部函数，里面定义一个内部函数，我只想用这个内部函数去引用外部函数的一个属性值，但是闭包会把外部函数的所有属性和方法都添加到内部函数的作用域链上，导致占用不必要的内存。 可以把要引用的变量用另外的值保存下来，然后把引用的对象设置为null。 function Outer() { var obj = {}; obj.id = &apos;12345678&apos;; obj.name = &apos;aha&apos;; // ... 假设经过很多处理过程，最后obj上带有很多属性 return function() { return obj.id; }; } function AnotherOuter() { var obj = {}; obj.id = &apos;12345678&apos;; obj.name = &apos;aha&apos;; // ... 假设经过很多处理过程，最后obj上带有很多属性 var id = obj.id; obj = null; return function() { return id; }; }]]></content>
      <categories>
        <category>Javascript</category>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端1px的border问题]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E7%9A%84border%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近做一个移动端的页面，踩了很多坑，也有很多小细节，终于找个时间总结一下，记录下来。 问题： 页面中很多border-bottom被设置为1px,在桌面端的时候，没有问题，但是到手机端，看起来会是2px,因为手机的有一个设备像素比，是两倍,设置的是1px，在2倍的像素比下，就是2px. 解决方法： 因为像素不可能是0.5px,最小单位是1px，所以考虑用css3的伪类 + transform方法对其做scale缩放 把原来的border去掉，利用：after重新做border,定位于原来的元素。 并且由于不同设备像素比，缩放比例需要不同。 因为在项目里面使用的比较多，为了增强复用性，需要单独创建一个文件，比如：css/mixin.css，使用的时候将这个文件用@import引入进来 css/mixin.css 设置： /*设置一个border-top为1px的伪类*/ .border-1px { position: relative; border: none; } .border-1px:after { display: block; position: absolute; left: 0; bottom: 0; // 因为设置的是border-bottom width: 100%; border-top: 1px solid #ccc; //height: 1px; content: &apos;&apos; } 注意：stylus或less或sass的写法： .border-1px ($color) { // 样式 &amp;:after // 样式 // 把颜色换成$color } /* 如果是需要设置border-top,用before伪类,设置伪类的border-bottom 但是此时的1px还是和原来直接设置border-bottom: 1px 一样的，并没有缩放效果 */ /*根据设备像素比，用media query来判断，做不同缩放，保证缩放完毕的值 * 设备像素比 = 1px*/ // 在设备像素比是1.5和2时候用scale做缩放 @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7) @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 用法： 1.先引入定义的公用样式，用 @import &apos;地址&apos; 2.设置给需要的元素，比如item元素 .item { border-1px(&apos;#ccc&apos;) // 设置1px的border-bottom }]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件知识学习总结]]></title>
    <url>%2F2015%2F06%2F18%2F%E4%BA%8B%E4%BB%B6%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[事件概念 用户或浏览器自身执行的某种动作，页面和用户交互的瞬间，比如clcik等； 事件流概念 是从页面中接收事件的顺序，或者说是在页面中传播响应的顺序，是从里面向外面流的，还是从外面向里面流的。 dom事件流DOM事件流，就是事件发生的时候，dom树从目标元素到根元素，按照特定的顺序传播，路径上所有的节点都会接收到该事件；IE不支持dom事件流。 冒泡型事件流和捕获型事件流冒泡型事件流： 从特定的事件目标开始接收到事件，从树叶到树根传播。 比如从div》body&gt;html&gt;document，是大部分浏览器默认的方式 事件捕获型 从最不特定的事件目标开始传播到你意向的事件目标，和冒泡型是相反的。 DOM2级事件流规定事件发生时，包括三个阶段： 事件捕获阶段-处于目标阶段-冒泡阶段，只有在冒泡阶段，才会对事件做出响应。事件捕获阶段，从html到body就停止了。 IE和DOM事件流的区别 IE是冒泡，div-&gt;body-&gt;doucment DOM事件流：先事件捕获，再到目标元素，最后事件冒泡阶段响应事件，document -&gt; body -&gt; div -&gt; (click) -&gt; div -&gt; body -&gt; document 事件处理程序事件处理程序默认是采用了事件冒泡机制，如果想用事件捕获，可以这样设置：btn.addEventListener(“click”, function(){}, false); // 在冒泡阶段响应 用闭包的方式封装事件处理程序注意他们的参数不同 addEventListener的参数是type,handler,false 而IE是”on”+type,比如onclick回调函数handler的this指向和event事件对象不同 attachEvent事件中listener调用时，因为IE和chrome调用的方式不同，chrome调用时是将e作为参数传入进入的，el.onclcik = function (e) ; 而IE是var func = el.onclcik; func(); // IE事件没有传递event参数，且执行时this指向window对象，所以listener执行的时候，无法直接获取event事件对象，也无法让直接调用this = el， // 所以需要想办法将listener执行时获取window.event参数，且this指向el.onclick的el对象。 // 解决方法： function createEventRegister() { if (document.addEventListener) { return function(ele, type, eventHandler) { ele.addEventListener(type, eventHandler); } } else if (document.attachEvent) { return function(ele, type, eventHandler) { ele.attachEvent(&apos;on&apos; + type, function() { // 重点 eventHandler.call(ele, window.event); // 用call改变this指向为当前的事件函数，参数为当前的e对象 }) } } else { return function(ele, type, eventHandler) { ele[&apos;on&apos; + type] = eventHandler; } } } 事件委托/事件代理 利用事件冒泡的原理，把自己所触发的事件交给父元素（广义的，祖先元素）代替执行，可以解决： 1.可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒，因为每个函数都是对象，都会占用内存，内存的对象越多，性能就越差； 2.当父元素下面的子元素是动态生成的，那么原先绑定的方法在新添加的元素上就不适用了，可以利用事件代理，绑定在父元素上。 典型的例子是创建li的时候，如果是ul.innerHtml的方法创建的，新老的Li都没有方法了，如果是通过append方法添加，那么原来的Li有，新的Li 没有原来的方法了。 事件代理的封装一、给ul下面的每一个标签注册同样的事件： //parentEle是父元素dom元素，tag是子元素，可以用li的class名，&quot;.save&quot;， //或者是&apos;li&apos;tag标签 function delegate(parentEle, tag, event, listener) { parentEle.addEventListener(event, function(event) { event = event || window.event; var target = event.target || event.srcElement; if (target &amp;&amp; target.tagName === tag.toUpperCase()) { listener.call(target, event); //this指向target对象 } }) } //使用示例： delegate(ul, &apos;li&apos;, &apos;click&apos;, function() { alert(this.innerHTML); }) 二.给其中的某一个li标签注册事件 function delegate(parentEle, childId, event, eventHandler) { parentEle[&apos;on&apos; + event] = function(ev) { ev = ev || window.event; var target = event.target || event.srcElement; if (target &amp;&amp; target.id === childId) { eventHandler(); //或者 //eventHander.call(target, event); } } } //使用示例 delegate(ul, &quot;inner&quot;, &quot;click&quot;, function(){ alert(1); }) jQuery中的事件代理$(function(){ $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function(){ console.log(this); }) }) $(&quot;ul&quot;).on(&quot;click&quot;, &quot;a&quot;, function(e) { console.log(e.currentTarget); // jquery里面e事件对象包装了一层 }) 如何阻止事件冒泡和默认事件阻止事件冒泡 阻止事件冒泡,使成为捕获型事件触发机制.比如只希望点击事件发生在子元素身上，不希望发生在父元素身上 function stopBubble() { var e=arguments.callee.caller.arguments[0]||event; //如果提供了事件对象，则这是一个非IE浏览器 if ( e &amp;&amp; e.stopPropagation ) //因此它支持W3C的stopPropagation()方法 e.stopPropagation(); else { //否则，我们需要使用IE的方式来取消事件冒泡 window.event.cancelBubble = true; } } // 一般在IE环境下可以省略掉（var e=arguments.callee.caller.arguments[0]||event;） 直接运行即可，但是在FF下不行了，它会报e.stopPropagation没有定义，所以要事先定义，才能兼容。 阻止默认行为 当按键后,不希望按键继续传递给如HTML文本框对象时,可以取消返回值.即停止默认事件默认行为. //阻止浏览器的默认行为 function stopDefault( e ) { if ( e &amp;&amp; e.preventDefault ) { e.preventDefault(); //阻止默认浏览器动作(W3C) } else { window.event.returnValue = false; // IE中阻止函数器默认动作的方式 return false; } } 事件循环（Event Loop）和任务队列（Task Queue） JS 是单线程的，但是却能执行异步任务，这主要是因为 JS 中存在事件循环（Event Loop）和任务队列（Task Queue）。 事件循环 JS 会创建一个类似于 while (true) 的循环，每执行一次循环体的过程称之为 Tick。每次 Tick 的过程就是查看是否有待处理事件，如果有则取出相关事件及回调函数放入执行栈中由主线程执行。待处理的事件会存储在一个任务队列中，也就是每次 Tick 会查看任务队列中是否有需要执行的任务。 任务队列 异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。 onclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中。 setTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中。 ajax 则会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中。 主线程： JS 只有一个线程，称之为主线程。而事件循环是主线程中执行栈里的代码执行完毕之后，才开始执行的。 所以，主线程中要执行的代码时间过长，会阻塞事件循环的执行，也就会阻塞异步操作的执行。 只有当主线程中执行栈为空的时候（即同步代码执行完后），才会进行事件循环来观察要执行的事件回调，当事件循环检测到任务队列中有事件就取出相关回调放入执行栈中由主线程执行。 用示例来说明 例1： var req = new XMLHttpRequest(); req.open(&apos;GET&apos;, url); req.onload = function (){}; // 这两个异步方法就会在 ajax 完成后推入任务队列，再由主线程执行 req.onerror = function (){}; req.send(); 例2： setTimeout(function(){ // 如果有大量的操作，可能会阻塞 UI 等，则可以使用 setTimeout 让这些操作在主线程把更重要的代码执行完毕之后，再来执行这里的操作。从而提高浏览器的性能。 },0); // 设置为 0，也会有个最小间隔值，也会在主线程中的代码运行完成后，由事件循环从任务队列将回调添加到执行栈中才执行 例3： // 事件循环测试。执行结果是 2-3-4-1，1在最后输出，说明事件循环是所有同步代码执行完后才开始执行的。 &apos;use strict&apos;; setTimeout(function() { console.log(1); }, 0); console.log(2); let end = Date.now() + 1000*5; while (Date.now() &lt; end) { } console.log(3); end = Date.now() + 1000*5; while (Date.now() &lt; end) { } console.log(4); Update：《你不知道的 JavaScript》一书中，重新讲解了 ES6 新增的任务队列，和上面的任务队列略有不同，上面的任务队列书中称为事件队列。 上面提到的任务（事件）队列是在事件循环中的，事件循环每一次 tick 便执行上面所述的任务（事件）队列中的一个任务。而任务（事件）队列是只能往尾部添加任务。 而 ES6 中新增的任务队列是在事件循环之上的，事件循环每次 tick 后会查看 ES6 的任务队列中是否有任务要执行，也就是 ES6 的任务队列比事件循环中的任务（事件）队列优先级更高。 如 Promise 就使用了 ES6 的任务队列特性。 参考：http://www.cnblogs.com/Medeor/p/4945687.htmlhttp://www.ruanyifeng.com/blog/2014/10/event-loop.htmlhttp://www.cnblogs.com/zhaodongyu/p/3922961.html深入浅出 node.js]]></content>
      <categories>
        <category>Javascript</category>
        <category>事件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css布局总结]]></title>
    <url>%2F2015%2F05%2F20%2Fcss%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、两列布局写移动端项目的时候，经常遇到左边或右边是图片，需要固定宽度，中间自适应，是图片的内容介绍，需要垂直居中，且和两边高度对齐，这个时候用flex布局比较好，总结了两种比较常用的方法： 第一种：flex左边宽度固定，右边自适应/*父元素*/ .father { display: flex; } /*左边子元素*/ .left { flex: 0 0 30px; width: 30px; } .right { flex: 1; } 第二种：positon定位和padding-left用100%宽的一个div用paading-left把左边图片的位置留出来，图片绝对定位到padding-left区域 例如一个列表项，每一个item下面左边是图片，右边是说明 二、三列布局左侧和右侧固定，中间自适应 1.设置第一个DIV左浮动，第二个DIV右浮动，第三个DIV设置左右MARGIN为两个DIV的固定宽度 #box1 { float: left; width: 300px; background-color: #0099cc; } #box2 { float: right; width: 300px; background-color: #cc6600; } #box3 { height: 500px; background-color: #c30230; margin-left: 300px; margin-right: 300px; } &lt;div id=&quot;box1&quot;&gt;这是div1&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;这是div2&lt;/div&gt; &lt;div id=&quot;box3&quot;&gt;这是div3&lt;/div&gt; 2.父元素宽度100%，相对定位，左右子元素绝对定位，中间子元素设置margin-left和margin-right #wrapper { position: relative; width: 100%; } #box1 { position: absolute; top: 0; left: 0; width: 300px; height: 300px; background-color: #0099cc; } #box2 { height: 400px; margin-left: 300px; margin-right: 300px; background-color: #cc6600; } #box3 { position: absolute; top: 0; right: 0; width: 300px; height: 300px; background-color: #c30230; } 三、多列布局要横向排列的子元素设置float:left或者是display:inline-block,并且设置父元素的font-size为0 经典圣杯布局和淘宝双飞翼布局实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，也就是我们常说的固比固布局页面的宽度的变化，三栏布局是中间盒子优先渲染，两边的盒子框子固定不变 圣杯布局&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;h4&gt;中间弹性区&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;h4&gt;左边栏&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;h4&gt;右边栏&lt;/h4&gt;&lt;/div&gt; &lt;/div&gt; /*middle放在第一个，先渲染，宽度100%*/ .container{ padding: 0 200px; 左右盒子的宽度 height:200px; overflow:hidden; } .middle{ width: 100%; height: 200px; float:left; } .left{ position: relative; left: -200px width: 200px; height: 200px; float:left; margin-left: -100%; // 设置左边盒子负边距为中间盒子的宽度，即100%，可以在中间盒子的左边 } .right{ position: relative; //重点 right: -210px // 重点 width: 200px; height: 200px; float:left; margin-left: -200px; // 关键，这样才能在最右边 } 淘宝的双飞翼布局 淘宝的双飞翼布局是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。 &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inside&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; #middle{ float:left; width:100%;/*左栏上去到第一行*/ height:100px; } #left { float:left; width:180px; height:100px; margin-left:-100%; // 本来在第二行，此时上去到第一行 } #right{ float:left; width:200px; height:100px; margin-left:-200px; // 本来在第二行，此时到第一行 } /*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/ #inside{ margin:0 200px 0 180px; height:100px; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现垂直居中的方法]]></title>
    <url>%2F2015%2F05%2F12%2Fcss%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[不定宽高的子元素垂直水平居中的方法项目里面写静态页面的时候，多次自适应宽高的子元素需要设置垂直水平居中的方法，总结了一下，主要是利用css3的translate和flex两种方法 示例： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;con&quot;&gt;&lt;/div&gt; /div&gt; 第一种：css3的translate方法// 父元素 .box { position: relative; width: 500px; height: 300px; background-color: red; } // 子元素 .con { position: absolute; width: 20%; height: 50%; /*不定宽高*/ left: 50%; /*先移动父元素的50%*/ top: 50%; transform: translate(-50%, -50%); /*移动自身的50%*/ background-color: #000; } 第二种：flex方法.box { display: flex; justify-content: center; /*块居中对齐*/ align-items: center; /*块垂直居中*/ width: 300px; height: 300px; background-color: red; } .con { width: 30%; height: 40%; background-color: #000; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片优化之懒加载]]></title>
    <url>%2F2015%2F04%2F15%2F%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E4%B9%8B%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[页面里面图片资源比较丰富，做优化的时候，首先考虑的就是图片按需加载，延迟加载。 因为如果一次性都加载完，等待时间会比较长。而且用户可能本来就不会一直拉到页面底部浏览完才离开，所以即为了加载速度，又为了节约流量。可以等到需要的时候再加载图片。 jquery懒加载插件-Lazy Load地址：https://github.com/tuupola/jquery_lazyload 使用方法1.引入jquery和lazyload插件，或者直接npm安装 // npm 安装 $ npm install jquery-lazyload // 直接引入 &lt;script src=&quot;jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.lazyload.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 2.给html页面的img设置lazy样式，并用自定义属性来存储图片实际指向的地址 &lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; height=&quot;480&quot;&gt; 3.js调用 $(&quot;img.lazy&quot;).lazyload(); 4.注意:必须设置图片的宽高，否则插件无法正常工作 特殊需求参数设置设置临界点默认情况下图片会出现在屏幕时加载. 如果你想提前加载图片, 可以设置threshold 选项, 如：设置 threshold 为 200 令图片在距离屏幕 200 像素时提前加载. $(&quot;img&quot;).lazyload({ threshold : 200 }); 使用特效默认情况下，图像完全加载并调用show()。你可以使用任何你想要的效果。下面的代码使用fadeIn （淡入效果） $(&quot;img&quot;).lazyload({ effect : &quot;fadeIn&quot; }); 当图片不连续时滚动页面的时候, Lazy Load 会循环为加载的图片. 在循环中检测图片是否在可视区域内. 默认情况下在找到第一张不在可见区域的图片时停止循环. 图片被认为是流式分布的, 图片在页面中的次序和 HTML 代码中次序相同. 但是在一些布局中, 这样的假设是不成立的. 不过你可以通过 failurelimit 选项来控制加载行为. $(&quot;img&quot;).lazyload({ failure_limit : 20 // 将 failurelimit 设为 20 ，当插件找到 20 个不在可见区域的图片时停止搜索. }); 加载隐藏图片当界面有很多隐藏图片的时候并希望加载他们的时候则使用kip_invisible 属性，将其设置为false $(&quot;img&quot;).lazyload({ skip_invisible : false }); 其他的需求可以看官网的api 懒加载的原理页面的img元素，如果不给src属性，浏览器是不会发送请求去下载图片的，只有通过src设置了图片路径，浏览器才会发送请求。 懒加载就是页面打开的时候，先把页面里的所有img元素或者是其他元素的背景图片路径替换成一个大小为1*1px的图片的路径，用来占位。 把真正的路径存在元素的自定义属性“data-original”里面 页面加载完成，根据scrollTop判断图片是否出现在浏览器可视区域里，如果在，再把自定义属性里面的路径取出来，赋值给图片的src，让图片显示出来。 在滚动事件中重复判断图片是否进入视野，如果进入，就把data-original属性里面的值取出来放在src属性里面。 实现方法（一）获取窗口、窗口滚动和元素距离窗口顶部的偏移高度，计算元素是否出现在窗口范围内； 1）屏幕可视窗口的大小 js原生方法：window.innerHeight标准浏览器IE9+ || document.documentElement.clientHeight标准浏览器及ie||document.body.clientHeight jquery方法： $(window).height() 2）浏览器窗口顶部和文档顶部之间的距离，也就是滚动条的滚动的距离 原生js方法：window.pageYoffset (IE9+标准) || document.documentElement.scrollTop 兼容ie低版本的 || document.body.scrollTop 兼容混杂模式 jquery方法： $(document).scrollTop() 3）获取元素距离窗口顶部偏移高度 jquery方法：$(0).offset().top //距离文档顶部的距离 原生js：getoffsetTop() 判断图片是否在可视区域内 function isShow($el){ var winH = $(window).height(),//获取窗口高度 scrollH = $(window).scrollTop(),//获取窗口滚动高度 top = $el.offset().top;//获取元素距离窗口顶部偏移高度 if(top &lt; scrollH + winH){ return true;//在可视范围 }else{ return false;//不在可视范围 } } (二)监听窗口滚动事件，判断元素是否在可视范围内 $(window).on(&apos;scroll&apos;, function(){ //监听滚动事件 checkShow(); }) checkShow(); // 先加载一次，首屏 function checkShow(){ //检查元素是否在可视范围内 $(&apos;img&apos;).each(function(){ //遍历每一个元素 var $cur = $(this); if(!!isloaded($cur)){ return; } //判断是否已加载 if (isShow($cur)) { setTimeout(function(){ showImg($cur); },300) //设置时间是为了更好的看出效果 }; }); } （三）元素显示的时候，把之前的地址设置为data-origin的地址 function showImg($el){ $el.attr(&apos;src&apos;, $el.attr(&apos;data-src&apos;)); $cur.data(&apos;isloaded&apos;,true); }]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和Github搭建的博客]]></title>
    <url>%2F2015%2F04%2F01%2Fartical%2F</url>
    <content type="text"><![CDATA[博客迁移原因之前一直在印象笔记上做记录，单机版的，时间长了占用大量的本地内存。markdown写起来还是比较少的，偶然看到一个用hexo搭建的博客，简洁明了，花了几个小时的功夫，终于把这个博客搭建起来了，虽然功能还不完善，但是看起来还是很舒服的，后面有时间了再慢慢完善。这几天先把部分笔记迁移过来，权当再复习一遍知识。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>